<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rummikub Win Tracker</title>
    <!-- Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <style>
        /* CSS Styles (keep existing styles) */
        /* --- Basic Reset & Defaults --- */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; /* Ensure body takes full height */ }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; background-color: #f4f7f6; color: #333; padding-bottom: 50px; }
        .app-container { max-width: 600px; margin: 0 auto; padding: 15px; position: relative; z-index: 1; /* Ensure app content is below timer */ }
        /* --- Typography --- */
        h1, h2, h3 { margin-bottom: 0.8em; color: #0b4f6c; }
        h1 { text-align: center; margin-bottom: 1em; color: #012a4a; }
        p { margin-bottom: 1em; }
        /* --- Buttons --- */
        button { display: inline-block; padding: 10px 18px; font-size: 1rem; font-weight: bold; color: #fff; background-color: #219ebc; border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.2s ease; min-height: 44px; vertical-align: middle; -webkit-tap-highlight-color: transparent; /* Prevent flash on mobile tap */ }
        button:hover, button:focus { background-color: #1a7f9a; outline: none; }
        button:disabled { background-color: #adb5bd; cursor: not-allowed; }
        button.secondary { background-color: #6c757d; }
        button.secondary:hover, button.secondary:focus { background-color: #5a6268; }
        button.danger { background-color: #e76f51; }
        button.danger:hover, button:focus { background-color: #d95a3a; }
        button.icon-button { padding: 8px 10px; font-size: 0.9rem; margin-left: 5px; }
        button.small-nav-button { padding: 5px 10px; font-size: 0.9rem; min-height: 30px; margin: 0 5px; }
        /* --- Forms --- */
        input[type="text"] { width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 1rem; }
        label { display: block; margin-bottom: 5px; font-weight: 500; font-size: 0.9em; }
        /* --- Layout Sections --- */
        section { background-color: #fff; padding: 15px; margin-bottom: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); }
        /* --- Header & Player Management Toggle --- */
        header { margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; /* Allow wrapping */ }
        header h1 { margin-bottom: 0; flex-grow: 1; text-align: left; margin-right: 10px; /* Space before buttons */ }
        .header-buttons { display: flex; align-items: center; }
        #togglePlayerManagement { flex-shrink: 0; margin-left: 5px; } /* Spacing for manage button */
        #toggleTimerBtn { /* Style for the new timer button */
            flex-shrink: 0;
            margin-left: 10px; /* Space between buttons */
            background-color: #2a9d8f; /* Different color? */
            padding: 8px 10px;
            font-size: 0.9rem;
        }
        #toggleTimerBtn:hover, #toggleTimerBtn:focus {
            background-color: #258a7f;
        }

        /* --- Player Management Section --- */
        #playerManagement { border: 1px dashed #ccc; }
        #playerManagement.hidden { display: none; }
        .player-management-entry { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #eee; }
        .player-management-entry:last-child { border-bottom: none; }
        .player-management-entry span.player-name-display { flex-grow: 1; margin-right: 10px; } /* Target specific span */
        .rename-controls { display: flex; align-items: center; }
        .rename-controls input { width: 120px; margin-bottom: 0; margin-right: 5px; font-size: 0.9rem; padding: 5px 8px; }
        #timerAudioSettings { margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee; }
        #timerAudioSettings h4 { margin-bottom: 0.5em; color: #333; }
        #timerAudioSettings button { margin-top: 5px; margin-right: 5px; font-size:0.9rem; padding: 8px 12px; }
        #audioUrlStatus { font-size: 0.9em; margin-top: 8px; line-height: 1.3; }
        /* --- Score Tracking Section --- */
        #scoreTrackingList li, #todaysWinsList li { display: flex; justify-content: space-between; align-items: center; padding: 12px 5px; border-bottom: 1px solid #eee; }
        #scoreTrackingList li:last-child, #todaysWinsList li:last-child { border-bottom: none; }

        /* UPDATED: Player Info Wrapper Styling */
        .player-info {
            flex-grow: 1; /* Take up available space */
            margin-right: 10px; /* Space before button */
        }
        .player-name {
            font-weight: bold;
            display: block; /* Ensure name is on its own line */
            overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
        }
        .win-timestamp { font-size: 0.85em; color: #666; margin-left: 10px; margin-right: 10px; white-space: nowrap; }

        /* UPDATED: Win Feedback Message Styling */
        .win-feedback {
            display: block; /* Place on new line */
            font-size: 0.85em; /* Slightly smaller */
            color: #28a745; /* Green */
            margin-top: 2px; /* Small space below name */
            font-style: italic;
            animation: fadeOut 3s forwards; /* Make it fade out */
            line-height: 1.2; /* Adjust line height if needed */
        }
        @keyframes fadeOut {
            0% { opacity: 1; }
            80% { opacity: 1; } /* Stay visible for most of the duration */
            100% { opacity: 0; }
        }

        /* --- Dashboard --- */
        .dashboard-controls { display: flex; justify-content: space-around; margin-bottom: 15px; flex-wrap: wrap; }
        .dashboard-controls button { flex-grow: 1; margin: 5px; background-color: #f8f9fa; color: #0b4f6c; border: 1px solid #dee2e6; }
        .dashboard-controls button.active { background-color: #0b4f6c; color: #fff; font-weight: bold; border-color: #0b4f6c; }
        .dashboard-view-toggle { text-align: center; margin-bottom: 15px; }
        .dashboard-view-toggle .small-nav-button {
            background-color: #e9ecef;  /* Light grey background */
            color: #495057;           /* Dark grey text */
            border: 1px solid #ced4da; /* Visible but subtle border */
            font-weight: normal;       /* Ensure text is not bold */
        }
        .dashboard-view-toggle .small-nav-button.active {
            background-color: #0b4f6c;  /* Dark blue background (matches period buttons) */
            color: #ffffff;           /* White text */
            border-color: #0b4f6c;   /* Border matches background (looks solid) */
            font-weight: bold;         /* Bold text */
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.1); /* Optional: subtle inset shadow */
        }
        .chart-title-container { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .chart-title-container h3 { margin-bottom: 0; text-align: center; flex-grow: 1; color: #333; font-weight: bold; }
        #winChartContainer, #monthlyChartContainer { background-color: #f8f9fa; padding: 20px 10px 10px 10px; border-radius: 5px; min-height: 320px; position: relative; }
        #chart, #monthlyChart { position: relative; height: 270px; width: 100%; }
        canvas.hidden { display: none; }
        /* --- Utility Classes --- */
        .hidden { display: none !important; }
        .text-center { text-align: center; }
        .error-message { color: #d95a3a; font-size: 0.9em; margin-top: -5px; margin-bottom: 10px; }
        .no-data {
            color: #6c757d;
            text-align: center;
            padding: 20px;
            font-style: italic;
            margin-top: 20px; /* Add some space */
        }
        /* --- List Styling --- */
        ul { list-style: none; padding: 0; }

        /* --- Style for Total Wins Display --- */
        .total-wins-display {
            font-size: 0.9em;
            color: #555;
            margin-top: -5px; /* Adjust spacing relative to title */
            margin-bottom: 10px;
            font-weight: bold;
        }
        /* --- Today's Summary Style --- */
        .todays-summary {
            font-size: 0.95em;
            color: #444;
            background-color: #eef3f5; /* Light background */
            padding: 8px 12px;
            border-radius: 4px;
            margin-bottom: 15px; /* Space before the list */
            border-left: 3px solid #219ebc; /* Accent border */
        }
        .todays-summary.hidden {
            display: none;
        }
        .todays-summary span { /* Style for individual player summaries */
             display: inline-block; /* Allow spacing */
             margin-right: 15px; /* Space between players */
        }
        .todays-summary span:last-child {
            margin-right: 0;
        }

        /* --- Timer Overlay Styles --- */
        #timerOverlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #333333; z-index: 1000;
            display: none; flex-direction: column; justify-content: center; align-items: center;
            overflow: hidden;
        }
        #timerFill {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 100%;
            background-color: #4CAF50; transition: height 0.1s linear; z-index: 1;
        }
        #timerDisplay {
            font-size: 10em; font-weight: bold; color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 2; position: relative;
        }
        #hideTimerBtn {
            position: absolute; top: 20px; right: 20px;
            padding: 12px 24px; font-size: 1.2rem;
            background-color: rgba(255, 255, 255, 0.7); color: #333;
            border: 1px solid #ccc; border-radius: 5px; cursor: pointer; z-index: 2;
        }
        #hideTimerBtn:hover { background-color: rgba(255, 255, 255, 0.9); }
        #nextTimerBtn {
            margin-top: 25px; padding: 18px 40px; font-size: 1.8rem; min-width: 150px;
            font-weight: bold; background-color: rgba(255, 255, 255, 0.7); color: #333;
            border: 1px solid #ccc; border-radius: 8px; cursor: pointer; z-index: 2;
            transition: background-color 0.2s ease;
        }
        #nextTimerBtn:hover { background-color: rgba(255, 255, 255, 0.95); }

    </style>
</head>
<body>

    <!-- Timer Overlay -->
    <div id="timerOverlay">
        <div id="timerFill"></div>
        <div id="timerDisplay">1:00</div>
        <button id="nextTimerBtn" aria-label="Next Turn Timer">NEXT</button>
        <button id="hideTimerBtn" aria-label="Hide Timer">Hide Timer</button>
    </div>
    <!-- Audio Element for Timer - src will be set by JS -->
    <audio id="timerAudio" preload="auto"></audio>

    <!-- App Container -->
    <div class="app-container">
         <header>
            <h1>Rummikub Wins</h1>
            <div class="header-buttons">
                 <button id="toggleTimerBtn" aria-label="Show Timer">‚è±Ô∏è Timer</button>
                 <button id="togglePlayerManagement" class="secondary icon-button" aria-label="Manage Players" title="Manage Players">‚öôÔ∏è Manage</button>
            </div>
        </header>

        <!-- Player Management Section -->
        <section id="playerManagement" class="hidden">
            <h3>Manage Players</h3>
            <div id="addPlayerForm">
                <input type="text" id="newPlayerName" placeholder="New Player Name">
                <button id="addPlayerBtn">Add Player</button>
                <div id="addPlayerError" class="error-message"></div>
            </div>
            <ul id="playerListManagement"></ul>
            <p id="noPlayersManaged" class="no-data hidden">No players added yet.</p>

            <!-- Timer Audio Settings -->
            <div id="timerAudioSettings">
                <h4>Timer Alarm Sound</h4>
                <label for="customAudioUrlInput">Custom Audio URL (e.g., direct link to MP3, WAV):</label>
                <input type="text" id="customAudioUrlInput" placeholder="Enter direct audio link here">
                <button id="saveAudioUrlBtn">Save Audio URL</button>
                <button id="resetAudioUrlBtn" class="secondary">Reset to Default</button>
                <div id="audioUrlStatus"></div>
            </div>
        </section>

        <!-- Dashboard / Statistics Section (Keep existing structure) -->
        <section id="dashboard">
            <h2>Dashboard</h2>
            <div class="dashboard-controls">
                <button data-period="month" class="active">This Month</button>
                <button data-period="week">This Week</button>
                <button data-period="year">This Year</button>
            </div>
            <div class="dashboard-view-toggle">
                 <button id="playerViewBtn" class="secondary small-nav-button active">Player Wins</button>
                 <button id="monthlyViewBtn" class="secondary small-nav-button">Monthly Breakdown</button>
            </div>
            <div id="winChartContainer">
                 <div class="chart-title-container">
                     <button id="prevPeriodBtn" class="secondary small-nav-button hidden" aria-label="Previous Period">‚¨ÖÔ∏è Prev</button>
                     <h3 id="winChartTitle">Wins This Week</h3>
                     <button id="nextPeriodBtn" class="secondary small-nav-button hidden" aria-label="Next Period">Next ‚û°Ô∏è</button>
                 </div>
                 <p id="totalPlayerWinsDisplay" class="total-wins-display text-center"></p>
                 <div id="chart">
                     <canvas id="playerWinCanvas"></canvas>
                     <p id="noChartData" class="no-data hidden">No wins recorded for this period.</p>
                 </div>
            </div>
            <div id="monthlyChartContainer" class="hidden">
                 <div class="chart-title-container">
                     <button id="prevYearBtn" class="secondary small-nav-button" aria-label="Previous Year">‚¨ÖÔ∏è Prev Yr</button>
                     <h3 id="monthlyChartTitle">Monthly Winners for 2023</h3>
                     <button id="nextYearBtn" class="secondary small-nav-button" aria-label="Next Year">Next Yr ‚û°Ô∏è</button>
                 </div>
                 <p id="totalMonthlyWinsDisplay" class="total-wins-display text-center"></p>
                 <div id="monthlyChart">
                      <canvas id="monthlyWinsCanvas"></canvas>
                      <p id="noMonthlyChartData" class="no-data hidden">No wins recorded for this year.</p>
                 </div>
            </div>
        </section>

        <!-- Score Tracking Interface (Keep existing structure) -->
        <section id="scoreTracking">
            <h2>Record a Win</h2>
            <ul id="scoreTrackingList"></ul>
             <p id="noPlayersForScoring" class="no-data hidden">Add players in 'Manage Players' to track wins.</p>
        </section>

        <!-- Today's Recorded Wins Management (Keep existing structure) -->
        <section id="todaysWins">
             <h3>Recorded Today (<span id="todayDateDisplay"></span>)</h3>
             <div id="todaysSummary" class="todays-summary hidden"></div>
             <ul id="todaysWinsList"></ul>
             <p id="noWinsToday" class="no-data">No wins recorded yet today.</p>
        </section>

        <!-- Firebase Placeholders (Keep existing structure) -->
        <div id="firebaseConfigWarning" style="padding: 10px; margin-top: 20px; background-color: #fff3cd; border: 1px solid #ffeeba; border-radius: 5px; font-size: 0.9em;">
            <strong>Firebase Setup:</strong> Ensure the `firebaseConfig` in the JavaScript below is correct...
        </div>
        <div id="firebaseError" style="display: none; padding: 10px; margin-top: 10px; background-color: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; border-radius: 5px; font-size: 0.9em;">
             <strong>Firebase Error:</strong> <span id="firebaseErrorMessage"></span>
        </div>
    </div><!-- /app-container -->

    <script type="module">

        // --- Firebase SDK Imports ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getFirestore, collection, getDocs, addDoc, deleteDoc, updateDoc, doc, query, where, orderBy, Timestamp, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";

        // --- Firebase Configuration (Replace with your actual config!) ---
        const firebaseConfig = {
          apiKey: "AIzaSyD-e3H5CaoQobBqFwzDnCGZCUbniZQg_J0", // Replace!
          authDomain: "i-am-awesome-tasker.firebaseapp.com", // Replace!
          projectId: "i-am-awesome-tasker", // Replace!
          storageBucket: "i-am-awesome-tasker.appspot.com", // Replace!
          messagingSenderId: "853316153385", // Replace!
          appId: "1:853316153385:web:db1fc1304b54a198a82c38", // Replace!
          measurementId: "G-ZDBF73CFXS" // Optional: Replace!
        };

        // --- Firebase Initialization ---
        let app, db;
        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            console.log("Firebase Initialized Successfully");
            document.getElementById('firebaseConfigWarning').style.display = 'none';
        } catch (error) {
            console.error("Firebase Initialization Error:", error);
            const e = document.getElementById('firebaseError');
            document.getElementById('firebaseErrorMessage').textContent = `Could not initialize Firebase. Check config/console. Error: ${error.message}`;
            e.style.display = 'block';
            document.getElementById('firebaseConfigWarning').style.backgroundColor = '#f8d7da';
            document.querySelectorAll('button').forEach(b => {
                if(b.id !== 'togglePlayerManagement' && b.id !== 'toggleTimerBtn') b.disabled = true;
            });
            throw new Error("Firebase initialization failed, stopping script execution.");
        }

        // --- Global State ---
        let players = [];
        let wins = [];
        let currentDashboardPeriod = 'month';
        let currentDisplayDate = new Date();
        let currentView = 'player';
        let playerWinChartInstance = null;
        let monthlyChartInstance = null;
        // --- Timer State ---
        let timerTimeoutId = null;
        const TIMER_DURATION_SECONDS = 60;
        let timerRemainingSeconds = TIMER_DURATION_SECONDS;
        let isTimerVisible = false;
        let audioUnlocked = false;
        // --- Wake Lock State ---
        let wakeLockSentinel = null;
        // --- Audio Settings State ---
        const DEFAULT_AUDIO_URL = "https://www.dropbox.com/scl/fi/540eent9p1es21f4ep2ix/trompo_1-edit.mp3?rlkey=m0hhk27s8892ow6eyogpqxm00&st=zi9nt3i9&dl=1";
        const LOCAL_STORAGE_AUDIO_KEY = 'rummikubTimerAudioURL';


        // --- DOM Elements ---
        // (Keep existing DOM element references)
         const togglePlayerManagementBtn = document.getElementById('togglePlayerManagement');
         const playerManagementSection = document.getElementById('playerManagement');
         const addPlayerBtn = document.getElementById('addPlayerBtn');
         const newPlayerNameInput = document.getElementById('newPlayerName');
         const addPlayerError = document.getElementById('addPlayerError');
         const playerListManagementUl = document.getElementById('playerListManagement');
         const noPlayersManagedMsg = document.getElementById('noPlayersManaged');
         const dashboardControls = document.querySelector('.dashboard-controls');
         const playerViewBtn = document.getElementById('playerViewBtn');
         const monthlyViewBtn = document.getElementById('monthlyViewBtn');
         const winChartContainer = document.getElementById('winChartContainer');
         const winChartTitle = document.getElementById('winChartTitle');
         const playerWinCanvas = document.getElementById('playerWinCanvas');
         const noChartDataMsg = document.getElementById('noChartData');
         const prevPeriodBtn = document.getElementById('prevPeriodBtn');
         const nextPeriodBtn = document.getElementById('nextPeriodBtn');
         const monthlyChartContainer = document.getElementById('monthlyChartContainer');
         const monthlyChartTitle = document.getElementById('monthlyChartTitle');
         const monthlyWinsCanvas = document.getElementById('monthlyWinsCanvas');
         const noMonthlyChartDataMsg = document.getElementById('noMonthlyChartData');
         const prevYearBtn = document.getElementById('prevYearBtn');
         const nextYearBtn = document.getElementById('nextYearBtn');
         const scoreTrackingListUl = document.getElementById('scoreTrackingList');
         const noPlayersForScoringMsg = document.getElementById('noPlayersForScoring');
         const todayDateDisplay = document.getElementById('todayDateDisplay');
         const todaysWinsListUl = document.getElementById('todaysWinsList');
         const noWinsTodayMsg = document.getElementById('noWinsToday');
         const todaysSummaryDiv = document.getElementById('todaysSummary');
         const toggleTimerBtn = document.getElementById('toggleTimerBtn');
         const timerOverlay = document.getElementById('timerOverlay');
         const timerFill = document.getElementById('timerFill');
         const timerDisplay = document.getElementById('timerDisplay');
         const hideTimerBtn = document.getElementById('hideTimerBtn');
         const timerAudio = document.getElementById('timerAudio');
         const nextTimerBtn = document.getElementById('nextTimerBtn');
         const totalPlayerWinsDisplay = document.getElementById('totalPlayerWinsDisplay');
         const totalMonthlyWinsDisplay = document.getElementById('totalMonthlyWinsDisplay');
         // New DOM Elements for Audio Settings
         const customAudioUrlInput = document.getElementById('customAudioUrlInput');
         const saveAudioUrlBtn = document.getElementById('saveAudioUrlBtn');
         const resetAudioUrlBtn = document.getElementById('resetAudioUrlBtn');
         const audioUrlStatus = document.getElementById('audioUrlStatus');


        // --- Utility Functions ---
        // (Keep existing utility functions)
        const getTodayDateString = () => new Date().toDateString();
        const formatTime = (timestamp) => { if (!timestamp) return ''; const date = timestamp.toDate ? timestamp.toDate() : (timestamp instanceof Date ? timestamp : null); if (!date) return ''; return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); };
        const getMonthName = (monthIndex) => ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][monthIndex];
        const getFullMonthName = (monthIndex) => ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"][monthIndex];
        const getPeriodRange = (period, baseDate = new Date()) => { let start = new Date(baseDate); let end = new Date(baseDate); switch (period) { case 'week': const dayOfWeek = start.getDay(); const diff = start.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1); start = new Date(start.setDate(diff)); start.setHours(0, 0, 0, 0); end = new Date(start); end.setDate(start.getDate() + 6); end.setHours(23, 59, 59, 999); break; case 'month': start = new Date(start.getFullYear(), start.getMonth(), 1); start.setHours(0, 0, 0, 0); end = new Date(start.getFullYear(), start.getMonth() + 1, 0); end.setHours(23, 59, 59, 999); break; case 'year': start = new Date(start.getFullYear(), 0, 1); start.setHours(0, 0, 0, 0); end = new Date(start.getFullYear(), 11, 31); end.setHours(23, 59, 59, 999); break; } return { start, end }; };
        const sanitizeHTML = (str) => { const temp = document.createElement('div'); temp.textContent = str; return temp.innerHTML; };
        const pluralize = (count, singular, plural = null) => { plural = plural ?? singular + 's'; return count === 1 ? `${count} ${singular}` : `${count} ${plural}`; }

        // --- Data Handling Functions (Firebase) ---
        // (Keep existing Firebase functions)
        const loadData = async () => { if (!db) { console.error("DB not available."); return; } console.log("Loading data..."); try { const playersCollection = collection(db, "players"); const playerQuery = query(playersCollection, orderBy("name")); const playerSnapshot = await getDocs(playerQuery); players = playerSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); const winsCollection = collection(db, "wins"); const winSnapshot = await getDocs(winsCollection); wins = winSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); wins = wins.filter(w => w.timestamp && typeof w.timestamp.toDate === 'function'); wins.sort((a, b) => b.timestamp.toMillis() - a.timestamp.toMillis()); } catch (error) { console.error("Error loading data:", error); const e = document.getElementById('firebaseError'); document.getElementById('firebaseErrorMessage').textContent = `Failed to load data. Error: ${error.message}`; e.style.display = 'block'; players = []; wins = []; } renderApp(); };
        const addPlayer = async (name) => { if (!db) { alert("DB error."); return; } const tN = name.trim(); if (!tN) { addPlayerError.textContent = "Name empty."; return; } if (players.some(p => p.name.toLowerCase() === tN.toLowerCase())) { addPlayerError.textContent = "Name exists."; return; } addPlayerError.textContent = ""; addPlayerBtn.disabled = true; try { const dR = await addDoc(collection(db, "players"), { name: tN }); players.push({ id: dR.id, name: tN }); players.sort((a, b) => a.name.localeCompare(b.name)); renderApp(); newPlayerNameInput.value = ''; } catch (error) { console.error("Error adding:", error); addPlayerError.textContent = `Failed: ${error.message}`; } finally { addPlayerBtn.disabled = false; } };
        const deletePlayer = async (playerId) => { if (!db) { alert("DB error."); return; } const p = players.find(pl => pl.id === playerId); if (!p || !confirm(`Delete ${p.name}? Wins remain as 'Unknown'.`)) return; const dB = playerListManagementUl.querySelector(`.player-management-entry[data-player-id="${playerId}"] .delete-player-btn`); if (dB) dB.disabled = true; try { await deleteDoc(doc(db, "players", playerId)); players = players.filter(pl => pl.id !== playerId); renderApp(); } catch (error) { console.error("Error deleting:", error); alert(`Failed: ${error.message}`); if (dB) dB.disabled = false; } };
        const renamePlayer = async (playerId, newName) => { if (!db) { alert("DB error."); return false; } const tN = newName.trim(); if (!tN) { alert("Name empty."); return false; } if (players.some(p => p.id !== playerId && p.name.toLowerCase() === tN.toLowerCase())) { alert("Name exists."); return false; } const pI = players.findIndex(p => p.id === playerId); if (pI === -1) return false; const en = playerListManagementUl.querySelector(`.player-management-entry[data-player-id="${playerId}"]`); const sB = en?.querySelector('.save-rename-btn'); const cB = en?.querySelector('.cancel-rename-btn'); if(sB) sB.disabled = true; if(cB) cB.disabled = true; try { await updateDoc(doc(db, "players", playerId), { name: tN }); players[pI].name = tN; players.sort((a, b) => a.name.localeCompare(b.name)); renderApp(); return true; } catch (error) { console.error("Error renaming:", error); alert(`Failed: ${error.message}`); if(sB) sB.disabled = false; if(cB) cB.disabled = false; return false; } };
        const recordWin = async (playerId) => { if (!db) { alert("DB error."); return; } const player = players.find(pl => pl.id === playerId); if (!player) return; const winButton = scoreTrackingListUl.querySelector(`button.add-win-btn[data-player-id="${playerId}"]`); const playerInfoDiv = scoreTrackingListUl.querySelector(`li[data-player-id="${playerId}"] .player-info`); if (winButton) winButton.disabled = true; const existingFeedback = playerInfoDiv?.querySelector('.win-feedback'); if (existingFeedback) existingFeedback.remove(); try { const docRef = await addDoc(collection(db, "wins"), { playerId: playerId, timestamp: serverTimestamp() }); const newWin = { id: docRef.id, playerId: playerId, timestamp: Timestamp.now() }; wins.unshift(newWin); const playerName = sanitizeHTML(player.name); const feedbackSpan = document.createElement('span'); feedbackSpan.className = 'win-feedback'; feedbackSpan.textContent = `Win added for ${playerName}!`; if (playerInfoDiv) { playerInfoDiv.appendChild(feedbackSpan); setTimeout(() => { feedbackSpan.remove(); }, 3000); } renderTodaysWinsList(); renderDashboard(); } catch (error) { console.error("Error recording win:", error); alert(`Failed to record win: ${error.message}`); } finally { setTimeout(() => { if (winButton) winButton.disabled = false; }, 500); } };
        const deleteWin = async (winId) => { if (!db) { alert("DB error."); return; } const wI = wins.findIndex(w => w.id === winId); if (wI === -1) return; const wD = wins[wI]; if (!wD.timestamp || typeof wD.timestamp.toDate !== 'function') return; const pN = players.find(p=>p.id === wD.playerId)?.name ?? 'Unknown Player'; if (!confirm(`Delete win for ${sanitizeHTML(pN)} at ${formatTime(wD.timestamp)}?`)) return; const dB = todaysWinsListUl.querySelector(`li[data-win-id="${winId}"] .delete-win-btn`); if(dB) dB.disabled = true; try { await deleteDoc(doc(db, "wins", winId)); wins.splice(wI, 1); renderTodaysWinsList(); renderDashboard(); } catch (error) { console.error("Error deleting win:", error); alert(`Failed: ${error.message}`); if(dB) dB.disabled = false; } };
        const getWinsForPeriodLocal = (period, baseDate = new Date()) => { const { start, end } = getPeriodRange(period, baseDate); const sT = start.getTime(); const eT = end.getTime(); return wins.filter(w => { if (!w.timestamp || typeof w.timestamp.toDate !== 'function') return false; const wT = w.timestamp.toDate().getTime(); return wT >= sT && wT <= eT; }); };
        const getWinsForYearLocal = (year) => { const s = new Date(year, 0, 1); const e = new Date(year, 11, 31, 23, 59, 59, 999); const sT = s.getTime(); const eT = e.getTime(); return wins.filter(w => { if (!w.timestamp || typeof w.timestamp.toDate !== 'function') return false; const wT = w.timestamp.toDate().getTime(); return wT >= sT && wT <= eT; }); };

        // --- Rendering Functions ---
        // (Keep existing rendering functions)
        const renderPlayerManagementList = () => { playerListManagementUl.innerHTML = ''; noPlayersManagedMsg.classList.toggle('hidden', players.length > 0); if (players.length === 0) return; players.forEach(p => { const li = document.createElement('li'); li.className = 'player-management-entry'; li.dataset.playerId = p.id; const sN = sanitizeHTML(p.name); li.innerHTML = ` <span class="player-name-display">${sN}</span> <div class="rename-controls hidden"> <input type="text" class="rename-input" value="${sN}" aria-label="New name for ${sN}"> <button class="save-rename-btn icon-button" aria-label="Save rename">‚úîÔ∏è</button> <button class="cancel-rename-btn icon-button secondary" aria-label="Cancel rename">‚ùå</button> </div> <div class="action-buttons"> <button class="rename-btn icon-button secondary" aria-label="Rename ${sN}">‚úèÔ∏è Rename</button> <button class="delete-player-btn icon-button danger" aria-label="Delete ${sN}">üóëÔ∏è Delete</button> </div> `; playerListManagementUl.appendChild(li); }); };
        const renderScoreTrackingList = () => { scoreTrackingListUl.innerHTML = ''; noPlayersForScoringMsg.classList.toggle('hidden', players.length > 0); if (players.length === 0) return; players.forEach(p => { const li = document.createElement('li'); li.dataset.playerId = p.id; const sN = sanitizeHTML(p.name); li.innerHTML = ` <div class="player-info"> <span class="player-name">${sN}</span> </div> <button class="add-win-btn" data-player-id="${p.id}">+ Win</button> `; scoreTrackingListUl.appendChild(li); }); };
        const renderTodaysWinsList = () => { todaysWinsListUl.innerHTML = ''; todaysSummaryDiv.innerHTML = ''; todaysSummaryDiv.classList.add('hidden'); const todayStr = getTodayDateString(); todayDateDisplay.textContent = todayStr; const todaysWins = wins.filter(w => w.timestamp?.toDate().toDateString() === todayStr); noWinsTodayMsg.classList.toggle('hidden', todaysWins.length > 0); if (todaysWins.length > 0) { const winsByPlayerToday = todaysWins.reduce((acc, win) => { acc[win.playerId] = (acc[win.playerId] || 0) + 1; return acc; }, {}); const summaryItems = []; const sortedPlayerIds = Object.keys(winsByPlayerToday).sort((a, b) => { const playerA = players.find(p => p.id === a); const playerB = players.find(p => p.id === b); const nameA = playerA ? playerA.name : 'Unknown'; const nameB = playerB ? playerB.name : 'Unknown'; return nameA.localeCompare(nameB); }); sortedPlayerIds.forEach(playerId => { const count = winsByPlayerToday[playerId]; const player = players.find(p => p.id === playerId); const playerName = player ? sanitizeHTML(player.name) : 'Unknown Player'; summaryItems.push(`<span>${playerName}: ${pluralize(count, 'win')}</span>`); }); if (summaryItems.length > 0) { todaysSummaryDiv.innerHTML = `<strong>Summary:</strong> ${summaryItems.join(' ')}`; todaysSummaryDiv.classList.remove('hidden'); } todaysWins.forEach(w => { const player = players.find(pl => pl.id === w.playerId); const playerName = player ? sanitizeHTML(player.name) : 'Unknown Player'; const li = document.createElement('li'); li.dataset.winId = w.id; li.innerHTML = ` <span class="player-name">${playerName}</span> <span class="win-timestamp">${formatTime(w.timestamp)}</span> <button class="delete-win-btn icon-button danger" aria-label="Delete this win">üóëÔ∏è</button> `; todaysWinsListUl.appendChild(li); }); } };
        const renderDashboard = () => { dashboardControls.querySelectorAll('button[data-period]').forEach(b => { b.classList.toggle('active', b.dataset.period === currentDashboardPeriod); }); playerViewBtn.classList.toggle('active', currentView === 'player'); monthlyViewBtn.classList.toggle('active', currentView === 'monthly'); winChartContainer.classList.toggle('hidden', currentView !== 'player'); monthlyChartContainer.classList.toggle('hidden', currentView === 'player'); if (currentView === 'player') { renderPlayerWinsChart(currentDashboardPeriod, currentDisplayDate); } else if (currentView === 'monthly') { renderMonthlyBreakdownChart(currentDisplayDate.getFullYear()); } };
        const renderPlayerWinsChart = (period, displayDate) => { if (playerWinChartInstance) { playerWinChartInstance.destroy(); playerWinChartInstance = null; } const { start, end } = getPeriodRange(period, displayDate); let chartTitleText = ''; const today = new Date(); today.setHours(0, 0, 0, 0); const currentPeriodRange = getPeriodRange(period, today); const isCurrentPeriod = currentPeriodRange.start.getTime() === start.getTime(); switch (period) { case 'week': chartTitleText = isCurrentPeriod ? 'Wins This Week' : `Week of ${start.toLocaleDateString()}`; break; case 'month': const monthName = getFullMonthName(displayDate.getMonth()); chartTitleText = isCurrentPeriod ? `Wins This ${monthName}` : `Wins ${monthName} ${displayDate.getFullYear()}`; break; case 'year': chartTitleText = isCurrentPeriod ? `Wins This Year (${displayDate.getFullYear()})` : `Wins ${displayDate.getFullYear()}`; break; } winChartTitle.textContent = chartTitleText; prevPeriodBtn.classList.remove('hidden'); nextPeriodBtn.classList.remove('hidden'); const endOfToday = new Date(); endOfToday.setHours(23, 59, 59, 999); nextPeriodBtn.disabled = end.getTime() >= endOfToday.getTime(); const periodWins = getWinsForPeriodLocal(period, displayDate); const totalWinsCount = periodWins.length; totalPlayerWinsDisplay.textContent = `Total Wins: ${totalWinsCount}`; totalPlayerWinsDisplay.classList.remove('hidden'); const hasPlayers = players.length > 0; const hasData = totalWinsCount > 0; let playerData = []; if (hasPlayers) { const winsByPlayer = players.reduce((acc, p) => { acc[p.id] = { name: p.name, count: 0 }; return acc; }, {}); periodWins.forEach(w => { if (w.playerId && winsByPlayer[w.playerId]) { winsByPlayer[w.playerId].count++; } }); playerData = Object.values(winsByPlayer); playerData.sort((a, b) => a.name.localeCompare(b.name)); } const showChart = hasPlayers && hasData; playerWinCanvas.classList.toggle('hidden', !showChart); noChartDataMsg.classList.toggle('hidden', showChart); if (!hasPlayers) { noChartDataMsg.textContent = "Add players to see statistics."; totalPlayerWinsDisplay.classList.add('hidden'); } else if (!hasData) { noChartDataMsg.textContent = "No wins recorded for this period."; } if (showChart) { const ctx = playerWinCanvas.getContext('2d'); if (!ctx) { console.error("Failed to get playerWinCanvas context"); return; } const labels = playerData.map(p => p.name); const dataCounts = playerData.map(p => p.count); playerWinChartInstance = new Chart(ctx, { type: 'bar', data: { labels: labels, datasets: [{ label: 'Wins', data: dataCounts, backgroundColor: '#219ebc', borderColor: '#1a7f9a', borderWidth: 1 }] }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true, ticks: { stepSize: 1, precision: 0 } } }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: function(c) { let l = c.dataset.label || ''; if (l) { l += ': '; } if (c.parsed.y !== null) { l += c.parsed.y + (c.parsed.y === 1 ? ' win' : ' wins'); } return l; } } } } } }); } };
        const renderMonthlyBreakdownChart = (year) => { if (monthlyChartInstance) { monthlyChartInstance.destroy(); monthlyChartInstance = null; } monthlyChartTitle.textContent = `Monthly Winners for ${year}`; nextYearBtn.disabled = year >= new Date().getFullYear(); const yearWins = getWinsForYearLocal(year); const totalWinsCount = yearWins.length; const hasData = totalWinsCount > 0; totalMonthlyWinsDisplay.textContent = `Total Wins: ${totalWinsCount}`; totalMonthlyWinsDisplay.classList.remove('hidden'); let monthlyResults = []; let overallMaxWinningScore = 0; if(hasData) { const monthlyPlayerWins = {}; yearWins.forEach(win => { if (win.timestamp && typeof win.timestamp.toDate === 'function' && win.playerId) { const mI = win.timestamp.toDate().getMonth(); monthlyPlayerWins[mI] = monthlyPlayerWins[mI] || {}; monthlyPlayerWins[mI][win.playerId] = (monthlyPlayerWins[mI][win.playerId] || 0) + 1; } }); for (let i = 0; i < 12; i++) { const monthData = monthlyPlayerWins[i]; let winners = []; let maxScore = 0; if (monthData && Object.keys(monthData).length > 0) { maxScore = Math.max(...Object.values(monthData)); if (maxScore > overallMaxWinningScore) { overallMaxWinningScore = maxScore; } winners = Object.entries(monthData) .filter(([_, score]) => score === maxScore) .map(([playerId, _]) => sanitizeHTML(players.find(p => p.id === playerId)?.name ?? 'Unknown')); } monthlyResults.push({ monthIndex: i, winnerNames: winners, winningScore: maxScore }); } } else { for (let i = 0; i < 12; i++) { monthlyResults.push({ monthIndex: i, winnerNames: [], winningScore: 0 }); } } monthlyWinsCanvas.classList.toggle('hidden', !hasData); noMonthlyChartDataMsg.classList.toggle('hidden', hasData); if (!hasData) { noMonthlyChartDataMsg.textContent = `No wins recorded for ${year}.`; } if(hasData) { const ctx = monthlyWinsCanvas.getContext('2d'); if (!ctx) { console.error("Failed to get monthlyWinsCanvas context"); return; } const labels = monthlyResults.map(r => getMonthName(r.monthIndex)); const dataScores = monthlyResults.map(r => r.winningScore); const yAxisMax = Math.max(3, overallMaxWinningScore + 2); monthlyChartInstance = new Chart(ctx, { type: 'bar', data: { labels: labels, datasets: [{ label: 'Winning Score', data: dataScores, backgroundColor: '#fdc500', borderColor: '#e8b700', borderWidth: 1 }] }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true, max: yAxisMax, ticks: { stepSize: 1, precision: 0 } } }, plugins: { legend: { display: false }, tooltip: { callbacks: { title: (tooltipItems) => `${getFullMonthName(tooltipItems[0].dataIndex)} ${year}`, label: (context) => { const index = context.dataIndex; const result = monthlyResults[index]; let winnerLabel = ''; if (!result || result.winnerNames.length === 0) winnerLabel = 'Winner: N/A'; else if (result.winnerNames.length === 1) winnerLabel = `Winner: ${result.winnerNames[0]}`; else winnerLabel = `Tie: ${result.winnerNames.join(', ')}`; const scoreLabel = `Score: ${context.parsed.y}`; return [winnerLabel, scoreLabel]; } } }, datalabels: { display: (context) => context.dataset.data[context.dataIndex] > 0, anchor: 'end', align: 'top', offset: -2, color: '#555', font: { size: 10, weight: 'bold' }, formatter: (value, context) => { const index = context.dataIndex; const result = monthlyResults[index]; if (!result || result.winnerNames.length === 0) { return ''; } else if (result.winnerNames.length === 1) { let name = result.winnerNames[0]; return name.length > 8 ? name.substring(0, 7) + '‚Ä¶' : name; } else { return 'Tie'; } } } } } }); } };
        const renderApp = () => { renderPlayerManagementList(); renderScoreTrackingList(); renderTodaysWinsList(); renderDashboard(); };


        // --- Timer Functions ---
        const formatTimerTime = (totalSeconds) => { const minutes = Math.floor(totalSeconds / 60); const seconds = totalSeconds % 60; return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`; };
        const updateTimerDisplay = () => { timerDisplay.textContent = formatTimerTime(timerRemainingSeconds); };
        const updateTimerFill = () => { const percentage = (timerRemainingSeconds / TIMER_DURATION_SECONDS) * 100; timerFill.style.height = `${percentage}%`; };

        const unlockAudioContext = () => {
            if (!timerAudio || timerAudio.readyState < 1) {
                 console.warn("Audio element not ready for unlock attempt or src not set.");
                 return;
            }
            const playPromise = timerAudio.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    timerAudio.pause();
                    if (!audioUnlocked) {
                         console.log("Audio context unlocked by user interaction.");
                         audioUnlocked = true;
                    } else {
                         console.log("Audio context potentially re-activated.");
                    }
                }).catch(error => {
                     if (error.name !== 'AbortError') {
                         console.warn("Audio unlock/reactivation attempt failed:", error.name, error.message);
                         audioUnlocked = false;
                     } else {
                          if (!audioUnlocked) {
                             console.log("Audio context unlocked (AbortError ignored).");
                             audioUnlocked = true;
                          } else {
                             console.log("Audio context potentially re-activated (AbortError ignored).");
                          }
                     }
                });
            }
        };

        const playBeepSound = () => {
            if (!timerAudio || !timerAudio.src) { // Check if src is set
                console.warn("Timer audio source not set. Cannot play beep.");
                return;
            }
            console.log(`Attempting to play beep sound (Audio Unlocked: ${audioUnlocked}, Ready State: ${timerAudio.readyState}, Src: ${timerAudio.src})`);

            if (!audioUnlocked) {
                 console.warn("Audio context is not unlocked. Beep may fail.");
            }

             if (timerAudio.readyState >= 2) { // HAVE_CURRENT_DATA or more
                 timerAudio.currentTime = 0;
                 const playPromise = timerAudio.play();
                 if (playPromise !== undefined) {
                     playPromise.then(() => {
                         console.log("Beep sound played successfully.");
                     }).catch(error => {
                         console.error("Timer audio playback failed:", error.name, error.message);
                         audioUnlocked = false;
                     });
                 }
             } else {
                 console.warn(`Audio not ready to play (readyState: ${timerAudio.readyState}). Attempting to load.`);
                 timerAudio.load(); // Try to trigger loading again if src is set but not ready
             }
        };

        const timerTick = () => {
             if (!isTimerVisible) {
                 stopTimer();
                 return;
             }
             timerRemainingSeconds--;
             if (timerRemainingSeconds < 0) {
                 playBeepSound();
                 timerRemainingSeconds = TIMER_DURATION_SECONDS;
             }
             updateTimerDisplay();
             updateTimerFill();
             timerTimeoutId = setTimeout(timerTick, 1000);
        };

        const startTimer = () => {
            stopTimer();
            isTimerVisible = true;
            timerRemainingSeconds = (timerRemainingSeconds > 0 && timerRemainingSeconds <= TIMER_DURATION_SECONDS)
                 ? timerRemainingSeconds
                 : TIMER_DURATION_SECONDS;
            updateTimerDisplay();
            updateTimerFill();
            timerTimeoutId = setTimeout(timerTick, 1000);
        };

        const stopTimer = () => {
            if (timerTimeoutId) {
                clearTimeout(timerTimeoutId);
                timerTimeoutId = null;
            }
        };

        const handleNextTimerClick = () => {
            unlockAudioContext();
            stopTimer();
            timerRemainingSeconds = TIMER_DURATION_SECONDS;
            updateTimerDisplay();
            updateTimerFill();
             setTimeout(() => {
                playBeepSound();
             }, 50);
            startTimer();
        };

        // --- Wake Lock Functions (Keep existing) ---
        const requestWakeLock = async () => { if ('wakeLock' in navigator) { try { wakeLockSentinel = await navigator.wakeLock.request('screen'); console.log('Screen Wake Lock requested successfully.'); wakeLockSentinel.addEventListener('release', () => { console.log('Screen Wake Lock was released'); if (isTimerVisible) { console.warn('Wake Lock released unexpectedly while timer visible.'); } wakeLockSentinel = null; }); } catch (err) { console.error(`Wake Lock Request Failed: ${err.name}, ${err.message}`); wakeLockSentinel = null; } } else { console.warn('Screen Wake Lock API not supported.'); } };
        const releaseWakeLock = async () => { if (wakeLockSentinel !== null && typeof wakeLockSentinel.release === 'function') { try { await wakeLockSentinel.release(); wakeLockSentinel = null; console.log('Screen Wake Lock released.'); } catch (err) { console.error(`Failed to release Wake Lock: ${err.name}, ${err.message}`); wakeLockSentinel = null; } } };

        // --- Timer Show/Hide (Modified for setTimeout and Audio Unlock) ---
        const showTimer = async () => {
            if (isTimerVisible) return;
            unlockAudioContext();
            timerOverlay.style.display = 'flex';
            toggleTimerBtn.textContent = '‚è±Ô∏è Hide Timer';
            toggleTimerBtn.setAttribute('aria-label', 'Hide Timer');
            await requestWakeLock();
            startTimer();
        };

        const hideTimer = async () => {
            if (!isTimerVisible) return;
            isTimerVisible = false;
            stopTimer();
            timerOverlay.style.display = 'none';
            toggleTimerBtn.textContent = '‚è±Ô∏è Timer';
            toggleTimerBtn.setAttribute('aria-label', 'Show Timer');
            await releaseWakeLock();
            if (timerAudio) {
                 timerAudio.pause();
                 timerAudio.currentTime = 0;
            }
            timerFill.style.height = '100%';
            timerRemainingSeconds = TIMER_DURATION_SECONDS;
            updateTimerDisplay();
        };

        // --- Custom Audio URL Functions ---
        const loadAndApplyAudioSetting = () => {
            const savedUrl = localStorage.getItem(LOCAL_STORAGE_AUDIO_KEY);
            if (savedUrl && savedUrl.trim() !== "") {
                timerAudio.src = savedUrl;
                customAudioUrlInput.value = savedUrl;
                audioUrlStatus.textContent = "Custom audio URL loaded.";
                audioUrlStatus.style.color = 'green';
                console.log("Loaded custom audio URL:", savedUrl);
            } else {
                timerAudio.src = DEFAULT_AUDIO_URL;
                customAudioUrlInput.value = ''; // Keep blank if default is used
                audioUrlStatus.textContent = "Using default audio sound.";
                audioUrlStatus.style.color = 'inherit';
                console.log("Using default audio URL:", DEFAULT_AUDIO_URL);
            }
            if (timerAudio.src) { // Only load if a src is actually set
                timerAudio.load();
            } else {
                console.warn("No audio source set for timerAudio.");
            }
        };

        const handleSaveAudioUrl = () => {
            const newUrl = customAudioUrlInput.value.trim();
            audioUrlStatus.textContent = ""; // Clear previous status

            if (!newUrl) {
                audioUrlStatus.textContent = "Audio URL cannot be empty. To use default, click Reset.";
                audioUrlStatus.style.color = 'red';
                return;
            }

            try {
                new URL(newUrl); // Basic URL format validation
            } catch (e) {
                audioUrlStatus.textContent = "Invalid URL format. Please enter a direct link to an audio file.";
                audioUrlStatus.style.color = 'red';
                return;
            }

            timerAudio.src = newUrl;
            localStorage.setItem(LOCAL_STORAGE_AUDIO_KEY, newUrl);
            if (timerAudio.src) timerAudio.load(); // Load the new source
            audioUrlStatus.textContent = "Custom audio URL saved. It will be used for the next alarm.";
            audioUrlStatus.style.color = 'green';
            console.log("Saved new audio URL:", newUrl);
            unlockAudioContext(); // Attempt to unlock/prime audio context with the new source
        };

        const handleResetAudioUrl = () => {
            timerAudio.src = DEFAULT_AUDIO_URL;
            localStorage.removeItem(LOCAL_STORAGE_AUDIO_KEY);
            customAudioUrlInput.value = '';
            if (timerAudio.src) timerAudio.load(); // Load the default source
            audioUrlStatus.textContent = "Audio URL reset to default.";
            audioUrlStatus.style.color = 'green';
            console.log("Reset audio URL to default:", DEFAULT_AUDIO_URL);
            unlockAudioContext(); // Attempt to unlock/prime audio context with the default source
        };


        // --- Event Listeners ---

        // Player Management Listeners (Keep existing)
        togglePlayerManagementBtn.addEventListener('click', () => { playerManagementSection.classList.toggle('hidden'); const i = playerManagementSection.classList.contains('hidden'); togglePlayerManagementBtn.setAttribute('aria-expanded',!i); togglePlayerManagementBtn.textContent = i?'‚öôÔ∏è Manage':'üîΩ Close'; });
        addPlayerBtn.addEventListener('click', () => addPlayer(newPlayerNameInput.value));
        newPlayerNameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') { e.preventDefault(); addPlayer(newPlayerNameInput.value); } addPlayerError.textContent = ""; });
        playerListManagementUl.addEventListener('click', (e) => { const t = e.target; const pE = t.closest('.player-management-entry'); if (!pE) return; const pId = pE.dataset.playerId; if (t.classList.contains('delete-player-btn')) { deletePlayer(pId); } else if (t.classList.contains('rename-btn')) { playerListManagementUl.querySelectorAll('.rename-controls:not(.hidden)').forEach(c => { const en = c.closest('.player-management-entry'); if (en && en !== pE) { en.querySelector('.rename-controls').classList.add('hidden'); en.querySelector('.player-name-display').classList.remove('hidden'); en.querySelector('.action-buttons').classList.remove('hidden'); } }); pE.querySelector('.player-name-display').classList.add('hidden'); pE.querySelector('.action-buttons').classList.add('hidden'); const rC = pE.querySelector('.rename-controls'); rC.classList.remove('hidden'); const i = rC.querySelector('.rename-input'); i.focus(); i.select(); } else if (t.classList.contains('save-rename-btn')) { const i = pE.querySelector('.rename-input'); renamePlayer(pId, i.value); } else if (t.classList.contains('cancel-rename-btn')) { const oN = pE.querySelector('.player-name-display').textContent; pE.querySelector('.rename-input').value = oN; pE.querySelector('.rename-controls').classList.add('hidden'); pE.querySelector('.player-name-display').classList.remove('hidden'); pE.querySelector('.action-buttons').classList.remove('hidden'); } });
        playerListManagementUl.addEventListener('keypress', (e) => { if (e.key === 'Enter' && e.target.classList.contains('rename-input')) { e.preventDefault(); const pE = e.target.closest('.player-management-entry'); if (pE) renamePlayer(pE.dataset.playerId, e.target.value); } });

        // Score Tracking / Today's Wins Listeners (Keep existing)
        scoreTrackingListUl.addEventListener('click', (e) => { if (e.target.classList.contains('add-win-btn') && !e.target.disabled) { recordWin(e.target.dataset.playerId); } });
        todaysWinsListUl.addEventListener('click', (e) => { if (e.target.classList.contains('delete-win-btn') && !e.target.disabled) { const wL = e.target.closest('li'); if (wL?.dataset.winId) deleteWin(wL.dataset.winId); } });

        // Dashboard Controls Listener (Keep existing)
        dashboardControls.addEventListener('click', (e) => { if (e.target.tagName === 'BUTTON' && e.target.dataset.period) { const newlySelectedPeriod = e.target.dataset.period; currentDisplayDate = new Date(); currentDashboardPeriod = newlySelectedPeriod; currentView = 'player'; renderDashboard(); } });

        // View Toggle Button Listeners (Keep existing)
        playerViewBtn.addEventListener('click', () => { if (currentView !== 'player') { currentView = 'player'; renderDashboard(); } });
        monthlyViewBtn.addEventListener('click', () => { if (currentView !== 'monthly') { currentView = 'monthly'; renderDashboard(); } });

        // Period Navigation Button Listeners (Keep existing)
        prevPeriodBtn.addEventListener('click', () => { if (currentDashboardPeriod === 'week') { currentDisplayDate.setDate(currentDisplayDate.getDate() - 7); } else if (currentDashboardPeriod === 'month') { currentDisplayDate.setMonth(currentDisplayDate.getMonth() - 1); } else if (currentDashboardPeriod === 'year') { currentDisplayDate.setFullYear(currentDisplayDate.getFullYear() - 1); } renderDashboard(); });
        nextPeriodBtn.addEventListener('click', () => { if (currentDashboardPeriod === 'week') { currentDisplayDate.setDate(currentDisplayDate.getDate() + 7); } else if (currentDashboardPeriod === 'month') { const tempDate = new Date(currentDisplayDate); tempDate.setMonth(tempDate.getMonth() + 1); const today = new Date(); if (tempDate.getFullYear() < today.getFullYear() || (tempDate.getFullYear() === today.getFullYear() && tempDate.getMonth() <= today.getMonth())) { currentDisplayDate.setMonth(currentDisplayDate.getMonth() + 1); } else { nextPeriodBtn.disabled = true; return; } } else if (currentDashboardPeriod === 'year') { const nextYear = currentDisplayDate.getFullYear() + 1; if (nextYear <= new Date().getFullYear()) { currentDisplayDate.setFullYear(nextYear); } else { nextPeriodBtn.disabled = true; return; } } renderDashboard(); });
        prevYearBtn.addEventListener('click', () => { currentDisplayDate.setFullYear(currentDisplayDate.getFullYear() - 1); renderDashboard(); });
        nextYearBtn.addEventListener('click', () => { const nextYear = currentDisplayDate.getFullYear() + 1; if (nextYear <= new Date().getFullYear()) { currentDisplayDate.setFullYear(nextYear); renderDashboard(); } else { nextYearBtn.disabled = true; } });

        // Timer Event Listeners
        toggleTimerBtn.addEventListener('click', () => { if (isTimerVisible) { hideTimer(); } else { showTimer(); } });
        hideTimerBtn.addEventListener('click', hideTimer);
        nextTimerBtn.addEventListener('click', handleNextTimerClick);

        // Custom Audio URL Event Listeners
        saveAudioUrlBtn.addEventListener('click', handleSaveAudioUrl);
        resetAudioUrlBtn.addEventListener('click', handleResetAudioUrl);
        customAudioUrlInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                handleSaveAudioUrl();
            }
            audioUrlStatus.textContent = ""; // Clear status on typing
        });


        // Visibility Change Listener (Keep existing)
         document.addEventListener('visibilitychange', async () => {
             console.log(`Visibility changed to: ${document.visibilityState}`);
             if (document.visibilityState === 'visible') {
                 if (isTimerVisible && !wakeLockSentinel) {
                     console.log("Page visible, timer active, but no wake lock. Re-requesting wake lock.");
                     await requestWakeLock();
                 }
                 if (isTimerVisible) {
                      console.log("Page visible, attempting to re-activate audio context.");
                      unlockAudioContext();
                 }
             } else {
                console.log("Page hidden, audio context likely to be suspended.");
             }
         });

        // --- Initial Load ---
        (async () => {
            if (typeof ChartDataLabels !== 'undefined') { Chart.register(ChartDataLabels); } else { console.error("ChartDataLabels plugin not loaded!"); }
            currentView = 'player';
            currentDashboardPeriod = 'month';
            currentDisplayDate = new Date();

            loadAndApplyAudioSetting(); // Load custom/default audio URL first
            updateTimerDisplay(); // Set initial timer display
            // timerAudio.load() is now called within loadAndApplyAudioSetting

            await loadData(); // Load data and trigger initial renderApp()
        })();

    </script>

</body>
</html>
