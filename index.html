<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rummikub Win Tracker</title>
    <!-- Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <style>
        /* CSS Styles (keep existing styles from previous full HTML) */
        /* --- Basic Reset & Defaults --- */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; }
        html.timer-active, body.timer-active { overflow: hidden; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; background-color: #f4f7f6; color: #333; padding-bottom: 50px; }
        .app-container { max-width: 600px; margin: 0 auto; padding: 15px; position: relative; z-index: 1; }
        h1, h2, h3 { margin-bottom: 0.8em; color: #0b4f6c; }
        h1 { text-align: center; margin-bottom: 1em; color: #012a4a; }
        p { margin-bottom: 1em; }
        button { display: inline-block; padding: 10px 18px; font-size: 1rem; font-weight: bold; color: #fff; background-color: #219ebc; border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.2s ease; min-height: 44px; vertical-align: middle; -webkit-tap-highlight-color: transparent; }
        button:hover, button:focus { background-color: #1a7f9a; outline: none; }
        button:disabled { background-color: #adb5bd; cursor: not-allowed; }
        button.secondary { background-color: #6c757d; }
        button.secondary:hover, button:secondary:focus { background-color: #5a6268; }
        button.danger { background-color: #e76f51; }
        button.danger:hover, button:focus { background-color: #d95a3a; }
        button.icon-button { padding: 8px 10px; font-size: 0.9rem; margin-left: 5px; }
        button.small-nav-button { padding: 5px 10px; font-size: 0.9rem; min-height: 30px; margin: 0 5px; }
        input[type="text"] { width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 1rem; }
        select { width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 1rem; background-color: white; min-height: 44px; }
        label { display: block; margin-bottom: 5px; font-weight: 500; font-size: 0.9em; }
        section { background-color: #fff; padding: 15px; margin-bottom: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); }
        header { margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; }
        header h1 { margin-bottom: 0; flex-grow: 1; text-align: left; margin-right: 10px; }
        .header-buttons { display: flex; align-items: center; }
        #togglePlayerManagement { flex-shrink: 0; margin-left: 5px; }
        #toggleTimerBtn { flex-shrink: 0; margin-left: 10px; background-color: #2a9d8f; padding: 8px 10px; font-size: 0.9rem; }
        #toggleTimerBtn:hover, #toggleTimerBtn:focus { background-color: #258a7f; }
        #playerManagement { border: 1px dashed #ccc; }
        #playerManagement.hidden { display: none; }
        #gameManagement { padding-bottom: 15px; margin-bottom: 15px; border-bottom: 1px solid #eee; } /* New Style */
        .player-management-entry { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #eee; }
        .player-management-entry:last-child { border-bottom: none; }
        .player-management-entry span.player-name-display { flex-grow: 1; margin-right: 10px; }
        .rename-controls { display: flex; align-items: center; }
        .rename-controls input { width: 120px; margin-bottom: 0; margin-right: 5px; font-size: 0.9rem; padding: 5px 8px; }
        #timerAudioSettings { margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee; }
        #timerAudioSettings h4 { margin-bottom: 0.5em; color: #333; }
        #timerAudioSettings button { margin-top: 5px; margin-right: 5px; font-size:0.9rem; padding: 8px 12px; }
        #customUrlGroup { margin-top: 10px; padding: 10px; border: 1px solid #e0e0e0; border-radius: 4px; background-color: #f9f9f9; }
        #customUrlGroup label { font-size: 0.85em; }
        #customUrlGroup input[type="text"] { margin-bottom: 8px; }
        #audioUrlStatus { font-size: 0.9em; margin-top: 8px; line-height: 1.3; }
        #audioUrlStatus .success { color: green; }
        #audioUrlStatus .error { color: red; }
        #audioUrlStatus .info { color: #333; }
        #scoreTrackingList li, #todaysWinsList li { display: flex; justify-content: space-between; align-items: center; padding: 12px 5px; border-bottom: 1px solid #eee; }
        #scoreTrackingList li:last-child, #todaysWinsList li:last-child { border-bottom: none; }
        .player-info { flex-grow: 1; margin-right: 10px; }
        .player-name { font-weight: bold; display: block; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .win-timestamp { font-size: 0.85em; color: #666; margin-left: 10px; margin-right: 10px; white-space: nowrap; }
        .win-feedback { display: block; font-size: 0.85em; color: #28a745; margin-top: 2px; font-style: italic; animation: fadeOut 3s forwards; line-height: 1.2; }
        @keyframes fadeOut { 0% { opacity: 1; } 80% { opacity: 1; } 100% { opacity: 0; } }
        .dashboard-controls { display: flex; justify-content: space-around; margin-bottom: 15px; flex-wrap: wrap; }
        .dashboard-controls button { flex-grow: 1; margin: 5px; background-color: #f8f9fa; color: #0b4f6c; border: 1px solid #dee2e6; }
        .dashboard-controls button.active { background-color: #0b4f6c; color: #fff; font-weight: bold; border-color: #0b4f6c; }
        .dashboard-view-toggle { text-align: center; margin-bottom: 15px; }
        .dashboard-view-toggle .small-nav-button { background-color: #e9ecef; color: #495057; border: 1px solid #ced4da; font-weight: normal; }
        .dashboard-view-toggle .small-nav-button.active { background-color: #0b4f6c; color: #ffffff; border-color: #0b4f6c; font-weight: bold; box-shadow: inset 0 1px 2px rgba(0,0,0,0.1); }
        .chart-title-container { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .chart-title-container h3 { margin-bottom: 0; text-align: center; flex-grow: 1; color: #333; font-weight: bold; }
        #winChartContainer, #monthlyChartContainer { background-color: #f8f9fa; padding: 20px 10px 10px 10px; border-radius: 5px; min-height: 320px; position: relative; }
        #chart, #monthlyChart { position: relative; height: 270px; width: 100%; }
        canvas.hidden { display: none; }
        .hidden { display: none !important; }
        .text-center { text-align: center; }
        .error-message { color: #d95a3a; font-size: 0.9em; margin-top: -5px; margin-bottom: 10px; }
        .no-data { color: #6c757d; text-align: center; padding: 20px; font-style: italic; margin-top: 20px; }
        ul { list-style: none; padding: 0; }
        .total-wins-display { font-size: 0.9em; color: #555; margin-top: -5px; margin-bottom: 10px; font-weight: bold; }
        .todays-summary { font-size: 0.95em; color: #444; background-color: #eef3f5; padding: 8px 12px; border-radius: 4px; margin-bottom: 15px; border-left: 3px solid #219ebc; }
        .todays-summary.hidden { display: none; }
        .todays-summary span { display: inline-block; margin-right: 15px; }
        .todays-summary span:last-child { margin-right: 0; }
        #timerOverlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: #111; z-index: 1000; display: none; flex-direction: column; justify-content: center; align-items: center; overflow: hidden; }
        #timerBackgroundImage { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; opacity: 0.1; z-index: 0; }
        #timerCurtain { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #4CAF50; z-index: 1; transform-origin: bottom; transition: transform 0.2s linear; }
        #timerDisplay { font-size: 10em; font-weight: bold; color: white; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7); z-index: 2; position: relative; }
        #hideTimerBtn { position: absolute; top: 20px; right: 20px; padding: 12px 24px; font-size: 1.2rem; background-color: rgba(255, 255, 255, 0.7); color: #333; border: 1px solid #ccc; border-radius: 5px; cursor: pointer; z-index: 2; }
        #hideTimerBtn:hover { background-color: rgba(255, 255, 255, 0.9); }
        #nextTimerBtn { margin-top: 25px; padding: 18px 40px; font-size: 1.8rem; min-width: 150px; font-weight: bold; background-color: rgba(255, 255, 255, 0.7); color: #333; border: 1px solid #ccc; border-radius: 8px; cursor: pointer; z-index: 2; transition: background-color 0.2s ease; }
        #nextTimerBtn:hover { background-color: rgba(255, 255, 255, 0.95); }
        #geminiInsightsSection { background-color: #e9f5fd; border-top: 3px solid #0b4f6c; }
        #geminiInsightsSection h2 { color: #012a4a; }
        #geminiApiKeyInputGroup label { font-weight: bold; }
        #geminiApiKeyInputGroup input[type="text"] { margin-bottom: 5px; }
        #geminiApiKeyNote { font-size:0.8em; color:#555; margin-top: 0; margin-bottom: 10px;}
        #geminiInsightResult { margin-top: 10px; padding: 12px; background-color: #ffffff; border-radius: 4px; min-height: 40px; border-left: 4px solid #ffc107; line-height: 1.5; white-space: pre-wrap; /* Ensures full text is shown and wraps */ overflow-y: auto; /* Adds scroll if content overflows a max height */ max-height: 200px; /* Example max height */ }
        #geminiImageContainer { margin-top: 15px; text-align: center; }
        #geminiImage { max-width: 100%; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: none; }
        .gemini-buttons-flex { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px; }
        #geminiInsightAccordion { margin-bottom: 15px; }
        #geminiInsightAccordion summary { cursor: pointer; font-weight: bold; color: #0b4f6c; }
        #changeApiKeyBtn { background-color: #6c757d; font-size: 0.9rem; padding: 8px 12px;}
        #firebaseConfigWarning, #firebaseError {
            padding: 10px; margin-top: 20px; border-radius: 5px; font-size: 0.9em;
            word-break: break-word; /* Ensure long messages wrap */
        }
        #firebaseConfigWarning { background-color: #fff3cd; border: 1px solid #ffeeba; }
        #firebaseError { background-color: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; display: none; }

        /* --- Mexican Train Styles --- */
        #mexicanTrainTracker { border-top: 1px solid #eee; margin-top: 20px; padding-top: 15px; }
        #mtPlayerCheckboxes { margin-bottom: 15px; }
        .mt-player-checkbox-item { display: block; margin-bottom: 8px; }
        .mt-player-checkbox-item input { margin-right: 8px; width: auto; }
        #mtScoresContainer { display: grid; grid-template-columns: 1fr auto auto; gap: 10px 15px; align-items: center; margin-bottom: 15px; }
        #mtScoresContainer .mt-player-name { font-weight: bold; }
        #mtScoresContainer .mt-player-total-score { color: #555; font-size: 0.9em; }
        #mtScoresContainer input[type="number"] { width: 70px; padding: 8px; font-size: 1rem; text-align: center; }
        #mtLeaderDisplay { font-weight: bold; color: #2a9d8f; margin-bottom: 15px; }
        #mtEndGameBtn { margin-left: 10px; }
        #mtGameOver { text-align: center; }
        #mtGameOverTitle { color: #0b4f6c; }
        #mtFinalScores { margin-bottom: 15px; line-height: 1.7; }
        #mtCompletedRounds { margin-bottom: 20px; }
        .mt-round-row { display: grid; grid-template-columns: 1fr auto; align-items: center; padding: 8px 0; border-bottom: 1px solid #eee; }
        .mt-round-row-header { font-weight: bold; }
        .mt-round-scores { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 5px 15px; }
        .mt-round-scores .player-score { font-size: 0.9em; }
        .mt-round-row .edit-round-btn { justify-self: flex-end; }
        .mt-round-row-editing .mt-round-scores { grid-template-columns: repeat(auto-fill, minmax(70px, 1fr)); }
    </style>
</head>
<body>

    <div id="timerOverlay">
        <img id="timerBackgroundImage" src="" alt="Timer Background" />
        <div id="timerCurtain"></div>
        <div id="timerDisplay">1:00</div>
        <button id="nextTimerBtn" aria-label="Next Turn Timer">NEXT</button>
        <button id="hideTimerBtn" aria-label="Hide Timer">Hide Timer</button>
    </div>
    <audio id="timerAudio" preload="auto"></audio>


    <div class="app-container">
         <header>
            <h1>Rummikub Wins</h1>
            <div class="header-buttons">
                 <button id="toggleTimerBtn" aria-label="Show Timer">⏱️ Timer</button>
                 <button id="togglePlayerManagement" class="secondary icon-button" aria-label="Manage Players & Settings" title="Manage Players & Settings">⚙️ Manage</button>
            </div>
        </header>

        <section id="geminiInsightsSection">
            <h2>AI Game Insights ✨</h2>
            <div id="geminiApiKeyInputGroup">
                <label for="geminiApiKey">Google AI Studio API Key:</label>
                <input type="text" id="geminiApiKey" placeholder="Enter your Gemini API Key">
                <p id="geminiApiKeyNote">
                    Get your key from <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer">Google AI Studio</a>.
                    The key will be stored in your browser's local storage.
                    <br><strong>Note:</strong> This key will also be used for Text-to-Speech. Ensure the Cloud Text-to-Speech API is enabled in your Google Cloud Project.
                </p>
            </div>
            <div id="geminiApiKeyStoredInfo" class="hidden">
                <p style="color: green; margin-bottom: 5px;">API Key is stored. <button id="changeApiKeyBtn" class="small-nav-button">Change/Re-enter Key</button></p>
            </div>

            <details id="geminiInsightAccordion">
                <summary>Show/Hide Funny Insight</summary>
                <div id="geminiInsightResult">
                    Enter your API Key above to get started...
                </div>
            </details>
            <div id="geminiImageContainer">
                <img id="geminiImage" src="" alt="AI Generated Image" />
            </div>
            <div class="gemini-buttons-flex">
                <button id="getGeminiInsightBtn">Get New Funny Insight 😂</button>
                <!-- The Listen button will be added here by JavaScript -->
            </div>
        </section>

        <section id="playerManagement" class="hidden">
            <h3>Manage Players, Games & Settings</h3>
             <!-- NEW GAME MANAGEMENT SECTION -->
            <div id="gameManagement">
                <label for="gameSelector">Current Game:</label>
                <select id="gameSelector"></select>
            </div>
             <!-- END NEW SECTION -->
            <div id="addPlayerForm">
                <label for="newPlayerName">Add New Player:</label>
                <input type="text" id="newPlayerName" placeholder="New Player Name">
                <button id="addPlayerBtn">Add Player</button>
                <div id="addPlayerError" class="error-message"></div>
            </div>
            <ul id="playerListManagement"></ul>
            <p id="noPlayersManaged" class="no-data hidden">No players added yet.</p>

            <div id="timerAudioSettings">
                <h4>Timer Alarm Sound</h4>
                <label for="audioSourceSelect">Select or Add Sound:</label>
                <select id="audioSourceSelect"></select>
                 <div id="audioUrlStatus"></div>
                <div id="customUrlGroup" class="hidden">
                    <label for="customAudioShortNameInput">Short Name (Required):</label>
                    <input type="text" id="customAudioShortNameInput" placeholder="e.g., My Awesome Beep">
                    <label for="customAudioUrlInput">Custom Audio URL:</label>
                    <input type="text" id="customAudioUrlInput" placeholder="Enter direct audio link (e.g., .mp3)">
                    <button id="saveCustomAudioBtn">Save & Use This Sound</button>
                </div>
                <button id="removeFavoriteBtn" class="secondary hidden">Remove Selected Sound</button>
            </div>
        </section>

        <section id="dashboard">
            <h2>Dashboard</h2>
            <div class="dashboard-controls"> <button data-period="month" class="active">This Month</button> <button data-period="week">This Week</button> <button data-period="year">This Year</button> </div>
            <div class="dashboard-view-toggle"> <button id="playerViewBtn" class="secondary small-nav-button active">Player Wins</button> <button id="monthlyViewBtn" class="secondary small-nav-button">Monthly Breakdown</button> </div>
            <div id="winChartContainer"> <div class="chart-title-container"> <button id="prevPeriodBtn" class="secondary small-nav-button hidden" aria-label="Previous Period">⬅️ Prev</button> <h3 id="winChartTitle">Wins This Week</h3> <button id="nextPeriodBtn" class="secondary small-nav-button hidden" aria-label="Next Period">Next ➡️</button> </div> <p id="totalPlayerWinsDisplay" class="total-wins-display text-center"></p> <div id="chart"> <canvas id="playerWinCanvas"></canvas> <p id="noChartData" class="no-data hidden">No wins recorded for this period.</p> </div> </div>
            <div id="monthlyChartContainer" class="hidden"> <div class="chart-title-container"> <button id="prevYearBtn" class="secondary small-nav-button" aria-label="Previous Year">⬅️ Prev Yr</button> <h3 id="monthlyChartTitle">Monthly Winners for 2023</h3> <button id="nextYearBtn" class="secondary small-nav-button" aria-label="Next Year">Next Yr ➡️</button> </div> <p id="totalMonthlyWinsDisplay" class="total-wins-display text-center"></p> <div id="monthlyChart"> <canvas id="monthlyWinsCanvas"></canvas> <p id="noMonthlyChartData" class="no-data hidden">No wins recorded for this year.</p> </div> </div>
        </section>
        <section id="scoreTracking">
            <h2>Record a Win</h2>

            <!-- Standard Score Tracking -->
            <ul id="scoreTrackingList"></ul>
            <p id="noPlayersForScoring" class="no-data hidden">Add players to track wins.</p>

            <!-- Mexican Train Tracker -->
            <div id="mexicanTrainTracker" class="hidden">
                <div id="mtGameSetup">
                    <p>Select players for the new game:</p>
                    <div id="mtPlayerCheckboxes"></div>
                    <button id="mtStartGameBtn">Start New Game</button>
                    <p id="mtStartGameError" class="error-message"></p>
                </div>
                <div id="mtGameActive" class="hidden">
                    <div id="mtCompletedRounds">
                        <h4>Completed Rounds</h4>
                        <!-- Completed rounds will be injected here -->
                    </div>
                    <div id="mtCurrentRound">
                        <h3 id="mtRoundTitle"></h3>
                        <div id="mtScoresContainer">
                            <!-- Player scores will be injected here -->
                        </div>
                        <div id="mtLeaderDisplay"></div>
                        <button id="mtSubmitRoundBtn">Submit Round Scores</button>
                        <button id="mtEndGameBtn" class="danger">End Game Early</button>
                    </div>
                </div>
                 <div id="mtGameOver" class="hidden">
                    <h3 id="mtGameOverTitle"></h3>
                    <p id="mtFinalScores"></p>
                    <button id="mtPlayAgainBtn">Play Again</button>
                </div>
            </div>
        </section>
        <section id="todaysWins"> <h3>Recorded Today (<span id="todayDateDisplay"></span>)</h3> <div id="todaysSummary" class="todays-summary hidden"></div> <ul id="todaysWinsList"></ul> <p id="noWinsToday" class="no-data">No wins recorded yet today.</p> </section>

        <div id="firebaseConfigWarning"><strong>Firebase Setup:</strong> Initializing...</div>
        <div id="firebaseError"><strong>Firebase Error:</strong> <span id="firebaseErrorMessage"></span></div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getFirestore, collection, getDocs, getDoc, addDoc, deleteDoc, updateDoc, doc, query, orderBy, Timestamp, serverTimestamp, setDoc } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";

        // Firebase configuration (replace with your actual config)
        const firebaseConfig = {
          apiKey: "AIzaSyD-e3H5CaoQobBqFwzDnCGZCUbniZQg_J0", // Replace!
          authDomain: "i-am-awesome-tasker.firebaseapp.com", // Replace!
          projectId: "i-am-awesome-tasker", // Replace!
          storageBucket: "i-am-awesome-tasker.appspot.com", // Replace!
          messagingSenderId: "853316153385", // Replace!
          appId: "1:853316153385:web:db1fc1304b54a198a82c38", // Replace!
          measurementId: "G-ZDBF73CFXS" // Optional: Replace!
        };


        let app, db;
        let firebaseInitializedSuccessfully = false;

        // --- Global Variables ---
        let players = [];
        let allWins = []; // NEW: Stores all wins from all games
        let wins = []; // This is now the filtered list for the current game
        let games = []; // NEW: Stores the list of games
        const DEFAULT_GAME_ID = 'rummikub'; // NEW: Constant for the default game
        let currentGameId = DEFAULT_GAME_ID; // NEW: Tracks the current game
        const ACTIVE_GAMES_COLLECTION = 'activeGames'; // NEW: Collection for complex games
        let mexicanTrainState = null; // NEW: To hold the state of the current MT game


        let currentDashboardPeriod = 'month';
        let currentDisplayDate = new Date();
        let currentView = 'player';
        let playerWinChartInstance = null;
        let monthlyChartInstance = null;
        let timerTimeoutId = null;
        const TIMER_DURATION_SECONDS = 60;
        let timerRemainingSeconds = TIMER_DURATION_SECONDS;
        let timerRestartCount = 0;
        const IMAGE_REGEN_THRESHOLD = 15;
        const PRELOAD_AI_COMMENTARY_SECONDS_BEFORE_END = 5;
        let isTimerVisible = false;
        let audioUnlocked = false;
        let wakeLockSentinel = null;
        let audioPreferences = [];
        let currentActiveAudioPreferenceId = "default";
        let insightAudio = null; 
        let isSpeaking = false;
        let preloadedAiCommentaryUrl = null;
        let isLoadingAiCommentary = false;
        let currentTimerAiCommentaryText = ""; 
        let lastLongInsightText = ""; 
        let geminiImageCache = [];
        window.geminiImageCache = geminiImageCache; // Expose for testing
        const GEMINI_IMAGE_CACHE_KEY = 'rummikubTrackerGeminiImageCache';

        const DEFAULT_AUDIO_URL = "https://www.dropbox.com/scl/fi/540eent9p1es21f4ep2ix/trompo_1-edit.mp3?rlkey=m0hhk27s8892ow6eyogpqxm00&st=zi9nt3i9&dl=1";
        const AUDIO_PREFERENCES_COLLECTION = 'audioPreferences';
        const APP_CONFIG_COLLECTION = 'appConfiguration';
        const TIMER_SETTINGS_DOC_ID = 'timerSettings';
        const GEMINI_API_KEY_STORAGE_KEY = 'rummikubTrackerGeminiApiKey';
        const AI_COMMENTATOR_ID = "ai_commentator";
        const RANDOM_MIX_AUDIO_ID = "random_mix";


        // --- DOM Elements ---
        const dom = {
            togglePlayerManagementBtn: document.getElementById('togglePlayerManagement'),
            playerManagementSection: document.getElementById('playerManagement'),
            gameSelector: document.getElementById('gameSelector'), // NEW
            addPlayerBtn: document.getElementById('addPlayerBtn'),
            newPlayerNameInput: document.getElementById('newPlayerName'),
            addPlayerError: document.getElementById('addPlayerError'),
            playerListManagementUl: document.getElementById('playerListManagement'),
            noPlayersManagedMsg: document.getElementById('noPlayersManaged'),
            dashboardControls: document.querySelector('.dashboard-controls'),
            playerViewBtn: document.getElementById('playerViewBtn'),
            monthlyViewBtn: document.getElementById('monthlyViewBtn'),
            winChartContainer: document.getElementById('winChartContainer'),
            winChartTitle: document.getElementById('winChartTitle'),
            playerWinCanvas: document.getElementById('playerWinCanvas'),
            noChartDataMsg: document.getElementById('noChartData'),
            prevPeriodBtn: document.getElementById('prevPeriodBtn'),
            nextPeriodBtn: document.getElementById('nextPeriodBtn'),
            monthlyChartContainer: document.getElementById('monthlyChartContainer'),
            monthlyChartTitle: document.getElementById('monthlyChartTitle'),
            monthlyWinsCanvas: document.getElementById('monthlyWinsCanvas'),
            noMonthlyChartDataMsg: document.getElementById('noMonthlyChartData'),
            prevYearBtn: document.getElementById('prevYearBtn'),
            nextYearBtn: document.getElementById('nextYearBtn'),
            scoreTrackingListUl: document.getElementById('scoreTrackingList'),
            noPlayersForScoringMsg: document.getElementById('noPlayersForScoring'),
            todayDateDisplay: document.getElementById('todayDateDisplay'),
            todaysWinsListUl: document.getElementById('todaysWinsList'),
            noWinsTodayMsg: document.getElementById('noWinsToday'),
            todaysSummaryDiv: document.getElementById('todaysSummary'),
            toggleTimerBtn: document.getElementById('toggleTimerBtn'),
            timerOverlay: document.getElementById('timerOverlay'),
            timerCurtain: document.getElementById('timerCurtain'),
            timerBackgroundImage: document.getElementById('timerBackgroundImage'),
            timerDisplay: document.getElementById('timerDisplay'),
            hideTimerBtn: document.getElementById('hideTimerBtn'),
            timerAudio: document.getElementById('timerAudio'), 
            nextTimerBtn: document.getElementById('nextTimerBtn'),
            totalPlayerWinsDisplay: document.getElementById('totalPlayerWinsDisplay'),
            totalMonthlyWinsDisplay: document.getElementById('totalMonthlyWinsDisplay'),
            audioSourceSelect: document.getElementById('audioSourceSelect'),
            customUrlGroup: document.getElementById('customUrlGroup'),
            customAudioShortNameInput: document.getElementById('customAudioShortNameInput'),
            customAudioUrlInput: document.getElementById('customAudioUrlInput'),
            saveCustomAudioBtn: document.getElementById('saveCustomAudioBtn'),
            removeFavoriteBtn: document.getElementById('removeFavoriteBtn'),
            audioUrlStatus: document.getElementById('audioUrlStatus'),
            geminiApiKeyInputGroup: document.getElementById('geminiApiKeyInputGroup'),
            geminiApiKeyInput: document.getElementById('geminiApiKey'),
            geminiApiKeyNote: document.getElementById('geminiApiKeyNote'),
            geminiApiKeyStoredInfo: document.getElementById('geminiApiKeyStoredInfo'),
            changeApiKeyBtn: document.getElementById('changeApiKeyBtn'),
            getGeminiInsightBtn: document.getElementById('getGeminiInsightBtn'),
            geminiInsightResultDiv: document.getElementById('geminiInsightResult'),
            geminiImageContainer: document.getElementById('geminiImageContainer'),
            geminiImage: document.getElementById('geminiImage'),
            geminiButtonsFlexDiv: document.querySelector('.gemini-buttons-flex'),
            listenToInsightBtn: null, 
            firebaseConfigWarningDiv: document.getElementById('firebaseConfigWarning'),
            firebaseErrorDiv: document.getElementById('firebaseError'),
            firebaseErrorMessageSpan: document.getElementById('firebaseErrorMessage'),
            // Mexican Train elements
            mexicanTrainTracker: document.getElementById('mexicanTrainTracker'),
            mtGameSetup: document.getElementById('mtGameSetup'),
            mtPlayerCheckboxes: document.getElementById('mtPlayerCheckboxes'),
            mtStartGameBtn: document.getElementById('mtStartGameBtn'),
            mtStartGameError: document.getElementById('mtStartGameError'),
            mtGameActive: document.getElementById('mtGameActive'),
            mtRoundTitle: document.getElementById('mtRoundTitle'),
            mtScoresContainer: document.getElementById('mtScoresContainer'),
            mtLeaderDisplay: document.getElementById('mtLeaderDisplay'),
            mtSubmitRoundBtn: document.getElementById('mtSubmitRoundBtn'),
            mtEndGameBtn: document.getElementById('mtEndGameBtn'),
            mtGameOver: document.getElementById('mtGameOver'),
            mtGameOverTitle: document.getElementById('mtGameOverTitle'),
            mtFinalScores: document.getElementById('mtFinalScores'),
            mtPlayAgainBtn: document.getElementById('mtPlayAgainBtn'),
        };

        // --- Utility Functions ---
        const utils = { getTodayDateString: () => new Date().toDateString(), formatTime: (timestamp) => { if (!timestamp) return ''; const date = timestamp.toDate ? timestamp.toDate() : (timestamp instanceof Date ? timestamp : null); if (!date) return ''; return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); }, getMonthName: (monthIndex) => ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][monthIndex], getFullMonthName: (monthIndex) => ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"][monthIndex], getPeriodRange: (period, baseDate = new Date()) => { let start = new Date(baseDate); let end = new Date(baseDate); switch (period) { case 'week': const dayOfWeek = start.getDay(); const diff = start.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1); start = new Date(start.setDate(diff)); start.setHours(0, 0, 0, 0); end = new Date(start); end.setDate(start.getDate() + 6); end.setHours(23, 59, 59, 999); break; case 'month': start = new Date(start.getFullYear(), start.getMonth(), 1); start.setHours(0, 0, 0, 0); end = new Date(start.getFullYear(), start.getMonth() + 1, 0); end.setHours(23, 59, 59, 999); break; case 'year': start = new Date(start.getFullYear(), 0, 1); start.setHours(0, 0, 0, 0); end = new Date(start.getFullYear(), 11, 31); end.setHours(23, 59, 59, 999); break; } return { start, end }; }, sanitizeHTML: (str) => { const temp = document.createElement('div'); temp.textContent = str; return temp.innerHTML; }, pluralize: (count, singular, plural = null) => { plural = plural ?? singular + 's'; return count === 1 ? `${count} ${singular}` : `${count} ${plural}`; } };

        // --- Game Management Functions (NEW) ---
        async function loadGames() {
            const defaultGames = [
                { id: 'rummikub', name: 'Rummikub', type: 'simple' },
                { id: 'cover_your_assets', name: 'Cover Your Assets', type: 'simple' },
                { id: 'mexican_train', name: 'Mexican Train', type: 'points_based_lowest_wins' }
            ];

            if (!db) {
                games = defaultGames;
                return;
            }

            try {
                const gamesCollection = collection(db, "games");
                const snapshot = await getDocs(gamesCollection);
                games = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                // Self-healing and migration logic
                for (const defaultGame of defaultGames) {
                    const gameById = games.find(g => g.id === defaultGame.id);
                    const gameByName = games.find(g => g.name.toLowerCase() === defaultGame.name.toLowerCase());

                    if (gameById) {
                        // Game exists with the correct ID. Ensure its type is correct.
                        if (gameById.type !== defaultGame.type) {
                            console.log(`Updating type for game '${defaultGame.name}'...`);
                            const gameDocRef = doc(db, "games", gameById.id);
                            updateDoc(gameDocRef, { type: defaultGame.type }).catch(e => console.error("Failed to update game type:", e));
                            gameById.type = defaultGame.type; // Update local cache
                        }
                    } else if (gameByName) {
                        // Game exists with the correct name but wrong/custom ID.
                        // This is a legacy entry. We should log this but not create a duplicate.
                        // We can also choose to "migrate" it by updating its type if missing.
                        console.log(`Legacy game found: '${gameByName.name}'. Checking for type...`);
                        if (gameByName.type !== defaultGame.type) {
                             const gameDocRef = doc(db, "games", gameByName.id);
                             updateDoc(gameDocRef, { type: defaultGame.type }).catch(e => console.error("Failed to update legacy game type:", e));
                             gameByName.type = defaultGame.type; // Update local cache
                        }
                    } else {
                        // Game does not exist by ID or name, create it.
                        console.log(`Default game '${defaultGame.name}' not found. Creating it now.`);
                        const gameDocRef = doc(db, "games", defaultGame.id);
                        setDoc(gameDocRef, { ...defaultGame, createdAt: serverTimestamp() }).catch(e => {
                            console.error(`Failed to auto-create default game '${defaultGame.id}':`, e);
                        });
                        games.push(defaultGame); // Add to local list immediately
                    }
                }

                games.sort((a,b) => a.name.localeCompare(b.name));

            } catch (error) {
                console.error("Error loading games:", error);
                games = defaultGames; // Fallback to default list if DB fails
            }
        }

        function populateGameSelector() {
            if (!dom.gameSelector) return;
            dom.gameSelector.innerHTML = '';
            games.forEach(game => {
                const option = new Option(utils.sanitizeHTML(game.name), game.id);
                dom.gameSelector.add(option);
            });
            dom.gameSelector.add(new Option("✨ Add New Game...", "add_new_game"));
            dom.gameSelector.value = currentGameId;
        }

        function filterWinsForCurrentGame() {
            wins = allWins.filter(w => (w.gameId || DEFAULT_GAME_ID) === currentGameId);
            wins.sort((a, b) => b.timestamp.toMillis() - a.timestamp.toMillis());
            console.log(`Filtered to ${wins.length} wins for game: ${currentGameId}`);
            // Update the main header title to reflect the current game
            const currentGame = games.find(g => g.id === currentGameId);
            const gameName = currentGame ? utils.sanitizeHTML(currentGame.name) : 'Game';
            document.querySelector('header h1').textContent = `${gameName} Wins`;
        }

        async function addNewGame() {
            const newGameName = prompt("Please enter the name for the new game:");
            if (!newGameName || newGameName.trim() === '') {
                dom.gameSelector.value = currentGameId;
                return;
            }
            const trimmedName = newGameName.trim();

            if (games.some(g => g.name.toLowerCase() === trimmedName.toLowerCase())) {
                alert(`A game named "${trimmedName}" already exists.`);
                dom.gameSelector.value = currentGameId;
                return;
            }

            dom.gameSelector.disabled = true;
            try {
                const docRef = await addDoc(collection(db, "games"), {
                    name: trimmedName,
                    createdAt: serverTimestamp()
                });
                currentGameId = docRef.id;
                localStorage.setItem('rummikubTrackerLastGameId', currentGameId);
                await loadGames();
                populateGameSelector();
                filterWinsForCurrentGame();
                renderApp();
            } catch (error) {
                console.error("Error adding new game:", error);
                alert(`Failed to add new game: ${error.message}`);
                dom.gameSelector.value = currentGameId;
            } finally {
                dom.gameSelector.disabled = false;
            }
        }

        async function handleGameChange() {
            const selectedValue = dom.gameSelector.value;
            if (selectedValue === 'add_new_game') {
                await addNewGame();
            } else {
                currentGameId = selectedValue;
                localStorage.setItem('rummikubTrackerLastGameId', currentGameId);
                filterWinsForCurrentGame();

                // Load MT state if it's the selected game
                if (currentGameId === 'mexican_train') {
                    await loadMexicanTrainState();
                } else {
                    mexicanTrainState = null; // Clear state if switching away
                }

                renderApp(); // This will now handle showing/hiding the correct tracker
                if (getStoredGeminiApiKey()) handleGetGeminiInsight(false);
            }
        }

        // --- Mexican Train Functions ---
        async function loadMexicanTrainState() {
            if (!db || currentGameId !== 'mexican_train') {
                mexicanTrainState = null;
                return;
            }
            try {
                const gameDocRef = doc(db, ACTIVE_GAMES_COLLECTION, 'mexican_train');
                const docSnap = await getDoc(gameDocRef);
                if (docSnap.exists() && docSnap.data().status === 'ongoing') {
                    mexicanTrainState = { id: docSnap.id, ...docSnap.data() };
                    console.log("Loaded active Mexican Train game state:", mexicanTrainState);
                } else {
                    mexicanTrainState = null;
                    console.log("No active Mexican Train game found in DB.");
                }
            } catch (error) {
                console.error("Error loading Mexican Train state:", error);
                mexicanTrainState = null;
            }
        }

        function renderMexicanTrainTracker() {
            dom.mexicanTrainTracker.classList.remove('hidden');

            if (!mexicanTrainState) {
                // Game has not started, show setup
                dom.mtGameSetup.classList.remove('hidden');
                dom.mtGameActive.classList.add('hidden');
                dom.mtGameOver.classList.add('hidden');
                dom.mtPlayerCheckboxes.innerHTML = players.map(p => `<label class="mt-player-checkbox-item"><input type="checkbox" name="mtPlayer" value="${p.id}"> ${utils.sanitizeHTML(p.name)}</label>`).join('');
                dom.mtStartGameError.textContent = '';
            } else if (mexicanTrainState.status === 'ongoing') {
                dom.mtGameSetup.classList.add('hidden');
                dom.mtGameActive.classList.remove('hidden');
                dom.mtGameOver.classList.add('hidden');

                // Render completed rounds
                const completedRoundsContainer = dom.mtGameActive.querySelector('#mtCompletedRounds');
                const firstRound = 12;
                const completedRoundsCount = firstRound - mexicanTrainState.currentRound;

                completedRoundsContainer.innerHTML = '<h4>Completed Rounds</h4>'; // Reset
                if (completedRoundsCount > 0) {
                    let completedRoundsHTML = '';
                    for (let i = 0; i < completedRoundsCount; i++) {
                        const roundNumber = firstRound - i;
                        const roundIndex = i;
                        const isEditing = mexicanTrainState.editingRoundIndex === roundIndex;

                        completedRoundsHTML += `<div class="mt-round-row ${isEditing ? 'mt-round-row-editing' : ''}" data-round-index="${roundIndex}">`;

                        let playerScoresHTML = Object.entries(mexicanTrainState.players).map(([playerId, data]) => {
                            const score = data.scores[roundIndex];
                            if (isEditing) {
                                return `<input type="number" class="mt-edit-score-input" data-player-id="${playerId}" value="${score}" min="0">`;
                            }
                            return `<span class="player-score"><b>${utils.sanitizeHTML(data.name)}:</b> ${score}</span>`;
                        }).join('');

                        let actionButtonsHTML = '';
                        if (isEditing) {
                            actionButtonsHTML = `<button class="save-round-btn small-nav-button" data-round-index="${roundIndex}">✔️ Save</button> <button class="cancel-edit-btn small-nav-button secondary" data-round-index="${roundIndex}">❌</button>`;
                        } else {
                            actionButtonsHTML = `<button class="edit-round-btn small-nav-button secondary" data-round-index="${roundIndex}">✏️ Edit</button>`;
                        }

                        completedRoundsHTML += `
                            <div>
                                <div class="mt-round-row-header">Round ${roundNumber}</div>
                                <div class="mt-round-scores">${playerScoresHTML}</div>
                            </div>
                            <div>${actionButtonsHTML}</div>
                        `;
                        completedRoundsHTML += `</div>`;
                    }
                    completedRoundsContainer.innerHTML += completedRoundsHTML;
                } else {
                    completedRoundsContainer.innerHTML += '<p class="no-data" style="padding:0; margin-top:0;">No rounds completed yet.</p>';
                }


                // Render current round
                dom.mtRoundTitle.textContent = `Current Round: ${mexicanTrainState.currentRound}`;
                const playerInputHTML = Object.entries(mexicanTrainState.players).map(([id, data]) => {
                    const totalScore = data.scores.reduce((acc, score) => acc + score, 0);
                    return `
                        <span class="mt-player-name">${utils.sanitizeHTML(data.name)}</span>
                        <span class="mt-player-total-score">Total: ${totalScore}</span>
                        <input type="number" class="mt-score-input" data-player-id="${id}" placeholder="Score" min="0">
                    `;
                }).join('');
                dom.mtScoresContainer.innerHTML = playerInputHTML;

                updateMexicanTrainLeader();

            } else { // Game is over
                dom.mtGameSetup.classList.add('hidden');
                dom.mtGameActive.classList.add('hidden');
                dom.mtGameOver.classList.remove('hidden');

                const finalScores = Object.values(mexicanTrainState.players)
                    .map(p => ({ ...p, totalScore: p.scores.reduce((a, b) => a + b, 0) }))
                    .sort((a, b) => a.totalScore - b.totalScore);

                const winner = finalScores[0];
                dom.mtGameOverTitle.textContent = `🎉 ${utils.sanitizeHTML(winner.name)} Wins! 🎉`;

                dom.mtFinalScores.innerHTML = finalScores.map((p, index) =>
                    `<b>${index + 1}. ${utils.sanitizeHTML(p.name)}:</b> ${p.totalScore} points`
                ).join('<br>');
            }
        }

        function updateMexicanTrainLeader() {
            if (!mexicanTrainState || mexicanTrainState.status !== 'ongoing') {
                dom.mtLeaderDisplay.innerHTML = '';
                return;
            }

            const playerTotals = Object.values(mexicanTrainState.players).map(p => {
                const currentRoundScoreInput = dom.mtScoresContainer.querySelector(`.mt-score-input[data-player-id="${p.id}"]`);
                const currentRoundScore = currentRoundScoreInput ? (parseInt(currentRoundScoreInput.value, 10) || 0) : 0;
                const previousTotal = p.scores.reduce((acc, score) => acc + score, 0);
                return { name: p.name, total: previousTotal + currentRoundScore };
            }).sort((a, b) => a.total - b.total);

            if (playerTotals.length > 0) {
                let rankingHtml = '<h4 style="margin-bottom: 5px; color: #0b4f6c;">Live Standings</h4><ul style="list-style-type: none; padding-left: 0; line-height: 1.5;">';
                let lastScore = -1;
                let rank = 0;
                const leaderTotal = playerTotals[0].total;

                playerTotals.forEach((player, index) => {
                    if (player.total !== lastScore) {
                        rank = index + 1;
                    }
                    lastScore = player.total;

                    let behindPreviousText = '';
                    if (index > 0) {
                        const pointsBehind = player.total - playerTotals[index - 1].total;
                        if (pointsBehind > 0) {
                           behindPreviousText = ` <span style="font-size: 0.85em; color: #d95a3a;">(+${pointsBehind})</span>`;
                        }
                    }

                    let behindLeaderText = '';
                    if (index > 0) {
                        const pointsBehindLeader = player.total - leaderTotal;
                        if (pointsBehindLeader > 0) {
                            behindLeaderText = ` <span style="font-size: 0.8em; color: #6c757d;">(${pointsBehindLeader} from 1st)</span>`;
                        }
                    }

                    const isLeader = rank === 1;
                    const fontWeight = isLeader ? 'bold' : 'normal';
                    const nameColor = isLeader ? '#1a7f9a' : '#333';

                    rankingHtml += `<li style="padding: 3px 0; border-bottom: 1px solid #f2f2f2;">`;
                    rankingHtml += `<span style="font-weight: bold; min-width: 25px; display: inline-block;">${rank}.</span>`;
                    rankingHtml += `<span style="font-weight: ${fontWeight}; color: ${nameColor};">${utils.sanitizeHTML(player.name)}:</span>`;
                    rankingHtml += ` ${player.total} pts`;
                    rankingHtml += behindPreviousText;
                    rankingHtml += behindLeaderText;
                    rankingHtml += `</li>`;
                });
                rankingHtml += '</ul>';
                dom.mtLeaderDisplay.innerHTML = rankingHtml;
            } else {
                dom.mtLeaderDisplay.innerHTML = '';
            }
        }

        async function saveEditedMexicanTrainRound(roundIndex) {
            const roundRow = dom.mtCompletedRounds.querySelector(`.mt-round-row[data-round-index="${roundIndex}"]`);
            const scoreInputs = roundRow.querySelectorAll('.mt-edit-score-input');
            let allScoresValid = true;
            const newScores = {};

            scoreInputs.forEach(input => {
                const playerId = input.dataset.playerId;
                const score = parseInt(input.value, 10);
                if (isNaN(score) || score < 0) {
                    allScoresValid = false;
                    input.style.border = '1px solid red';
                } else {
                    newScores[playerId] = score;
                    input.style.border = '';
                }
            });

            if (!allScoresValid) {
                alert("Please enter a valid, non-negative score for all players.");
                return;
            }

            const button = roundRow.querySelector('.save-round-btn');
            button.disabled = true;

            const updatedPlayers = { ...mexicanTrainState.players };
            Object.keys(updatedPlayers).forEach(id => {
                updatedPlayers[id].scores[roundIndex] = newScores[id] || 0;
            });

            try {
                const gameDocRef = doc(db, ACTIVE_GAMES_COLLECTION, 'mexican_train');
                await updateDoc(gameDocRef, { players: updatedPlayers });

                mexicanTrainState.players = updatedPlayers;
                delete mexicanTrainState.editingRoundIndex; // Exit editing mode
                renderMexicanTrainTracker();
            } catch (error) {
                console.error("Error saving edited round:", error);
                alert(`Failed to save changes: ${error.message}`);
                button.disabled = false;
            }
        }

        async function startNewMexicanTrainGame() {
            const selectedCheckboxes = dom.mtPlayerCheckboxes.querySelectorAll('input:checked');
            if (selectedCheckboxes.length < 2) {
                dom.mtStartGameError.textContent = "Please select at least 2 players.";
                return;
            }

            dom.mtStartGameBtn.disabled = true;
            dom.mtStartGameError.textContent = '';

            const newGameState = {
                gameId: 'mexican_train',
                status: 'ongoing',
                currentRound: 12,
                players: {}
            };

            selectedCheckboxes.forEach(cb => {
                const player = players.find(p => p.id === cb.value);
                if (player) {
                    newGameState.players[player.id] = {
                        name: player.name,
                        scores: []
                    };
                }
            });

            try {
                const gameDocRef = doc(db, ACTIVE_GAMES_COLLECTION, 'mexican_train');
                await setDoc(gameDocRef, newGameState);
                mexicanTrainState = { id: 'mexican_train', ...newGameState };
                renderMexicanTrainTracker();
            } catch (error) {
                console.error("Error starting new Mexican Train game:", error);
                dom.mtStartGameError.textContent = `Failed to start game: ${error.message}`;
            } finally {
                dom.mtStartGameBtn.disabled = false;
            }
        }

        async function submitMexicanTrainRound() {
            const scoreInputs = dom.mtScoresContainer.querySelectorAll('.mt-score-input');
            let allScoresValid = true;
            const roundScores = {};

            scoreInputs.forEach(input => {
                const playerId = input.dataset.playerId;
                const score = parseInt(input.value, 10);
                if (isNaN(score) || score < 0) {
                    allScoresValid = false;
                    input.style.border = '1px solid red';
                } else {
                    roundScores[playerId] = score;
                    input.style.border = '';
                }
            });

            if (!allScoresValid) {
                alert("Please enter a valid, non-negative score for all players.");
                return;
            }

            dom.mtSubmitRoundBtn.disabled = true;

            const updatedPlayers = { ...mexicanTrainState.players };
            Object.keys(updatedPlayers).forEach(id => {
                updatedPlayers[id].scores.push(roundScores[id] || 0);
            });

            const isFinalRound = mexicanTrainState.currentRound === 0;
            const newStatus = isFinalRound ? 'completed' : 'ongoing';
            const newRound = isFinalRound ? 0 : mexicanTrainState.currentRound - 1;

            const updatedState = {
                ...mexicanTrainState,
                players: updatedPlayers,
                currentRound: newRound,
                status: newStatus
            };

            try {
                const gameDocRef = doc(db, ACTIVE_GAMES_COLLECTION, 'mexican_train');
                await updateDoc(gameDocRef, {
                    players: updatedPlayers,
                    currentRound: newRound,
                    status: newStatus
                });

                mexicanTrainState = updatedState;

                if (isFinalRound) {
                    const finalScores = Object.entries(mexicanTrainState.players).map(([id, data]) => ({
                        id,
                        name: data.name,
                        totalScore: data.scores.reduce((acc, s) => acc + s, 0)
                    })).sort((a, b) => a.totalScore - b.totalScore);

                    const winnerId = finalScores[0].id;
                    await recordWin(winnerId); // Record the win in the main system
                    alert(`${finalScores[0].name} wins the game!`);
                }

                renderMexicanTrainTracker();

            } catch (error) {
                console.error("Error submitting round:", error);
                alert(`Failed to submit round: ${error.message}`);
            } finally {
                dom.mtSubmitRoundBtn.disabled = false;
            }
        }

        async function endGameEarly() {
            if (!mexicanTrainState || !confirm("Are you sure you want to end this game? The current leader will be declared the winner.")) {
                return;
            }

            dom.mtEndGameBtn.disabled = true;

            const playerTotals = Object.entries(mexicanTrainState.players).map(([id, data]) => ({
                id,
                name: data.name,
                totalScore: data.scores.reduce((acc, s) => acc + s, 0)
            })).sort((a, b) => a.totalScore - b.totalScore);

            const winnerId = playerTotals[0].id;

            const updatedState = {
                ...mexicanTrainState,
                status: 'completed'
            };

            try {
                const gameDocRef = doc(db, ACTIVE_GAMES_COLLECTION, 'mexican_train');
                await updateDoc(gameDocRef, { status: 'completed' });
                await recordWin(winnerId);
                mexicanTrainState = updatedState;
                alert(`${playerTotals[0].name} wins the game!`);
                renderMexicanTrainTracker();
            } catch (error) {
                console.error("Error ending game early:", error);
                alert(`Failed to end game: ${error.message}`);
            } finally {
                dom.mtEndGameBtn.disabled = false;
            }
        }

        // --- Audio Settings Management ---
        async function loadAudioPreferencesFromFirebase() { if (!db) { audioPreferences = []; return; } try { const prefsCollection = collection(db, AUDIO_PREFERENCES_COLLECTION); const prefsQuery = query(prefsCollection, orderBy("name")); const snapshot = await getDocs(prefsQuery); audioPreferences = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); } catch (error) { console.error("Error loading audio preferences:", error); dom.audioUrlStatus.innerHTML = `<span class="error">Failed to load audio list: ${error.message}</span>`; audioPreferences = []; } }
        async function saveAudioPreferenceToFirebase(name, url) { if (!db) return null; name = name.trim(); url = url.trim(); const existingByName = audioPreferences.find(p => p.name.toLowerCase() === name.toLowerCase()); if (existingByName) { dom.audioUrlStatus.innerHTML = `<span class="error">A sound with the name "${utils.sanitizeHTML(name)}" already exists. Please choose a different name.</span>`; return null; } const existingByUrl = audioPreferences.find(p => p.url === url); if (existingByUrl) { dom.audioUrlStatus.innerHTML = `<span class="info">This URL is already saved as "${utils.sanitizeHTML(existingByUrl.name)}". To use it, select it from the list.</span>`; return null; } try { const docRef = await addDoc(collection(db, AUDIO_PREFERENCES_COLLECTION), { name: name, url: url, createdAt: serverTimestamp() }); const newPref = { id: docRef.id, name, url, createdAt: Timestamp.now() }; audioPreferences.push(newPref); audioPreferences.sort((a, b) => a.name.localeCompare(b.name)); return newPref; } catch (error) { console.error("Error saving audio preference:", error); dom.audioUrlStatus.innerHTML = `<span class="error">Failed to save sound: ${error.message}</span>`; return null; } }
        async function getActiveAudioPreferenceIdFromFirebase() { if (!db) return "default"; try { const configDocRef = doc(db, APP_CONFIG_COLLECTION, TIMER_SETTINGS_DOC_ID); const docSnap = await getDoc(configDocRef); if (docSnap.exists() && docSnap.data().activeAudioPreferenceId) { return docSnap.data().activeAudioPreferenceId; } return "default"; } catch (error) { console.error("Error getting active audio preference:", error); return "default"; } }
        async function setActiveAudioPreferenceIdInFirebase(preferenceId) { if (!db) return; currentActiveAudioPreferenceId = preferenceId; try { const configDocRef = doc(db, APP_CONFIG_COLLECTION, TIMER_SETTINGS_DOC_ID); await setDoc(configDocRef, { activeAudioPreferenceId: preferenceId }, { merge: true }); } catch (error) { console.error("Error setting active audio preference:", error); dom.audioUrlStatus.innerHTML = `<span class="error">Failed to save active sound choice: ${error.message}</span>`; } }
        
        const populateAudioSourceSelect = () => {
            const activeId = currentActiveAudioPreferenceId;
            dom.audioSourceSelect.innerHTML = '';
            
            const defaultOption = new Option("Default Sound", "default");
            dom.audioSourceSelect.add(defaultOption);

            const randomMixOption = new Option("🔀 Random Mix (Sounds + AI)", RANDOM_MIX_AUDIO_ID);
            dom.audioSourceSelect.add(randomMixOption);

            audioPreferences.forEach(pref => {
                const option = new Option(utils.sanitizeHTML(pref.name), pref.id);
                dom.audioSourceSelect.add(option);
            });
            
            const customNewOption = new Option("Add New Custom Sound...", "custom_new");
            dom.audioSourceSelect.add(customNewOption);

            const isValidStaticPref = audioPreferences.some(p => p.id === activeId);
            if (activeId !== "default" && activeId !== AI_COMMENTATOR_ID && activeId !== RANDOM_MIX_AUDIO_ID && !isValidStaticPref) {
                console.warn(`Stale activeAudioPreferenceId '${activeId}' found. Reverting to default.`);
                currentActiveAudioPreferenceId = "default";
                if(firebaseInitializedSuccessfully) setActiveAudioPreferenceIdInFirebase("default");
                dom.audioSourceSelect.value = "default";
            } else {
                dom.audioSourceSelect.value = activeId || "default";
            }
        };

        const updateCustomAudioUI = () => {
            const selectedValue = dom.audioSourceSelect.value;
            if (selectedValue === "custom_new") {
                dom.customUrlGroup.classList.remove('hidden');
                dom.customAudioShortNameInput.value = "";
                dom.customAudioUrlInput.value = "";
                dom.customAudioShortNameInput.readOnly = false;
                dom.customAudioUrlInput.readOnly = false;
                dom.saveCustomAudioBtn.classList.remove('hidden');
                dom.removeFavoriteBtn.classList.add('hidden');
                dom.customAudioShortNameInput.focus();
            } else {
                dom.customUrlGroup.classList.add('hidden');
                dom.saveCustomAudioBtn.classList.add('hidden');
                dom.customAudioShortNameInput.value = "";
                dom.customAudioUrlInput.value = "";
                if (selectedValue === "default" || selectedValue === AI_COMMENTATOR_ID || selectedValue === RANDOM_MIX_AUDIO_ID) {
                    dom.removeFavoriteBtn.classList.add('hidden');
                } else {
                    const selectedPref = audioPreferences.find(p => p.id === selectedValue);
                    if (selectedPref) {
                        dom.removeFavoriteBtn.classList.remove('hidden');
                    } else {
                        dom.removeFavoriteBtn.classList.add('hidden');
                    }
                }
            }
        };

        const applyAudioChoice = async (preferenceId) => {
            let urlToLoad;
            let statusName;

            if (preferenceId === AI_COMMENTATOR_ID) {
                dom.timerAudio.src = "";
                statusName = "✨ AI Comedic Commentator";
            } else if (preferenceId === RANDOM_MIX_AUDIO_ID) {
                dom.timerAudio.src = "";
                statusName = "🔀 Random Mix (Sounds + AI)";
            } else if (preferenceId === "default" || !preferenceId) {
                urlToLoad = DEFAULT_AUDIO_URL;
                statusName = "Default Sound";
                preferenceId = "default";
            } else {
                const pref = audioPreferences.find(p => p.id === preferenceId);
                if (pref) {
                    urlToLoad = pref.url;
                    statusName = utils.sanitizeHTML(pref.name);
                } else {
                    console.warn(`Audio preference ID "${preferenceId}" not found during apply. Reverting to default.`);
                    urlToLoad = DEFAULT_AUDIO_URL;
                    statusName = "Default Sound";
                    preferenceId = "default";
                }
            }

            if (urlToLoad && dom.timerAudio.src !== urlToLoad) {
                dom.timerAudio.src = urlToLoad;
                dom.timerAudio.load();
            } else if (urlToLoad && (!dom.timerAudio.src || dom.timerAudio.src === window.location.href)) {
                dom.timerAudio.src = urlToLoad;
                dom.timerAudio.load();
            }

            if (firebaseInitializedSuccessfully) await setActiveAudioPreferenceIdInFirebase(preferenceId);
            dom.audioUrlStatus.innerHTML = `<span class="info">Currently using: ${statusName}</span>`;
            console.log(`Audio choice applied: ${preferenceId} (${statusName})`);
            if (isTimerVisible || audioUnlocked) { unlockAudioContext(); }
        };


        // --- Firebase Data Functions ---
        const loadData = async () => { if (!firebaseInitializedSuccessfully || !db) { console.error("loadData: Firebase not initialized or DB unavailable."); dom.noPlayersForScoringMsg.textContent = "Error: Database unavailable."; dom.noPlayersForScoringMsg.classList.remove('hidden'); dom.noWinsTodayMsg.textContent = "Error: Database unavailable."; dom.noWinsTodayMsg.classList.remove('hidden'); return; } console.log("loadData: Attempting to load data from Firestore..."); dom.noPlayersForScoringMsg.textContent = "Loading players..."; dom.noPlayersForScoringMsg.classList.remove('hidden'); dom.noWinsTodayMsg.textContent = "Loading wins..."; dom.noWinsTodayMsg.classList.remove('hidden'); try { const playersCollectionRef = collection(db, "players"); const playerQuery = query(playersCollectionRef, orderBy("name")); const playerSnapshot = await getDocs(playerQuery); players = playerSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); console.log(`loadData: Players loaded: ${players.length}`, players); const winsCollectionRef = collection(db, "wins"); const winSnapshot = await getDocs(winsCollectionRef); allWins = winSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); allWins = allWins.filter(w => w.timestamp && typeof w.timestamp.toDate === 'function'); console.log(`loadData: Total wins loaded (all games): ${allWins.length}`); filterWinsForCurrentGame(); console.log(`loadData: Wins loaded: ${wins.length}`, wins); dom.noPlayersForScoringMsg.textContent = "Add players to track wins."; dom.noWinsTodayMsg.textContent = "No wins recorded yet today."; } catch (error) { console.error("loadData: Error loading data from Firestore:", error); if (dom.firebaseErrorDiv) { dom.firebaseErrorMessageSpan.textContent = `Failed to load game data. Error: ${error.message}. Check Firestore rules, API enablement, and console.`; dom.firebaseErrorDiv.style.display = 'block'; } players = []; allWins = []; wins = []; dom.noPlayersForScoringMsg.textContent = "Error loading players."; dom.noWinsTodayMsg.textContent = "Error loading wins."; } finally { renderApp(); } };
        const addPlayer = async (name) => { if (!firebaseInitializedSuccessfully || !db) { alert("Database connection error. Cannot add player."); return; } const tN = name.trim(); if (!tN) { dom.addPlayerError.textContent = "Name empty."; return; } if (players.some(p => p.name.toLowerCase() === tN.toLowerCase())) { dom.addPlayerError.textContent = "Name exists."; return; } dom.addPlayerError.textContent = ""; dom.addPlayerBtn.disabled = true; try { const dR = await addDoc(collection(db, "players"), { name: tN }); players.push({ id: dR.id, name: tN }); players.sort((a, b) => a.name.localeCompare(b.name)); renderApp(); dom.newPlayerNameInput.value = ''; if (getStoredGeminiApiKey()) handleGetGeminiInsight(false); } catch (error) { console.error("Error adding player:", error); dom.addPlayerError.textContent = `Failed to add player: ${error.message}`; } finally { dom.addPlayerBtn.disabled = false; } };
        const deletePlayer = async (playerId) => { if (!firebaseInitializedSuccessfully || !db) { alert("Database connection error. Cannot delete player."); return; } const p = players.find(pl => pl.id === playerId); if (!p || !confirm(`Delete ${utils.sanitizeHTML(p.name)}? This player will be removed from all games. Their past wins will remain attributed to 'Unknown Player'.`)) return; const delBtn = dom.playerListManagementUl.querySelector(`.player-management-entry[data-player-id="${playerId}"] .delete-player-btn`); if (delBtn) delBtn.disabled = true; try { await deleteDoc(doc(db, "players", playerId)); players = players.filter(pl => pl.id !== playerId); renderApp(); if (getStoredGeminiApiKey()) handleGetGeminiInsight(false); } catch (error) { console.error("Error deleting player:", error); alert(`Failed: ${error.message}`); if (delBtn) delBtn.disabled = false; } };
        const renamePlayer = async (playerId, newName) => { if (!firebaseInitializedSuccessfully || !db) { alert("Database connection error. Cannot rename player."); return false; } const tN = newName.trim(); if (!tN) { alert("Name empty."); return false; } if (players.some(p => p.id !== playerId && p.name.toLowerCase() === tN.toLowerCase())) { alert("Name exists."); return false; } const pI = players.findIndex(p => p.id === playerId); if (pI === -1) return false; const entry = dom.playerListManagementUl.querySelector(`.player-management-entry[data-player-id="${playerId}"]`); const saveBtn = entry?.querySelector('.save-rename-btn'); const cancelBtn = entry?.querySelector('.cancel-rename-btn'); if(saveBtn) saveBtn.disabled = true; if(cancelBtn) cancelBtn.disabled = true; try { await updateDoc(doc(db, "players", playerId), { name: tN }); players[pI].name = tN; players.sort((a, b) => a.name.localeCompare(b.name)); renderApp(); if (getStoredGeminiApiKey()) handleGetGeminiInsight(false); return true; } catch (error) { console.error("Error renaming player:", error); alert(`Failed: ${error.message}`); if(saveBtn) saveBtn.disabled = false; if(cancelBtn) cancelBtn.disabled = false; return false; } };
        const recordWin = async (playerId) => { if (!firebaseInitializedSuccessfully || !db) { alert("Database connection error. Cannot record win."); return; } const player = players.find(pl => pl.id === playerId); if (!player) return; const winButton = dom.scoreTrackingListUl.querySelector(`button.add-win-btn[data-player-id="${playerId}"]`); const playerInfoDiv = dom.scoreTrackingListUl.querySelector(`li[data-player-id="${playerId}"] .player-info`); if (winButton) winButton.disabled = true; const existingFeedback = playerInfoDiv?.querySelector('.win-feedback'); if (existingFeedback) existingFeedback.remove(); try { const winData = { playerId: playerId, timestamp: serverTimestamp(), gameId: currentGameId }; const docRef = await addDoc(collection(db, "wins"), winData); const newWin = { id: docRef.id, playerId: playerId, timestamp: Timestamp.now(), gameId: currentGameId }; allWins.unshift(newWin); filterWinsForCurrentGame(); const playerName = utils.sanitizeHTML(player.name); const feedbackSpan = document.createElement('span'); feedbackSpan.className = 'win-feedback'; feedbackSpan.textContent = `Win added for ${playerName}!`; if (playerInfoDiv) { playerInfoDiv.appendChild(feedbackSpan); setTimeout(() => { feedbackSpan.remove(); }, 3000); } renderTodaysWinsList(); renderDashboard(); if (getStoredGeminiApiKey()) handleGetGeminiInsight(false); } catch (error) { console.error("Error recording win:", error); alert(`Failed to record win: ${error.message}`); } finally { setTimeout(() => { if (winButton) winButton.disabled = false; }, 500); } };
        const deleteWin = async (winId) => { if (!firebaseInitializedSuccessfully || !db) { alert("Database connection error. Cannot delete win."); return; } const winInAll = allWins.find(w => w.id === winId); if (!winInAll) return; const pN = players.find(p=>p.id === winInAll.playerId)?.name ?? 'Unknown Player'; if (!confirm(`Delete win for ${utils.sanitizeHTML(pN)} at ${utils.formatTime(winInAll.timestamp)}?`)) return; const delBtn = dom.todaysWinsListUl.querySelector(`li[data-win-id="${winId}"] .delete-win-btn`); if(delBtn) delBtn.disabled = true; try { await deleteDoc(doc(db, "wins", winId)); allWins = allWins.filter(w => w.id !== winId); filterWinsForCurrentGame(); renderTodaysWinsList(); renderDashboard(); if (getStoredGeminiApiKey()) handleGetGeminiInsight(false); } catch (error) { console.error("Error deleting win:", error); alert(`Failed: ${error.message}`); if(delBtn) delBtn.disabled = false; } };
        const getWinsForPeriodLocal = (period, baseDate = new Date()) => { const { start, end } = utils.getPeriodRange(period, baseDate); const sT = start.getTime(); const eT = end.getTime(); return wins.filter(w => { if (!w.timestamp || typeof w.timestamp.toDate !== 'function') return false; const wT = w.timestamp.toDate().getTime(); return wT >= sT && wT <= eT; }); };
        const getWinsForYearLocal = (year) => { const s = new Date(year, 0, 1); const e = new Date(year, 11, 31, 23, 59, 59, 999); const sT = s.getTime(); const eT = e.getTime(); return wins.filter(w => { if (!w.timestamp || typeof w.timestamp.toDate !== 'function') return false; const wT = w.timestamp.toDate().getTime(); return wT >= sT && wT <= eT; }); };

        // --- Rendering Functions ---
        const renderPlayerManagementList = () => { dom.playerListManagementUl.innerHTML = ''; dom.noPlayersManagedMsg.classList.toggle('hidden', players.length > 0 || !firebaseInitializedSuccessfully); if (players.length === 0 && firebaseInitializedSuccessfully) return; if(!firebaseInitializedSuccessfully && dom.playerListManagementUl) { dom.playerListManagementUl.innerHTML = '<p class="no-data">Player management unavailable (database error).</p>'; return; } players.forEach(p => { const li = document.createElement('li'); li.className = 'player-management-entry'; li.dataset.playerId = p.id; const sN = utils.sanitizeHTML(p.name); li.innerHTML = ` <span class="player-name-display">${sN}</span> <div class="rename-controls hidden"> <input type="text" class="rename-input" value="${sN}" aria-label="New name for ${sN}"> <button class="save-rename-btn icon-button" aria-label="Save rename">✔️</button> <button class="cancel-rename-btn icon-button secondary" aria-label="Cancel rename">❌</button> </div> <div class="action-buttons"> <button class="rename-btn icon-button secondary" aria-label="Rename ${sN}">✏️ Rename</button> <button class="delete-player-btn icon-button danger" aria-label="Delete ${sN}">🗑️ Delete</button> </div> `; dom.playerListManagementUl.appendChild(li); }); };
        const renderScoreTrackingList = () => {
            const currentGame = games.find(g => g.id === currentGameId);
            const gameType = currentGame?.type || 'simple';

            // Hide all trackers initially
            dom.scoreTrackingListUl.classList.add('hidden');
            dom.mexicanTrainTracker.classList.add('hidden');
            dom.noPlayersForScoringMsg.classList.add('hidden');

            if (gameType === 'points_based_lowest_wins') {
                renderMexicanTrainTracker();
            } else { // 'simple' game type
                dom.scoreTrackingListUl.classList.remove('hidden');
                dom.scoreTrackingListUl.innerHTML = '';
                dom.noPlayersForScoringMsg.classList.toggle('hidden', players.length > 0 || !firebaseInitializedSuccessfully);
                if (players.length === 0 && firebaseInitializedSuccessfully) {
                    dom.noPlayersForScoringMsg.textContent = "Add players to track wins.";
                    return;
                }
                if (!firebaseInitializedSuccessfully && dom.scoreTrackingListUl) {
                    dom.scoreTrackingListUl.innerHTML = '<p class="no-data">Score tracking unavailable (database error).</p>';
                    dom.noPlayersForScoringMsg.classList.add('hidden');
                    return;
                }
                players.forEach(p => {
                    const li = document.createElement('li');
                    li.dataset.playerId = p.id;
                    const sN = utils.sanitizeHTML(p.name);
                    li.innerHTML = ` <div class="player-info"> <span class="player-name">${sN}</span> </div> <button class="add-win-btn" data-player-id="${p.id}">+ Win</button> `;
                    dom.scoreTrackingListUl.appendChild(li);
                });
            }
        };
        const renderTodaysWinsList = () => { dom.todaysWinsListUl.innerHTML = ''; dom.todaysSummaryDiv.innerHTML = ''; dom.todaysSummaryDiv.classList.add('hidden'); const todayStr = utils.getTodayDateString(); dom.todayDateDisplay.textContent = todayStr; if (!firebaseInitializedSuccessfully) { dom.noWinsTodayMsg.textContent="Win list unavailable (database error)."; dom.noWinsTodayMsg.classList.remove('hidden'); return;} const todaysWins = wins.filter(w => w.timestamp?.toDate().toDateString() === todayStr); dom.noWinsTodayMsg.classList.toggle('hidden', todaysWins.length > 0); if (todaysWins.length > 0) { const winsByPlayerToday = todaysWins.reduce((acc, win) => { acc[win.playerId] = (acc[win.playerId] || 0) + 1; return acc; }, {}); const summaryItems = []; const sortedPlayerIds = Object.keys(winsByPlayerToday).sort((a, b) => { const playerA = players.find(p => p.id === a); const playerB = players.find(p => p.id === b); const nameA = playerA ? playerA.name : 'Unknown'; const nameB = playerB ? playerB.name : 'Unknown'; return nameA.localeCompare(nameB); }); sortedPlayerIds.forEach(playerId => { const count = winsByPlayerToday[playerId]; const player = players.find(p => p.id === playerId); const playerName = player ? utils.sanitizeHTML(player.name) : 'Unknown Player'; summaryItems.push(`<span>${playerName}: ${utils.pluralize(count, 'win')}</span>`); }); if (summaryItems.length > 0) { dom.todaysSummaryDiv.innerHTML = `<strong>Summary:</strong> ${summaryItems.join(' ')}`; dom.todaysSummaryDiv.classList.remove('hidden'); } todaysWins.forEach(w => { const player = players.find(pl => pl.id === w.playerId); const playerName = player ? utils.sanitizeHTML(player.name) : 'Unknown Player'; const li = document.createElement('li'); li.dataset.winId = w.id; li.innerHTML = ` <span class="player-name">${playerName}</span> <span class="win-timestamp">${utils.formatTime(w.timestamp)}</span> <button class="delete-win-btn icon-button danger" aria-label="Delete this win">🗑️</button> `; dom.todaysWinsListUl.appendChild(li); }); } };
        const renderDashboard = () => { dom.dashboardControls.querySelectorAll('button[data-period]').forEach(b => { b.classList.toggle('active', b.dataset.period === currentDashboardPeriod); }); dom.playerViewBtn.classList.toggle('active', currentView === 'player'); dom.monthlyViewBtn.classList.toggle('active', currentView === 'monthly'); dom.winChartContainer.classList.toggle('hidden', currentView !== 'player'); dom.monthlyChartContainer.classList.toggle('hidden', currentView === 'player'); if (currentView === 'player') { renderPlayerWinsChart(currentDashboardPeriod, currentDisplayDate); } else if (currentView === 'monthly') { renderMonthlyBreakdownChart(currentDisplayDate.getFullYear()); } };
        const renderPlayerWinsChart = (period, displayDate) => { if (playerWinChartInstance) { playerWinChartInstance.destroy(); playerWinChartInstance = null; } if (!firebaseInitializedSuccessfully) {dom.noChartDataMsg.textContent="Charts unavailable (database error)."; dom.noChartDataMsg.classList.remove('hidden'); dom.playerWinCanvas.classList.add('hidden'); return;} const { start, end } = utils.getPeriodRange(period, displayDate); let chartTitleText = ''; const today = new Date(); today.setHours(0,0,0,0); const currentPeriodRange = utils.getPeriodRange(period, today); const isCurrentPeriod = currentPeriodRange.start.getTime() === start.getTime(); switch (period) { case 'week': chartTitleText = isCurrentPeriod ? 'Wins This Week' : `Week of ${start.toLocaleDateString()}`; break; case 'month': const monthName = utils.getFullMonthName(displayDate.getMonth()); chartTitleText = isCurrentPeriod ? `Wins This ${monthName}` : `Wins ${monthName} ${displayDate.getFullYear()}`; break; case 'year': chartTitleText = isCurrentPeriod ? `Wins This Year (${displayDate.getFullYear()})` : `Wins ${displayDate.getFullYear()}`; break; } dom.winChartTitle.textContent = chartTitleText; dom.prevPeriodBtn.classList.remove('hidden'); dom.nextPeriodBtn.classList.remove('hidden'); const endOfToday = new Date(); endOfToday.setHours(23,59,59,999); dom.nextPeriodBtn.disabled = end.getTime() >= endOfToday.getTime(); const periodWins = getWinsForPeriodLocal(period, displayDate); const totalWinsCount = periodWins.length; dom.totalPlayerWinsDisplay.textContent = `Total Wins: ${totalWinsCount}`; dom.totalPlayerWinsDisplay.classList.remove('hidden'); const hasPlayers = players.length > 0; const hasData = totalWinsCount > 0; let playerData = []; if (hasPlayers) { const winsByPlayer = players.reduce((acc, p) => { acc[p.id] = { name: p.name, count: 0 }; return acc; }, {}); periodWins.forEach(w => { if (w.playerId && winsByPlayer[w.playerId]) { winsByPlayer[w.playerId].count++; } }); playerData = Object.values(winsByPlayer); playerData.sort((a, b) => a.name.localeCompare(b.name)); } const showChart = hasPlayers && hasData; dom.playerWinCanvas.classList.toggle('hidden', !showChart); dom.noChartDataMsg.classList.toggle('hidden', showChart); if (!hasPlayers) { dom.noChartDataMsg.textContent = "Add players to see statistics."; dom.totalPlayerWinsDisplay.classList.add('hidden'); } else if (!hasData) { dom.noChartDataMsg.textContent = "No wins recorded for this period."; } if (showChart) { const ctx = dom.playerWinCanvas.getContext('2d'); if (!ctx) return; const labels = playerData.map(p => p.name); const dataCounts = playerData.map(p => p.count); playerWinChartInstance = new Chart(ctx, { type: 'bar', data: { labels: labels, datasets: [{ label: 'Wins', data: dataCounts, backgroundColor: '#219ebc', borderColor: '#1a7f9a', borderWidth: 1 }] }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true, ticks: { stepSize: 1, precision: 0 } } }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: function(c) { let l = c.dataset.label || ''; if (l) { l += ': '; } if (c.parsed.y !== null) { l += c.parsed.y + (c.parsed.y === 1 ? ' win' : ' wins'); } return l; } } } } } }); } };
        const renderMonthlyBreakdownChart = (year) => { if (monthlyChartInstance) { monthlyChartInstance.destroy(); monthlyChartInstance = null; } if (!firebaseInitializedSuccessfully) {dom.noMonthlyChartDataMsg.textContent="Charts unavailable (database error)."; dom.noMonthlyChartDataMsg.classList.remove('hidden'); dom.monthlyWinsCanvas.classList.add('hidden'); return;} dom.monthlyChartTitle.textContent = `Monthly Winners for ${year}`; dom.nextYearBtn.disabled = year >= new Date().getFullYear(); const yearWins = getWinsForYearLocal(year); const totalWinsCount = yearWins.length; const hasData = totalWinsCount > 0; dom.totalMonthlyWinsDisplay.textContent = `Total Wins: ${totalWinsCount}`; dom.totalMonthlyWinsDisplay.classList.remove('hidden'); let monthlyResults = []; let overallMaxWinningScore = 0; if(hasData) { const monthlyPlayerWins = {}; yearWins.forEach(win => { if (win.timestamp && typeof win.timestamp.toDate === 'function' && win.playerId) { const mI = win.timestamp.toDate().getMonth(); monthlyPlayerWins[mI] = monthlyPlayerWins[mI] || {}; monthlyPlayerWins[mI][win.playerId] = (monthlyPlayerWins[mI][win.playerId] || 0) + 1; } }); for (let i = 0; i < 12; i++) { const monthData = monthlyPlayerWins[i]; let winners = []; let maxScore = 0; if (monthData && Object.keys(monthData).length > 0) { maxScore = Math.max(...Object.values(monthData)); if (maxScore > overallMaxWinningScore) overallMaxWinningScore = maxScore; winners = Object.entries(monthData).filter(([_, score]) => score === maxScore).map(([playerId, _]) => utils.sanitizeHTML(players.find(p => p.id === playerId)?.name ?? 'Unknown')); } monthlyResults.push({ monthIndex: i, winnerNames: winners, winningScore: maxScore }); } } else { for (let i = 0; i < 12; i++) monthlyResults.push({ monthIndex: i, winnerNames: [], winningScore: 0 }); } dom.monthlyWinsCanvas.classList.toggle('hidden', !hasData); dom.noMonthlyChartDataMsg.classList.toggle('hidden', hasData); if (!hasData) dom.noMonthlyChartDataMsg.textContent = `No wins recorded for ${year}.`; if(hasData) { const ctx = dom.monthlyWinsCanvas.getContext('2d'); if (!ctx) return; const labels = monthlyResults.map(r => utils.getMonthName(r.monthIndex)); const dataScores = monthlyResults.map(r => r.winningScore); const yAxisMax = Math.max(3, overallMaxWinningScore + 2); monthlyChartInstance = new Chart(ctx, { type: 'bar', data: { labels: labels, datasets: [{ label: 'Winning Score', data: dataScores, backgroundColor: '#fdc500', borderColor: '#e8b700', borderWidth: 1 }] }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true, max: yAxisMax, ticks: { stepSize: 1, precision: 0 } } }, plugins: { legend: { display: false }, tooltip: { callbacks: { title: (tooltipItems) => `${utils.getFullMonthName(tooltipItems[0].dataIndex)} ${year}`, label: (context) => { const index = context.dataIndex; const result = monthlyResults[index]; let winnerLabel = (!result || result.winnerNames.length === 0) ? 'Winner: N/A' : (result.winnerNames.length === 1 ? `Winner: ${result.winnerNames[0]}` : `Tie: ${result.winnerNames.join(', ')}`); const scoreLabel = `Score: ${context.parsed.y}`; return [winnerLabel, scoreLabel]; } } }, datalabels: { display: (context) => context.dataset.data[context.dataIndex] > 0, anchor: 'end', align: 'top', offset: -2, color: '#555', font: { size: 10, weight: 'bold' }, formatter: (value, context) => { const index = context.dataIndex; const result = monthlyResults[index]; if (!result || result.winnerNames.length === 0) return ''; let name = result.winnerNames.length === 1 ? result.winnerNames[0] : 'Tie'; return name.length > 8 ? name.substring(0, 7) + '…' : name; } } } } }); } };
        const renderApp = () => { renderPlayerManagementList(); renderScoreTrackingList(); renderTodaysWinsList(); renderDashboard(); console.log("renderApp: UI rendered/updated.");};

        // --- Timer Functions ---
        const formatTimerTime = (totalSeconds) => { const minutes = Math.floor(totalSeconds / 60); const seconds = totalSeconds % 60; return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`; };
        const updateTimerDisplay = () => { if(dom.timerDisplay) dom.timerDisplay.textContent = formatTimerTime(timerRemainingSeconds); };

        const updateTimerCurtain = () => {
            if(dom.timerCurtain) {
                const scale = timerRemainingSeconds / TIMER_DURATION_SECONDS;
                dom.timerCurtain.style.transform = `scaleY(${scale})`;
            }
        };

        const unlockAudioContext = () => {
            if (dom.timerAudio && dom.timerAudio.src && dom.timerAudio.readyState < 1 &&
                currentActiveAudioPreferenceId !== AI_COMMENTATOR_ID &&
                currentActiveAudioPreferenceId !== RANDOM_MIX_AUDIO_ID) {
                const playPromise = dom.timerAudio.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => dom.timerAudio.pause()).catch(e => { if(e.name !== 'AbortError') console.warn("Main audio unlock failed", e);});
                }
            }
            if (!audioUnlocked) {
                console.log("Attempting to unlock audio context generally.");
                audioUnlocked = true;
            }
        };

        const playStandardBeepSound = () => {
            if (currentActiveAudioPreferenceId === AI_COMMENTATOR_ID) {
                console.warn("playStandardBeepSound called when AI_COMMENTATOR_ID is active. This should be handled by playTimerEndSound.");
                return;
            }
            if (!dom.timerAudio || !dom.timerAudio.src) {
                console.error("playStandardBeepSound: dom.timerAudio.src is not set. Cannot play sound.");
                return;
            }
            if (!audioUnlocked) {
                unlockAudioContext();
            }

            // A Promise-based wrapper to ensure we handle the 'ended' event correctly.
            const playPromise = dom.timerAudio.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    // Once playback starts, listen for it to end.
                    dom.timerAudio.onended = () => {
                        dom.timerAudio.pause();
                        // Setting src to empty string is a common technique to release audio focus
                        // and resources on mobile browsers.
                        dom.timerAudio.src = '';
                        dom.timerAudio.load(); // Reset the audio element
                        dom.timerAudio.onended = null; // Clean up the listener
                        console.log("Audio playback ended and resources released.");
                    };
                }).catch(error => {
                    console.error("Timer audio playback failed:", error);
                    // If play fails, also try to clean up.
                    dom.timerAudio.src = '';
                    dom.timerAudio.load();
                });
            }
        };
        
        async function playRandomExistingSound() {
            const availableSounds = [{ id: 'default', name: 'Default Sound', url: DEFAULT_AUDIO_URL }];
            audioPreferences.forEach(pref => availableSounds.push(pref));
            const randomSound = availableSounds[Math.floor(Math.random() * availableSounds.length)];
            console.log("Random Mix: Selected existing sound:", randomSound.name, randomSound.url);
            if (dom.timerAudio.src !== randomSound.url) {
                dom.timerAudio.src = randomSound.url;
                dom.timerAudio.load();
            }
            playStandardBeepSound();
        }

        async function playTimerEndSound() {
            unlockAudioContext();
            if (currentActiveAudioPreferenceId === RANDOM_MIX_AUDIO_ID) {
                console.log("Random Mix: Choosing existing sound.");
                await playRandomExistingSound();
            } else if (currentActiveAudioPreferenceId === AI_COMMENTATOR_ID) {
                if (preloadedAiCommentaryUrl) {
                    console.log("Playing preloaded AI commentary.");
                    dom.timerAudio.src = preloadedAiCommentaryUrl;
                    dom.timerAudio.play().catch(e => {
                        console.error("Error playing preloaded AI commentary:", e);
                        playStandardBeepSound();
                    });
                    dom.timerAudio.onended = () => {
                        URL.revokeObjectURL(preloadedAiCommentaryUrl);
                        preloadedAiCommentaryUrl = null;
                        currentTimerAiCommentaryText = "";
                        dom.timerAudio.onended = null;
                    };
                    preloadedAiCommentaryUrl = null;
                } else {
                    console.warn("AI commentary URL not ready, fetching now or playing fallback.");
                    await fetchAndPlayAiTimerCommentary(true);
                }
            } else {
                playStandardBeepSound();
            }
        }

        const timerTick = async () => {
            if (!isTimerVisible) { stopTimer(); return; }
            timerRemainingSeconds--;

            if (currentActiveAudioPreferenceId === AI_COMMENTATOR_ID &&
                timerRemainingSeconds === PRELOAD_AI_COMMENTARY_SECONDS_BEFORE_END &&
                !isLoadingAiCommentary && !preloadedAiCommentaryUrl) {
                console.log("Timer tick: Preloading AI commentary...");
                await preloadAiTimerCommentary();
            }

            if (timerRemainingSeconds < 0) {
                await playTimerEndSound();
                timerRemainingSeconds = TIMER_DURATION_SECONDS;
            }
            updateTimerDisplay();
            updateTimerCurtain();
            timerTimeoutId = setTimeout(timerTick, 1000);
        };

        const startTimer = () => {
            stopTimer();
            isTimerVisible = true;
            timerRemainingSeconds = (timerRemainingSeconds > 0 && timerRemainingSeconds <= TIMER_DURATION_SECONDS) ? timerRemainingSeconds : TIMER_DURATION_SECONDS;
            updateTimerDisplay();
            updateTimerCurtain();
            timerTimeoutId = setTimeout(timerTick, 1000);
        };

        const stopTimer = () => {
            if (timerTimeoutId) { clearTimeout(timerTimeoutId); timerTimeoutId = null; }
            isLoadingAiCommentary = false;
            if (preloadedAiCommentaryUrl) {
                URL.revokeObjectURL(preloadedAiCommentaryUrl);
                preloadedAiCommentaryUrl = null;
            }
            if (dom.timerAudio && dom.timerAudio.src && dom.timerAudio.src.startsWith('blob:')) {
                dom.timerAudio.pause();
                dom.timerAudio.removeAttribute('src');
            }
            currentTimerAiCommentaryText = "";
        };

        const handleNextTimerClick = async () => {
            unlockAudioContext(); 
            stopTimer(); 
            timerRemainingSeconds = TIMER_DURATION_SECONDS;

            if (dom.timerCurtain) {
                dom.timerCurtain.style.transform = 'scaleY(1)';
            }
            updateTimerDisplay();
            updateTimerCurtain();

            timerRestartCount++;
            if (getStoredGeminiApiKey() && firebaseInitializedSuccessfully && timerRestartCount >= IMAGE_REGEN_THRESHOLD) {
                console.log(`Timer restarted ${timerRestartCount} times. Generating new image and insight.`);
                await handleGetGeminiInsight(true);
                timerRestartCount = 0;
            }

            if (currentActiveAudioPreferenceId === RANDOM_MIX_AUDIO_ID) {
                console.log("Next Click (Random Mix): Playing random sound/AI for next turn.");
                await playTimerEndSound();
            } else if (currentActiveAudioPreferenceId === AI_COMMENTATOR_ID) {
                console.log("Next Click: Fetching and playing AI commentary for next turn...");
                await fetchAndPlayAiTimerCommentary(false);
            } else {
                setTimeout(() => playStandardBeepSound(), 50);
            }
            startTimer();
        };

        // --- WAKE LOCK FUNCTIONS ---
        const requestWakeLock = async () => {
            if ('wakeLock' in navigator) {
                try {
                    wakeLockSentinel = await navigator.wakeLock.request('screen');
                    wakeLockSentinel.addEventListener('release', () => {
                        if (isTimerVisible) console.warn('Wake Lock released while timer visible.');
                        wakeLockSentinel = null;
                    });
                    console.log('Wake Lock active.');
                } catch (err) {
                    console.error(`Wake Lock Failed: ${err.name}, ${err.message}`);
                    wakeLockSentinel = null;
                }
            } else {
                console.warn('Wake Lock API not supported.');
            }
        };

        const releaseWakeLock = async () => {
            if (wakeLockSentinel) {
                await wakeLockSentinel.release();
                wakeLockSentinel = null;
                console.log('Wake Lock released.');
            }
        };
        // --- END WAKE LOCK FUNCTIONS ---

        const showTimer = async () => {
            if (isTimerVisible) return;
            document.documentElement.classList.add('timer-active');
            document.body.classList.add('timer-active');
            unlockAudioContext();

            if (dom.timerCurtain) {
                // Reset curtain to be fully down
                dom.timerCurtain.style.transition = 'none';
                dom.timerCurtain.style.transform = 'scaleY(1)';
                void dom.timerCurtain.offsetWidth; // Force reflow
                dom.timerCurtain.style.transition = 'transform 0.2s linear';
            }
            if (geminiImageCache.length > 0) {
                dom.timerBackgroundImage.src = `data:image/png;base64,${geminiImageCache[0]}`;
            } else {
                dom.timerBackgroundImage.src = '';
            }

            dom.timerOverlay.style.display = 'flex';
            dom.toggleTimerBtn.textContent = '⏱️ Hide Timer';
            await requestWakeLock(); 
            startTimer();
        };
        
        const hideTimer = async () => {
            if (!isTimerVisible) return;
            document.documentElement.classList.remove('timer-active');
            document.body.classList.remove('timer-active');
            isTimerVisible = false;
            stopTimer();
            dom.timerOverlay.style.display = 'none';
            dom.toggleTimerBtn.textContent = '⏱️ Timer';
            await releaseWakeLock(); 

            timerRemainingSeconds = TIMER_DURATION_SECONDS;
            updateTimerDisplay();

            if (getStoredGeminiApiKey() && firebaseInitializedSuccessfully) {
                console.log("Timer hidden. Refreshing main Gemini insight.");
                handleGetGeminiInsight(false);
            } else if (lastLongInsightText && lastLongInsightText.trim() !== "") {
                console.log("Timer hidden. Restoring last long Gemini insight.");
                dom.geminiInsightResultDiv.textContent = lastLongInsightText;
                toggleListenButton(true, lastLongInsightText);
            } else {
                const defaultMsg = 'Enter your API Key above to get started...';
                dom.geminiInsightResultDiv.textContent = defaultMsg;
                lastLongInsightText = defaultMsg;
                toggleListenButton(false);
            }
        };

        // --- Gemini AI & TTS Insight Functions ---
        function getStoredGeminiApiKey() { return localStorage.getItem(GEMINI_API_KEY_STORAGE_KEY); }
        function storeGeminiApiKey(apiKey) { localStorage.setItem(GEMINI_API_KEY_STORAGE_KEY, apiKey); }

        function isValidInsightText(text) { if (!text) return false; const lowerText = text.toLowerCase(); const placeholders = [ 'enter your api key', 'please enter your gemini api key', 'api key is stored', 'fetching initial insight', 'conjuring witticisms', 'rethinking...', 'spicy error:', 'api key needed', 'database not connected', 'creative block', 'generating commentary...', 'loading commentary...' ]; return !placeholders.some(p => lowerText.includes(p)); }

        function toggleListenButton(show, insightText = "") { if (!dom.listenToInsightBtn) return; const canListen = show && isValidInsightText(insightText); if (canListen) { dom.listenToInsightBtn.style.display = 'inline-block'; dom.listenToInsightBtn.disabled = isSpeaking; if (!isSpeaking) { dom.listenToInsightBtn.innerHTML = '🔊 Audiable Insight!'; } } else { dom.listenToInsightBtn.style.display = 'none'; if (insightAudio && !insightAudio.paused) { insightAudio.pause(); insightAudio.currentTime = 0; } } }

        function addListenToInsightButton() { if (dom.listenToInsightBtn || !dom.geminiButtonsFlexDiv) return; const button = document.createElement('button'); button.id = 'listenToInsightBtn'; button.innerHTML = '🔊 Listen'; button.classList.add('icon-button', 'secondary'); button.style.marginLeft = '0px'; button.style.display = 'none'; dom.geminiButtonsFlexDiv.appendChild(button); dom.listenToInsightBtn = button; dom.listenToInsightBtn.addEventListener('click', async () => { if (isSpeaking) { if (insightAudio && !insightAudio.paused) { insightAudio.pause(); insightAudio.currentTime = 0; } isSpeaking = false; dom.listenToInsightBtn.innerHTML = '🔊 Listen'; dom.listenToInsightBtn.disabled = false; return; } const textToSpeak = dom.geminiInsightResultDiv.textContent; if (!isValidInsightText(textToSpeak)) { alert("No valid insight available to listen to."); toggleListenButton(false); return; } await speakTextWithGoogleTTS(textToSpeak); }); }

        async function speakTextWithGoogleTTS(textToSpeak) {
            const apiKey = getStoredGeminiApiKey();
            if (!apiKey) { alert("API Key needed for Text-to-Speech. Please enter it in the AI Insights section."); toggleListenButton(false); return; }
            if (isSpeaking) return;
            isSpeaking = true;
            dom.listenToInsightBtn.disabled = true;
            dom.listenToInsightBtn.innerHTML = '🔊 Loading...';

            const voices = [ { name: "en-US-Chirp3-HD-Achernar", gender: "FEMALE" },
                            { name: "en-US-Chirp3-HD-algenib", gender: "MALE" },
            { name: "en-US-Chirp3-HD-Aoede", gender: "FAMALE" }
     ];
            const selectedVoice = voices[Math.floor(Math.random() * voices.length)];
            const TTS_API_URL = `https://texttospeech.googleapis.com/v1/text:synthesize?key=${apiKey}`;

            try {
                const response = await fetch(TTS_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        input: { text: textToSpeak },
                        voice: { languageCode: 'en-US', name: selectedVoice.name },
                        audioConfig: { audioEncoding: 'MP3', speakingRate: 1.1, pitch: 0 }
                    })
                });
                if (!response.ok) { const errorData = await response.json(); console.error('Google TTS API Error:', errorData); let errorMessage = `TTS API Error (${response.status}): ${errorData?.error?.message || response.statusText}.`; errorMessage += " Ensure Cloud Text-to-Speech API is enabled for your key and project."; throw new Error(errorMessage); }
                const data = await response.json();
                if (data.audioContent) {
                    const audioBytes = Uint8Array.from(atob(data.audioContent), c => c.charCodeAt(0));
                    const audioBlob = new Blob([audioBytes], { type: 'audio/mp3' });
                    const audioUrl = URL.createObjectURL(audioBlob);
                    if (!insightAudio) insightAudio = new Audio();
                    insightAudio.src = audioUrl;
                    dom.listenToInsightBtn.innerHTML = '🔊 Playing...';
                    await insightAudio.play();
                    insightAudio.onended = () => { isSpeaking = false; dom.listenToInsightBtn.innerHTML = '🔊 Listen'; dom.listenToInsightBtn.disabled = false; toggleListenButton(true, textToSpeak); URL.revokeObjectURL(audioUrl); };
                    insightAudio.onerror = (e) => { console.error("Audio playback error object:", e); isSpeaking = false; dom.listenToInsightBtn.innerHTML = '🔊 Listen (Err)'; dom.listenToInsightBtn.disabled = false; toggleListenButton(true, textToSpeak); URL.revokeObjectURL(audioUrl); alert("Error during audio playback. Check console."); };
                } else { throw new Error("No audio content received from TTS API."); }
            } catch (error) { console.error('Error with TTS:', error); alert(`Could not play insight: ${error.message}`); isSpeaking = false; dom.listenToInsightBtn.innerHTML = '🔊 Listen'; dom.listenToInsightBtn.disabled = false; toggleListenButton(true, textToSpeak); }
        }

        async function synthesizeTimerCommentarySpeech(textToSpeak) {
            const apiKey = getStoredGeminiApiKey();
            if (!apiKey) { console.error("TTS Internal: API Key missing."); return null; }
            if (!textToSpeak || textToSpeak.trim() === "") { console.error("TTS Internal: No text to speak."); return null;}

            const commentatorVoices = [ { name: "en-US-Chirp3-HD-Achernar", gender: "FEMALE" },
                                       { name: "en-US-Chirp3-HD-algenib", gender: "MALE" },
                                       { name: "en-US-Chirp3-HD-Aoede", gender: "FEMALE" }];
            const selectedVoice = commentatorVoices[Math.floor(Math.random() * commentatorVoices.length)];
            const TTS_API_URL = `https://texttospeech.googleapis.com/v1/text:synthesize?key=${apiKey}`;

            try {
                const response = await fetch(TTS_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        input: { text: textToSpeak },
                        voice: { languageCode: 'en-US', name: selectedVoice.name },
                        audioConfig: { audioEncoding: 'MP3', speakingRate: 1.1, pitch: 0 }
                    })
                });
                if (!response.ok) { const errorData = await response.json(); console.error('Google TTS API Error (Timer):', errorData); throw new Error(`TTS API Error (${response.status}): ${errorData?.error?.message || response.statusText}`); }
                const data = await response.json();
                if (data.audioContent) {
                    const audioBytes = Uint8Array.from(atob(data.audioContent), c => c.charCodeAt(0));
                    const audioBlob = new Blob([audioBytes], { type: 'audio/mp3' });
                    return URL.createObjectURL(audioBlob);
                } else {
                    throw new Error("No audio content received from TTS API (Timer).");
                }
            } catch (error) {
                console.error('Error with Timer TTS:', error);
                return null;
            }
        }


        function updateApiKeySectionVisibility() { const storedKey = getStoredGeminiApiKey(); if (storedKey) { dom.geminiApiKeyInputGroup.classList.add('hidden'); dom.geminiApiKeyStoredInfo.classList.remove('hidden'); dom.getGeminiInsightBtn.disabled = !firebaseInitializedSuccessfully; } else { dom.geminiApiKeyInputGroup.classList.remove('hidden'); dom.geminiApiKeyStoredInfo.classList.add('hidden'); dom.geminiApiKeyInput.value = ''; dom.getGeminiInsightBtn.disabled = true; dom.geminiInsightResultDiv.textContent = 'Please enter your Gemini API Key to enable AI insights.'; lastLongInsightText = dom.geminiInsightResultDiv.textContent; toggleListenButton(false); } }

        async function fetchFromGemini(apiKey, promptText, model = "gemini-2.0-flash", generationConfigOverrides = {}) {
            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
            const defaultConfig = {
                temperature: 0.9,
                topK: 40,
                topP: 0.95,
                maxOutputTokens: 300
            };
            const finalConfig = { ...defaultConfig, ...generationConfigOverrides };

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: promptText }] }],
                        generationConfig: finalConfig
                    }),
                });
                if (!response.ok) { const errorData = await response.json(); console.error('Gemini API Error:', errorData); throw new Error(`Gemini API Error (${response.status}): ${errorData?.error?.message || response.statusText}. Ensure API is enabled and model name is correct.`); }
                const data = await response.json();
                if (data.candidates && data.candidates[0]?.content?.parts[0]?.text) { return data.candidates[0].content.parts[0].text; }
                else if (data.promptFeedback?.blockReason) { throw new Error(`Content blocked: ${data.promptFeedback.blockReason}. ${data.promptFeedback.blockReasonMessage || ''}`); }
                throw new Error('Could not extract response from Gemini.');
            } catch (error) { console.error('Error fetching from Gemini:', error); throw error; }
        }

        function saveImageCache() {
            // If the cache is empty, just ensure it's cleared from localStorage.
            if (geminiImageCache.length === 0) {
                localStorage.removeItem(GEMINI_IMAGE_CACHE_KEY);
                return;
            }

            // Create a mutable copy to attempt saving.
            let cacheToSave = [...geminiImageCache];

            // Try to save, and if it fails due to quota, reduce and retry.
            while (cacheToSave.length > 0) {
                try {
                    // Attempt to save the current state of the cache copy.
                    localStorage.setItem(GEMINI_IMAGE_CACHE_KEY, JSON.stringify(cacheToSave));

                    // If successful, update the global cache to match what was saved.
                    // This is important because the global cache might have more items than what could be saved.
                    if (geminiImageCache.length !== cacheToSave.length) {
                         console.log(`Successfully saved a reduced image cache of ${cacheToSave.length} items.`);
                         geminiImageCache = cacheToSave;
                         window.geminiImageCache = geminiImageCache; // Update exposed cache
                    }
                    return; // Exit the function successfully
                } catch (e) {
                    // Check if the error is a quota error.
                    if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED' || (e.message && e.message.toLowerCase().includes('quota'))) {
                        console.warn(`Quota exceeded when trying to save ${cacheToSave.length} images. Removing oldest image and retrying.`);
                        // Remove the oldest item (from the end of the array) and try again.
                        cacheToSave.pop();
                    } else {
                        // If it's a different error, log it and stop.
                        console.error("Failed to save image cache due to an unexpected error:", e);
                        return; // Exit on other errors
                    }
                }
            }

            // If the loop finishes, it means we couldn't even save a single image.
            console.warn("Could not save any images to cache. Clearing cache.");
            localStorage.removeItem(GEMINI_IMAGE_CACHE_KEY);
            geminiImageCache = []; // Clear the in-memory cache as well
            window.geminiImageCache = geminiImageCache;
        }

        function loadImageCache() {
            const cached = localStorage.getItem(GEMINI_IMAGE_CACHE_KEY);
            if (cached) {
                const parsedCache = JSON.parse(cached);
                geminiImageCache.length = 0; // Clear array in place
                geminiImageCache.push(...parsedCache); // Add new items
                console.log(`Loaded ${geminiImageCache.length} images from cache.`);
            }
        }


        async function fetchImageFromImagen(apiKey, promptText) {
            const model = "imagen-4.0-generate-001";
            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:predict?key=${apiKey}`;

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        "instances": [
                          {
                            "prompt": promptText
                          }
                        ],
                        "parameters": {
                          "sampleCount": 1
                        }
                      }),
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Imagen API Error:', errorData);
                    throw new Error(`Imagen API Error (${response.status}): ${errorData?.error?.message || response.statusText}`);
                }

                const data = await response.json();
                console.log("Full Imagen Response for debugging:", data); // For debugging

                if (data.predictions && data.predictions.length > 0 && data.predictions[0].bytesBase64Encoded) {
                    const imageData = data.predictions[0].bytesBase64Encoded;
                    geminiImageCache.unshift(imageData);
                    if (geminiImageCache.length > 5) {
                        geminiImageCache.pop();
                    }
                    saveImageCache();
                    return imageData;
                }

                console.warn("Imagen API returned a response without image data.");
                return null;

            } catch (error) {
                console.error('Error fetching image from Imagen:', error);
                throw error;
            }
        }

        function prepareDataForGemini() { 
            const currentGameName = games.find(g => g.id === currentGameId)?.name || 'This Game';
            let dataSummary = `${currentGameName} Game Stats:\n`;
            if (players.length === 0 && firebaseInitializedSuccessfully) return dataSummary + "No players yet. It's a lonely game so far!\n";
            if (!firebaseInitializedSuccessfully) return dataSummary + "Database not connected. Cannot provide stats.\n";
            dataSummary += `Players: ${players.map(p => utils.sanitizeHTML(p.name)).join(', ')}\n\n`;
            const totalWinsByPlayer = players.map(p => ({ name: utils.sanitizeHTML(p.name), count: wins.filter(w => w.playerId === p.id).length })).sort((a, b) => b.count - a.count);
            dataSummary += `Leaderboard for ${currentGameName} (All Time):\n`;
            if (totalWinsByPlayer.some(p => p.count > 0)) { totalWinsByPlayer.forEach(p => dataSummary += `- ${p.name}: ${utils.pluralize(p.count, 'win')}\n`); }
            else { dataSummary += `- No one has won yet in ${currentGameName}! The trophy is still up for grabs!\n`; }
            dataSummary += "\n";
            const { start: currentStart, end: currentEnd } = utils.getPeriodRange(currentDashboardPeriod, currentDisplayDate);
            const currentPeriodWinsData = getWinsForPeriodLocal(currentDashboardPeriod, currentDisplayDate);
            let currentPeriodTitle = '';
            switch (currentDashboardPeriod) {
                case 'week': currentPeriodTitle = `This Week (${currentStart.toLocaleDateString()} - ${currentEnd.toLocaleDateString()})`; break;
                case 'month': currentPeriodTitle = `This Month (${utils.getFullMonthName(currentDisplayDate.getMonth())} ${currentDisplayDate.getFullYear()})`; break;
                case 'year': currentPeriodTitle = `This Year (${currentDisplayDate.getFullYear()})`; break;
            }
            dataSummary += `Performance - ${currentPeriodTitle}:\n`;
            if (currentPeriodWinsData.length > 0) { const winsByPlayer = players.reduce((acc, p) => ({...acc, [p.id]: { name: utils.sanitizeHTML(p.name), count: 0 }}), {}); currentPeriodWinsData.forEach(w => { if (winsByPlayer[w.playerId]) winsByPlayer[w.playerId].count++; }); Object.values(winsByPlayer).filter(p=>p.count > 0).sort((a,b) => b.count - a.count).forEach(p => dataSummary += `- ${p.name}: ${utils.pluralize(p.count, 'win')}\n`); } else { dataSummary += `- No wins recorded in this period. Is everyone on vacation?\n`; } dataSummary += "\n"; let prevDate = new Date(currentDisplayDate); let prevPeriodTitle = ""; if (currentDashboardPeriod === 'week') { prevDate.setDate(prevDate.getDate() - 7); prevPeriodTitle = "Last Week"; } else if (currentDashboardPeriod === 'month') { prevDate.setMonth(prevDate.getMonth() - 1); prevPeriodTitle = "Last Month"; } else if (currentDashboardPeriod === 'year') { prevDate.setFullYear(prevDate.getFullYear() - 1); prevPeriodTitle = "Last Year"; } if (prevPeriodTitle) { const prevPeriodWinsData = getWinsForPeriodLocal(currentDashboardPeriod, prevDate); dataSummary += `For Comparison - ${prevPeriodTitle}:\n`; if (prevPeriodWinsData.length > 0) { const winsByPlayerPrev = players.reduce((acc, p) => ({...acc, [p.id]: { name: utils.sanitizeHTML(p.name), count: 0 }}), {}); prevPeriodWinsData.forEach(w => { if (winsByPlayerPrev[w.playerId]) winsByPlayerPrev[w.playerId].count++; }); Object.values(winsByPlayerPrev).filter(p=>p.count > 0).sort((a,b) => b.count - a.count).forEach(p => dataSummary += `- ${p.name}: ${utils.pluralize(p.count, 'win')}\n`); } else { dataSummary += `- No wins recorded in ${prevPeriodTitle}. A fresh start perhaps!\n`; } dataSummary += "\n"; } const threeDaysAgo = new Date(); threeDaysAgo.setDate(threeDaysAgo.getDate() - 2); threeDaysAgo.setHours(0,0,0,0); const recentWinsRaw = wins.filter(w => w.timestamp?.toDate() >= threeDaysAgo); if(recentWinsRaw.length > 0){ dataSummary += "Hot Streaks (Last 3 Days including Today):\n"; const recentSummary = recentWinsRaw.reduce((acc,w) => { const pName = players.find(p=>p.id === w.playerId)?.name || "An Unknown Force"; acc[utils.sanitizeHTML(pName)] = (acc[utils.sanitizeHTML(pName)] || 0) + 1; return acc; }, {}); Object.entries(recentSummary).sort(([,a],[,b]) => b-a).forEach(([name, count]) => dataSummary += `- ${name} won ${utils.pluralize(count, 'time')}\n`); } else { dataSummary += "Recent Activity: A bit quiet lately. Time to shuffle the tiles!\n" } return dataSummary;
        }

        async function handleGetGeminiInsight(isButtonPress = true) {
            const apiKey = dom.geminiApiKeyInput.value.trim() || getStoredGeminiApiKey();
            if (!apiKey) {
                const msg = `<span style="color:red;">API Key needed! Please enter it above.</span>`;
                dom.geminiInsightResultDiv.innerHTML = msg;
                lastLongInsightText = msg;
                updateApiKeySectionVisibility();
                toggleListenButton(false);
                return;
            }
            if (!firebaseInitializedSuccessfully) {
                const msg = `<span style="color:orange;">Database not connected. AI insights need game data.</span>`;
                dom.geminiInsightResultDiv.innerHTML = msg;
                lastLongInsightText = msg;
                toggleListenButton(false);
                return;
            }

            if (isButtonPress || !getStoredGeminiApiKey()) storeGeminiApiKey(apiKey);
            updateApiKeySectionVisibility();
            dom.getGeminiInsightBtn.disabled = true;
            dom.getGeminiInsightBtn.textContent = 'Rethinking... 😂';
            if (isSpeaking && insightAudio) { insightAudio.pause(); insightAudio.currentTime = 0; isSpeaking = false; }
            toggleListenButton(false);

            dom.geminiImage.style.display = 'none';
            dom.geminiImage.src = '';

            const loadingMsg = isButtonPress ? 'Conjuring witticisms... 🧠' : 'Fetching initial insight... 🧠';
            dom.geminiInsightResultDiv.innerHTML = loadingMsg;

            const gameDataSummary = prepareDataForGemini();

            // Fetch text insight
            const textPromise = (async () => {
                const promptForLongInsight = `
            **Primary Directive: Your ONLY output will be 1 sentence of text. No preambles, no explanations, no apologies, nothing but the commentary itself.**
You are a witty, observant, and slightly sarcastic game commentator with a knack for comedic timing. Your audience loves your playful jabs and insightful, humorous takes. Your commentary should sound like a friend chatting excitedly, sometimes conspiratorially, with another friend about the game.

Based on the game stats below for the game "${games.find(g => g.id === currentGameId)?.name || 'the game'}", provide a funny and insightful commentary.
CRITITAL: if the game is Rummikub, use Rummi only instead of the entire RUMMIKUB word. For other games, you can use their full name.

**Your Comedic Style & Delivery (for Text Generation):**
*   Natural & Conversational: Write like you're speaking directly to a friend. Use informal language, contractions, and a relaxed tone. Think stand-up comedian observing the game.
*   Punctuation for Nuance & Pacing:
    *   Pauses: Use ellipses (...) strategically for comedic effect, to indicate a thought trailing off, or a moment of mock disbelief. Short, punchy sentences or even well-placed sentence fragments can also create natural pauses.
    *   Excitement & Exclamation: Don't be shy with exclamation points! If a point is particularly surprising or funny, let it show! Occasionally, you might even use ALL CAPS for a *single* word or very short phrase if you want to convey shouting or extreme emphasis (e.g., "NO WAY!").
    *   Wondering & Sarcasm: Use question marks to pose rhetorical questions or express mock wonder. Sarcasm can be conveyed through word choice and by stating something that's clearly a bit absurd given the context (e.g., "Oh, Player X is just being *generous* this month with those scores, right?").
*   Show, Don't Just Tell Emotion:
    *   Instead of writing "(laughs)", craft a line that is genuinely funny or highlights an absurd situation that would make someone chuckle. For example, "Player Y's tile rack must be looking like a abstract art project with those moves... or maybe it's avant-garde?"
    *   For excitement, use vivid adjectives and verbs.
*   Playful Teasing & Comparisons:
    *   Gently tease players. Who's dominating this month vs. last? Who's on an undeniable hot streak (or a hilarious cold one)? Is anyone surprisingly ahead overall, or perhaps their recent performance is... let's say, *unexpected*?
    *   Celebrate or gently mock streaks and the competitive spirit.
    *   Mention their scores, who is leading and by how many points, and also who is the runner up and how many points to catch up to the top player?
    *   Use statistics, like this player needs to win 2 games a night to catch up to the top player by certain date.
    *   If someone has won today, definitely add some comments about it specially if they're catching up to someone else or 2 players are too close to each other.
*   Humor Techniques: Employ puns (if they're clever!), witty observations, and a generally amusing and light-hearted tone.
*   Sparse Data Joke: If data is sparse, lean into it: "Well, the scoreboard's looking a bit minimalist this period. Are we going for a 'less is more' vibe, or did someone hide the good tiles?"

**Content Specifics:**
*   Ensure your commentary flows well, even when transitioning between players. No bullet points in the final output.
*   **Mountain Biking Banter (Conditional):** For players JB and Mike (both guys), who enjoy mountain biking, feel free to randomly sprinkle in a funny, short mountain biking-related quip or comparison if it fits the commentary. Sometimes include it, sometimes don't – keep it surprising! (e.g., "Looks like JB's navigating the leaderboard like a technical downhill course this month!" or "Mike's scores are climbing steadier than a granny gear on a steep ascent! Meanwhile...")
*   **Mention Every Player:** Critically, every player active in the \`gameDataSummary\` must be mentioned in your commentary, even if it's a brief, witty aside.
*   Use overall stats or trends but focus on the stats mainly display like mfor this month, week, or year, but be funny and sarcastic about it that are genuinly funny.
*   Info about players: They've known each other for a good part of 5 years, live nearby. Jovany and Rosie (Mexican, 2 kids), Beatriz and Mike (Filipino-American, 2 kids). Neighbors: one nosy family, another nosy neighbor, mean HOA president. Ongoing drama with a neighbor (domestic violence, mental health - make fun LIGHTLY and CAREFULLY, if at all, focusing on absurdity rather than malice). Main players do outings (dinners, museums, parks, camping), discuss family issues (Rosie & Beatriz). Use this info LIGHTLY, RANDOMLY, and FUNNILY.
*   Focus on the gameDataSummary provided.

**Examples (Illustrating Tone & Punctuation for Nuance for LONGER insights):**
*   "Okay, so Player X is CLEARLY channeling some kind of Rummikub wizard this week... leaving everyone else wondering if their tiles are just decorative. And Player Y? Their lucky streak from last month seems to have... well, taken an extended vacation, shall we say?"
*   "Player Z is playing the long game, folks! Sneaking up that overall leaderboard while everyone's distracted by the weekly fireworks. Clever, Z, very clever... or just very patient?"

**Game Data:**
${gameDataSummary}
`;
                try {
                    const insight = await fetchFromGemini(apiKey, promptForLongInsight, "gemini-2.0-flash");
                    const finalInsightText = insight.trim();
                    dom.geminiInsightResultDiv.textContent = finalInsightText;
                    lastLongInsightText = finalInsightText;
                    toggleListenButton(true, finalInsightText);
                } catch (error) {
                    const errorMsg = `<span style="color:red;">Spicy Error: ${utils.sanitizeHTML(error.message)}</span> <br>Maybe the AI is on a coffee break? Check API key & console.`;
                    dom.geminiInsightResultDiv.innerHTML = errorMsg;
                    lastLongInsightText = errorMsg;
                    toggleListenButton(false);
                }
            })();

            const shouldFetchNewImage = isButtonPress || Math.random() < 0.2 || geminiImageCache.length === 0;

            const imagePromise = (async () => {
                if (shouldFetchNewImage) {
                    const imagePrompt = getAiImagePromptText(gameDataSummary);
                    dom.geminiImageContainer.innerHTML = '<p class="no-data">🖼️ Generating new image...</p>';
                    try {
                        const imageData = await fetchImageFromImagen(apiKey, imagePrompt);
                        if (imageData) {
                            dom.geminiImage.src = `data:image/png;base64,${imageData}`;
                        } else {
                           throw new Error("No image data returned from API.");
                        }
                    } catch (error) {
                        console.error("Image generation failed:", error);
                        dom.geminiImageContainer.innerHTML = `<p class="error-message">Image generation failed: ${utils.sanitizeHTML(error.message)}</p>`;
                        dom.geminiImage.style.display = 'none';
                        return; // Stop further execution in this block
                    }
                } else {
                    console.log("Using cached image for insight section.");
                    dom.geminiImage.src = `data:image/png;base64,${geminiImageCache[0]}`;
                }

                dom.geminiImage.style.display = 'block';
                dom.geminiImageContainer.innerHTML = '';
                dom.geminiImageContainer.appendChild(dom.geminiImage);
            })();

            try {
                await Promise.all([textPromise, imagePromise]);
            } catch (error) {
                console.error("Error during parallel fetch:", error);
            } finally {
                dom.getGeminiInsightBtn.disabled = false;
                dom.getGeminiInsightBtn.textContent = 'Get New Funny Insight 😂';
            }
        }

        function getAiTimerCommentaryPromptText(gameDataSummary) {
            const currentGameName = games.find(g => g.id === currentGameId)?.name || 'the game';
            return `
**Primary Directive: Your ONLY output will be ONE (1) single line of text. No preambles, no explanations, no apologies, nothing but the commentary itself.**
**Secondary Directive: Never prefrence one single player. Randomize the punch line and the players. It's not known who the next player is, so never say is a specific player's turn. Use jokes from Grabriel Iglesias, Kevin Hart, or Dave Chappelle.**
You are a witty, observant, and heavily sarcastic and heavy humoristic game commentator for a timer with a knack for short, punchy lines. Your audience loves your playful jabs and insightful, humorous takes delivered quickly.
Based on the game stats below for "${currentGameName}", provide a funny and insightful commentary. Also, make more generic punch lines to point out that it's the next player's turn.
CRITICAL: Your response MUST be 7-12 words ONLY. This is for a quick audio alert. This is for text-to-speech google API for Chirp3-HD voices so format it so it sounds natural with nuances and expressions.
CRITICAL: DO NOT always mentioned the top players with wins, also focus on those with low scores. Mix it up. If the game is Rummikub, use "Rummi", NEVER use the full word rummikub.
CRITICAL: JOVANY is said "Jovaaany" so spell it like that with emphasis in VAh. Mike is said Mike. Beatriz is Beatriz. Rosie is spell the same, Rosie.

Your Comedic Style & Delivery (for Text Generation):
- Punctuation for Pacing: Use ellipses (...), exclamation points (!) sparingly.
- Humor: Witty observations, playful but also hard teasing, scores or trends, or sarcastic comments. Mock heavily.
- Player Mentions: If possible, briefly allude to a player's performance or not performing with numeric data.
- Mountain Biking Banter (Conditional, for Jovany/Mike): "Jovanys climbing again!" or "Mike's on a roll... downhill?"
- Focus: Recent stats (current period, hot streaks from Game Data).
- If data is sparse (from Game Data): "Scoreboard's quiet... too quiet." or "Anyone playing today?"

Examples (Illustrating 10-15 word count and tone):
CRITICAL: Do not always use the top scorers, you can use also low scorers. Audience likes a good chuckle so mock every just alike.
"Wow, [PlayerX] is UNSTOPPABLE today!"
"[PlayerY]... a tactical retreat, perhaps?"
"[PlayerY] come on man. Try harder just like you try biking!"
"[PlayerX] still pedaling to victory!"
"[playerY] cooking up another win!"
"Everyone's so quiet... planning something?"
"Next up! Who's feeling lucky?"

CRITICAL: You can use other punch items like the ones below mixed with player stats mentioned earlier in ONE SINGLE PUNCH LINE:
"Hey hey, don't be sad, we know who will win"
"who will be the winner this time? You know who!"

**FINAL, ABSOLUTE INSTRUCTION: Your entire response MUST be just ONE single line of commentary. Nothing before it, nothing after it. Just the line.**

Game Data:
${gameDataSummary}
`;
        }

        function getAiImagePromptText(gameDataSummary) {
            const playerGenders = {
                "Mike": "male",
                "Jovany": "male",
                "Rosie": "female",
                "Beatriz": "female"
            };

            const styles = ["Pixar animation style", "hyperrealistic", "abstract", "impressionistic painting", "surrealist", "cyberpunk", "steampunk", "minimalist line art", "vibrant cartoon", "DC Comics style", "anime", "watercolour painting", "claymation"];
            const themes = [
                {
                    name: "a grand royal court",
                    winner: "a magnificent monarch on a throne",
                    loser: "a lowly court jester being laughed at",
                    middle: ["a noble knight", "a cunning advisor", "a wealthy merchant"]
                },
                {
                    name: "a space race to a new planet",
                    winner: "an astronaut planting a flag on the new world",
                    loser: "an astronaut whose ship has comically crash-landed",
                    middle: ["an astronaut floating in orbit", "a scientist at mission control", "an alien spectator"]
                },
                {
                    name: "a magical wizard duel",
                    winner: "a powerful arch-mage casting a spectacular spell",
                    loser: "an apprentice whose spell has backfired hilariously",
                    middle: ["a sorcerer summoning a creature", "a witch brewing a potion", "an enchanted statue"]
                },
                {
                    name: "a cooking competition",
                    winner: "a master chef presenting a perfect dish to judges",
                    loser: "a clumsy cook who has made a huge mess",
                    middle: ["a focused sous-chef chopping vegetables", "a baker decorating a cake", "a food critic tasting a dish"]
                },
                {
                    name: "a mountain expedition",
                    winner: "a climber at the summit, enjoying the view",
                    loser: "a climber tangled in their own ropes at the base",
                    middle: ["a climber halfway up the cliff face", "a sherpa guiding the way", "a hiker resting by a fire"]
                },
                {
                    name: "a pirate treasure hunt",
                    winner: "the pirate captain opening a chest overflowing with gold",
                    loser: "a swabber being chased by a crab",
                    middle: ["the first mate reading a map", "a lookout in the crow's nest", "a parrot on a shoulder"]
                }
            ];

            const randomStyle = styles[Math.floor(Math.random() * styles.length)];
            const randomTheme = themes[Math.floor(Math.random() * themes.length)];

            const rankedPlayers = players
                .map(p => {
                    const name = p.name;
                    let gender = "unknown";
                    // Find the canonical name (e.g., "Mike" for "Mikey") to get the gender
                    const canonicalName = Object.keys(playerGenders).find(key => name.toLowerCase().includes(key.toLowerCase()));
                    if (canonicalName) {
                        gender = playerGenders[canonicalName];
                    }
                    return {
                        name: name,
                        gender: gender,
                        count: wins.filter(w => w.playerId === p.id).length
                    };
                })
                .sort((a, b) => b.count - a.count);

            if (rankedPlayers.length === 0) {
                return `A lonely, empty scene in a ${randomStyle}. The game has no players yet.`;
            }

            let prompt = `Create a masterpiece image in a ${randomStyle}. The scene is ${randomTheme.name}, visualizing the rankings of exactly ${rankedPlayers.length} players. The characters must accurately reflect their specified gender and relative rankings.\n\n`;

            const winner = rankedPlayers[0];
            prompt += `- The winner, ${winner.name} (${winner.gender}), is depicted as ${randomTheme.winner}.\n`;

            if (rankedPlayers.length > 1) {
                const loser = rankedPlayers[rankedPlayers.length - 1];
                prompt += `- The player in last place, ${loser.name} (${loser.gender}), is depicted as ${randomTheme.loser}.\n`;
            }

            if (rankedPlayers.length > 2) {
                const middlePlayers = rankedPlayers.slice(1, -1);
                middlePlayers.forEach((player, index) => {
                    const role = randomTheme.middle[index % randomTheme.middle.length];
                    prompt += `- ${player.name} (${player.gender}) is in the middle, depicted as ${role}.\n`;
                });
            }

            prompt += `\nThe names of the players should be subtly integrated into the scene. The overall mood is funny and comical. Intricate details, 4K resolution.`;

            console.log("Generated Image Prompt:", prompt);
            return prompt;
        }

        async function preloadAiTimerCommentary() {
            if (isLoadingAiCommentary || !firebaseInitializedSuccessfully) return;
            const apiKey = getStoredGeminiApiKey();
            if (!apiKey) { console.warn("AI Timer: API Key missing for preloading."); return; }

            isLoadingAiCommentary = true;
            console.log("Preloading AI timer commentary...");
            try {
                const gameDataSummary = prepareDataForGemini();
                const promptText = getAiTimerCommentaryPromptText(gameDataSummary);
                const commentaryText = await fetchFromGemini(apiKey, promptText, "gemini-2.0-flash", { maxOutputTokens: 100 });

                if (commentaryText && commentaryText.trim() !== "") {
                    currentTimerAiCommentaryText = commentaryText.trim();
                    console.log("AI Timer Text (preload):", currentTimerAiCommentaryText);

                    if (preloadedAiCommentaryUrl) {
                        URL.revokeObjectURL(preloadedAiCommentaryUrl);
                        preloadedAiCommentaryUrl = null;
                    }

                    preloadedAiCommentaryUrl = await synthesizeTimerCommentarySpeech(currentTimerAiCommentaryText);
                    if(preloadedAiCommentaryUrl) console.log("AI Timer Audio URL preloaded.");
                    else console.warn("AI Timer Audio preloading failed (no URL).");
                } else {
                    console.warn("AI Timer: Gemini returned empty text for commentary.");
                    currentTimerAiCommentaryText = "";
                }
            } catch (error) {
                console.error("Error preloading AI timer commentary:", error);
                if (preloadedAiCommentaryUrl) {
                    URL.revokeObjectURL(preloadedAiCommentaryUrl);
                }
                preloadedAiCommentaryUrl = null;
                currentTimerAiCommentaryText = "";
            } finally {
                isLoadingAiCommentary = false;
            }
        }

        async function fetchAndPlayAiTimerCommentary(isTimerEndEvent = false) {
            if (!firebaseInitializedSuccessfully || !getStoredGeminiApiKey()) {
                 if (isTimerEndEvent) playWebAudioSound('default');
                return;
            }

            const apiKey = getStoredGeminiApiKey();
            isLoadingAiCommentary = true;

            try {
                const gameDataSummary = prepareDataForGemini();
                const promptText = getAiTimerCommentaryPromptText(gameDataSummary);
                const commentaryText = await fetchFromGemini(apiKey, promptText, "gemini-2.0-flash", { maxOutputTokens: 100 });

                if (commentaryText && commentaryText.trim() !== "") {
                    currentTimerAiCommentaryText = commentaryText.trim();
                    console.log("AI Timer Text (fetch/play):", currentTimerAiCommentaryText);
                    const audioUrl = await synthesizeTimerCommentarySpeech(currentTimerAiCommentaryText);
                    if (audioUrl) {
                        if (dom.timerAudio.src && dom.timerAudio.src.startsWith('blob:')) {
                            URL.revokeObjectURL(dom.timerAudio.src);
                        }
                        dom.timerAudio.src = audioUrl;
                        dom.timerAudio.play().catch(e => {
                            console.error("Failed to play AI commentary on demand via <audio> element. Falling back.", e);
                            if (isTimerEndEvent) playWebAudioSound('default');
                        });
                        dom.timerAudio.onended = () => {
                            URL.revokeObjectURL(audioUrl);
                            dom.timerAudio.onended = null;
                        };
                    } else {
                         throw new Error("Synthesize speech returned no URL.");
                    }
                } else {
                    console.warn("AI Timer: Gemini returned empty text. Playing fallback if timer end.");
                    if (isTimerEndEvent) playWebAudioSound('default');
                }
            } catch (error) {
                console.error("Error fetching and playing AI timer commentary:", error);
                if (isTimerEndEvent) playWebAudioSound('default');
            } finally {
                isLoadingAiCommentary = false;
                if (!isTimerEndEvent || (currentActiveAudioPreferenceId !== AI_COMMENTATOR_ID && currentActiveAudioPreferenceId !== RANDOM_MIX_AUDIO_ID)) {
                     currentTimerAiCommentaryText = ""; 
                }
            }
        }


        // --- Event Listeners ---
        dom.togglePlayerManagementBtn.addEventListener('click', () => { dom.playerManagementSection.classList.toggle('hidden'); const i = dom.playerManagementSection.classList.contains('hidden'); dom.togglePlayerManagementBtn.textContent = i ? '⚙️ Manage' : '🔽 Close'; });
        dom.gameSelector.addEventListener('change', handleGameChange);
        dom.addPlayerBtn.addEventListener('click', () => addPlayer(dom.newPlayerNameInput.value));
        dom.newPlayerNameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') { e.preventDefault(); addPlayer(dom.newPlayerNameInput.value); } dom.addPlayerError.textContent = ""; });
        dom.playerListManagementUl.addEventListener('click', (e) => { const t = e.target; const pE = t.closest('.player-management-entry'); if (!pE) return; const pId = pE.dataset.playerId; if (t.classList.contains('delete-player-btn')) { deletePlayer(pId); } else if (t.classList.contains('rename-btn')) { dom.playerListManagementUl.querySelectorAll('.rename-controls:not(.hidden)').forEach(c => { const en = c.closest('.player-management-entry'); if (en && en !== pE) { en.querySelector('.rename-controls').classList.add('hidden'); en.querySelector('.player-name-display').classList.remove('hidden'); en.querySelector('.action-buttons').classList.remove('hidden'); } }); pE.querySelector('.player-name-display').classList.add('hidden'); pE.querySelector('.action-buttons').classList.add('hidden'); const rC = pE.querySelector('.rename-controls'); rC.classList.remove('hidden'); rC.querySelector('.rename-input').focus(); } else if (t.classList.contains('save-rename-btn')) { renamePlayer(pId, pE.querySelector('.rename-input').value); } else if (t.classList.contains('cancel-rename-btn')) { pE.querySelector('.rename-input').value = pE.querySelector('.player-name-display').textContent; pE.querySelector('.rename-controls').classList.add('hidden'); pE.querySelector('.player-name-display').classList.remove('hidden'); pE.querySelector('.action-buttons').classList.remove('hidden'); } });
        dom.playerListManagementUl.addEventListener('keypress', (e) => { if (e.key === 'Enter' && e.target.classList.contains('rename-input')) { e.preventDefault(); renamePlayer(e.target.closest('.player-management-entry').dataset.playerId, e.target.value); } });
        dom.scoreTrackingListUl.addEventListener('click', (e) => { if (e.target.classList.contains('add-win-btn') && !e.target.disabled) recordWin(e.target.dataset.playerId); });
        dom.todaysWinsListUl.addEventListener('click', (e) => { if (e.target.classList.contains('delete-win-btn') && !e.target.disabled) { const wL = e.target.closest('li'); if (wL?.dataset.winId) deleteWin(wL.dataset.winId); } });
        dom.dashboardControls.addEventListener('click', (e) => { if (e.target.tagName === 'BUTTON' && e.target.dataset.period) { currentDisplayDate = new Date(); currentDashboardPeriod = e.target.dataset.period; currentView = 'player'; renderDashboard(); if (getStoredGeminiApiKey() && firebaseInitializedSuccessfully) handleGetGeminiInsight(false); } });
        dom.playerViewBtn.addEventListener('click', () => { if (currentView !== 'player') { currentView = 'player'; renderDashboard(); } });
        dom.monthlyViewBtn.addEventListener('click', () => { if (currentView !== 'monthly') { currentView = 'monthly'; renderDashboard(); } });
        dom.prevPeriodBtn.addEventListener('click', () => { if (currentDashboardPeriod === 'week') currentDisplayDate.setDate(currentDisplayDate.getDate() - 7); else if (currentDashboardPeriod === 'month') currentDisplayDate.setMonth(currentDisplayDate.getMonth() - 1); else if (currentDashboardPeriod === 'year') currentDisplayDate.setFullYear(currentDisplayDate.getFullYear() - 1); renderDashboard(); if (getStoredGeminiApiKey() && firebaseInitializedSuccessfully) handleGetGeminiInsight(false); });
        dom.nextPeriodBtn.addEventListener('click', () => { let allowNav = true; const tempDate = new Date(currentDisplayDate); if (currentDashboardPeriod === 'week') tempDate.setDate(tempDate.getDate() + 7); else if (currentDashboardPeriod === 'month') tempDate.setMonth(tempDate.getMonth() + 1); else if (currentDashboardPeriod === 'year') tempDate.setFullYear(tempDate.getFullYear() + 1); const today = new Date(); if (tempDate.getFullYear() > today.getFullYear() || (tempDate.getFullYear() === today.getFullYear() && (currentDashboardPeriod === 'month' ? tempDate.getMonth() > today.getMonth() : false)) || (currentDashboardPeriod === 'week' && tempDate > today) ) { allowNav = false; } if(allowNav) { currentDisplayDate = tempDate; renderDashboard(); if (getStoredGeminiApiKey() && firebaseInitializedSuccessfully) handleGetGeminiInsight(false); } else { dom.nextPeriodBtn.disabled = true;} });
        dom.prevYearBtn.addEventListener('click', () => { currentDisplayDate.setFullYear(currentDisplayDate.getFullYear() - 1); renderDashboard(); if (getStoredGeminiApiKey() && firebaseInitializedSuccessfully) handleGetGeminiInsight(false); });
        dom.nextYearBtn.addEventListener('click', () => { if (currentDisplayDate.getFullYear() + 1 <= new Date().getFullYear()) { currentDisplayDate.setFullYear(currentDisplayDate.getFullYear() + 1); renderDashboard(); if (getStoredGeminiApiKey() && firebaseInitializedSuccessfully) handleGetGeminiInsight(false); } else { dom.nextYearBtn.disabled = true; } });
        dom.toggleTimerBtn.addEventListener('click', () => { if (isTimerVisible) hideTimer(); else showTimer(); });
        dom.hideTimerBtn.addEventListener('click', hideTimer);
        dom.nextTimerBtn.addEventListener('click', handleNextTimerClick);
        
        dom.audioSourceSelect.addEventListener('change', async () => {
            const selectedValue = dom.audioSourceSelect.value;
            dom.audioUrlStatus.innerHTML = ""; // Clear previous status
            if (selectedValue !== "custom_new") {
                await applyAudioChoice(selectedValue);
            } else {
                // When "Add New..." is selected, keep the current status until a new sound is saved
                const activePref = audioPreferences.find(p => p.id === currentActiveAudioPreferenceId) || 
                                   (currentActiveAudioPreferenceId === "default" ? { name: "Default Sound" } : 
                                   (currentActiveAudioPreferenceId === AI_COMMENTATOR_ID ? { name: "✨ AI Comedic Commentator" } : 
                                   (currentActiveAudioPreferenceId === RANDOM_MIX_AUDIO_ID ? { name: "🔀 Random Mix (Sounds + AI)" } : { name: "Default Sound" })));
                dom.audioUrlStatus.innerHTML = `<span class="info">Currently using: ${utils.sanitizeHTML(activePref.name)}</span>`;
            }
            updateCustomAudioUI();
        });

        dom.saveCustomAudioBtn.addEventListener('click', async () => { if (!firebaseInitializedSuccessfully) {alert("Database not connected. Cannot save audio."); return;} const shortName = dom.customAudioShortNameInput.value.trim(); let customUrl = dom.customAudioUrlInput.value.trim(); dom.audioUrlStatus.innerHTML = ""; if (!shortName) { dom.audioUrlStatus.innerHTML = '<span class="error">Short Name is required.</span>'; dom.customAudioShortNameInput.focus(); return; } if (!customUrl) { dom.audioUrlStatus.innerHTML = '<span class="error">Audio URL cannot be empty.</span>'; dom.customAudioUrlInput.focus(); return; } try { new URL(customUrl); } catch (e) { dom.audioUrlStatus.innerHTML = '<span class="error">Invalid URL format.</span>'; dom.customAudioUrlInput.focus(); return; } if (customUrl.includes("dropbox.com/")) { const originalUrl = customUrl; customUrl = customUrl.replace(/([?&])dl=0(&|$)/, '$1dl=1$2'); if (customUrl !== originalUrl) { console.log("Corrected Dropbox URL from:", originalUrl, "to:", customUrl); } } dom.saveCustomAudioBtn.disabled = true; dom.saveCustomAudioBtn.textContent = "Saving..."; const newPref = await saveAudioPreferenceToFirebase(shortName, customUrl); if (newPref) { await applyAudioChoice(newPref.id); populateAudioSourceSelect(); updateCustomAudioUI(); dom.audioUrlStatus.innerHTML = `<span class="success">Sound "${utils.sanitizeHTML(newPref.name)}" saved. </span>` + dom.audioUrlStatus.innerHTML; } else { if (dom.audioSourceSelect.value === "custom_new") { dom.saveCustomAudioBtn.textContent = "Save & Use This Sound"; } } dom.saveCustomAudioBtn.disabled = false; if (dom.audioSourceSelect.value !== "custom_new") { dom.saveCustomAudioBtn.textContent = "Save & Use This Sound"; } });
        dom.removeFavoriteBtn.addEventListener('click', async () => { if (!firebaseInitializedSuccessfully) {alert("Database not connected. Cannot remove audio."); return;} const prefIdToRemove = dom.audioSourceSelect.value; if (prefIdToRemove === "default" || prefIdToRemove === "custom_new" || prefIdToRemove === AI_COMMENTATOR_ID || prefIdToRemove === RANDOM_MIX_AUDIO_ID) return; const prefToRemove = audioPreferences.find(p => p.id === prefIdToRemove); if (!prefToRemove) { console.warn("Could not find preference to remove:", prefIdToRemove); return; } if (!confirm(`Are you sure you want to remove the sound "${utils.sanitizeHTML(prefToRemove.name)}"?`)) { return; } dom.removeFavoriteBtn.disabled = true; dom.removeFavoriteBtn.textContent = "Removing..."; let previousStatus = dom.audioUrlStatus.innerHTML; try { await deleteDoc(doc(db, AUDIO_PREFERENCES_COLLECTION, prefIdToRemove)); audioPreferences = audioPreferences.filter(p => p.id !== prefIdToRemove); let newActiveId = currentActiveAudioPreferenceId; if (currentActiveAudioPreferenceId === prefIdToRemove) { newActiveId = "default"; } await applyAudioChoice(newActiveId); populateAudioSourceSelect(); updateCustomAudioUI(); dom.audioUrlStatus.innerHTML = `<span class="success">Removed "${utils.sanitizeHTML(prefToRemove.name)}". </span>` + dom.audioUrlStatus.innerHTML; } catch (error) { console.error("Error removing audio preference:", error); dom.audioUrlStatus.innerHTML = `<span class="error">Failed to remove sound: ${error.message}</span>` + previousStatus; } finally { dom.removeFavoriteBtn.disabled = false; dom.removeFavoriteBtn.textContent = "Remove Selected Sound"; } });
        dom.geminiApiKeyInput.addEventListener('change', () => { const apiKey = dom.geminiApiKeyInput.value.trim(); if (apiKey) { storeGeminiApiKey(apiKey); updateApiKeySectionVisibility(); if (firebaseInitializedSuccessfully) handleGetGeminiInsight(false); } });
        dom.changeApiKeyBtn.addEventListener('click', () => { localStorage.removeItem(GEMINI_API_KEY_STORAGE_KEY); updateApiKeySectionVisibility(); dom.geminiApiKeyInput.focus(); });
        dom.getGeminiInsightBtn.addEventListener('click', () => handleGetGeminiInsight(true));
        document.addEventListener('visibilitychange', async () => { 
            if (document.visibilityState === 'visible') {
                if (isTimerVisible && !wakeLockSentinel) {
                     await requestWakeLock(); 
                }
                if (isTimerVisible || audioUnlocked) unlockAudioContext();
            }
        });

        // Mexican Train Listeners
        dom.mtStartGameBtn.addEventListener('click', startNewMexicanTrainGame);
        dom.mtSubmitRoundBtn.addEventListener('click', submitMexicanTrainRound);
        dom.mtEndGameBtn.addEventListener('click', endGameEarly);
        dom.mtPlayAgainBtn.addEventListener('click', () => {
            mexicanTrainState = null;
            renderMexicanTrainTracker();
        });
        dom.mexicanTrainTracker.addEventListener('input', (e) => {
            if (e.target.classList.contains('mt-score-input')) {
                updateMexicanTrainLeader();
            }
        });
        dom.mexicanTrainTracker.addEventListener('click', (e) => {
            const target = e.target;
            if (target.classList.contains('edit-round-btn')) {
                const roundIndex = parseInt(target.dataset.roundIndex, 10);
                mexicanTrainState.editingRoundIndex = roundIndex;
                renderMexicanTrainTracker();
            } else if (target.classList.contains('cancel-edit-btn')) {
                delete mexicanTrainState.editingRoundIndex;
                renderMexicanTrainTracker();
            } else if (target.classList.contains('save-round-btn')) {
                const roundIndex = parseInt(target.dataset.roundIndex, 10);
                saveEditedMexicanTrainRound(roundIndex);
            }
        });


        // --- Initialization (IIFE) ---
        (async () => {
            console.log("App initialization started.");
            addListenToInsightButton();
            lastLongInsightText = dom.geminiInsightResultDiv.textContent;
            loadImageCache();

            try {
                if (!firebaseConfig.apiKey || firebaseConfig.apiKey.includes("YOUR_") || firebaseConfig.apiKey.includes("Replace!") || !firebaseConfig.projectId || firebaseConfig.projectId.includes("YOUR_") || firebaseConfig.projectId.includes("Replace!")) {
                    dom.firebaseConfigWarningDiv.innerHTML = '<strong>Firebase Setup: CRITICAL!</strong> Please replace placeholder values in `firebaseConfig` (like YOUR_API_KEY, YOUR_PROJECT_ID) with your actual Firebase project configuration. Stats will not load without this.';
                    dom.firebaseConfigWarningDiv.style.backgroundColor = '#f8d7da';
                    console.error("Firebase config contains placeholder values. Halting Firebase initialization.");
                } else {
                    app = initializeApp(firebaseConfig);
                    db = getFirestore(app);
                    firebaseInitializedSuccessfully = true;
                    dom.firebaseConfigWarningDiv.style.display = 'none';
                    console.log("Firebase initialized successfully.");
                }
            } catch (error) {
                console.error("Firebase Initialization Error:", error);
                if (dom.firebaseErrorDiv) { dom.firebaseErrorMessageSpan.textContent = `Firebase Init Error: ${error.message}. Check console, ensure config is correct & Firebase services (Firestore API) are enabled in Google Cloud.`; dom.firebaseErrorDiv.style.display = 'block'; }
                dom.firebaseConfigWarningDiv.innerHTML = '<strong>Firebase Initialization Failed!</strong> Check console for details.';
                dom.firebaseConfigWarningDiv.style.backgroundColor = '#f8d7da';
            }

            if (typeof Chart !== 'undefined' && typeof ChartDataLabels !== 'undefined') { Chart.register(ChartDataLabels); console.log("Chart.js and Datalabels registered."); }
            else { console.warn("Chart or ChartDataLabels not fully loaded. Datalabels might not work."); }

            currentView = 'player';
            currentDashboardPeriod = 'month';
            currentDisplayDate = new Date();
            updateApiKeySectionVisibility();
            updateTimerDisplay();

            if (firebaseInitializedSuccessfully) {
                console.log("Proceeding with Firebase-dependent setup.");
                try {
                    const lastGameId = localStorage.getItem('rummikubTrackerLastGameId');
                    if (lastGameId) {
                        currentGameId = lastGameId;
                    }
                    
                    await loadGames();
                    populateGameSelector();

                    if (currentGameId === 'mexican_train') {
                        await loadMexicanTrainState();
                    }
                    
                    await loadAudioPreferencesFromFirebase();
                    currentActiveAudioPreferenceId = await getActiveAudioPreferenceIdFromFirebase();
                    populateAudioSourceSelect();
                    await applyAudioChoice(currentActiveAudioPreferenceId);
                    updateCustomAudioUI();
                    console.log("Audio preferences loaded.");

                    await loadData();
                    console.log("Game data loading initiated (players, wins).");

                    if (getStoredGeminiApiKey()) {
                        console.log("Attempting to fetch initial Gemini insight.");
                        handleGetGeminiInsight(false);
                    } else {
                        toggleListenButton(false);
                        dom.getGeminiInsightBtn.disabled = true;
                    }
                } catch (error) {
                    console.error("Error during Firebase-dependent setup (games/audio/data/gemini):", error);
                    renderApp(); // Render basic structure even on error
                    const errorMsg = "Error loading app data. Check console.";
                    dom.noPlayersForScoringMsg.textContent = errorMsg;
                    dom.noPlayersForScoringMsg.classList.remove('hidden');
                    dom.geminiInsightResultDiv.textContent = errorMsg;
                    lastLongInsightText = errorMsg;
                    toggleListenButton(false);
                }
            } else {
                console.warn("Firebase not initialized. Skipping Firebase-dependent setup.");
                games = [{ id: DEFAULT_GAME_ID, name: 'Rummikub' }];
                populateGameSelector();
                populateAudioSourceSelect();
                applyAudioChoice("default"); 
                updateCustomAudioUI();
                renderApp(); 
                dom.noPlayersForScoringMsg.textContent = "Database connection failed. Cannot load players.";
                dom.noPlayersForScoringMsg.classList.remove('hidden');
                dom.noWinsTodayMsg.textContent = "Database connection failed.Cannot load wins.";
                dom.noWinsTodayMsg.classList.remove('hidden');
                if(dom.scoreTrackingListUl) dom.scoreTrackingListUl.innerHTML = '<p class="no-data">Score tracking unavailable (database error).</p>';

                const noDbMsg = 'Database connection failed. AI insights require game data.';
                if (!getStoredGeminiApiKey()) {
                    const noKeyMsg = 'Please enter your Gemini API Key. AI features also require database connection.';
                    dom.geminiInsightResultDiv.textContent = noKeyMsg;
                    lastLongInsightText = noKeyMsg;
                } else {
                    dom.geminiInsightResultDiv.textContent = noDbMsg;
                    lastLongInsightText = noDbMsg;
                }
                toggleListenButton(false);
                dom.getGeminiInsightBtn.disabled = true;
            }
            console.log("App initialization finished.");
        })();
    </script>
</body>
</html>
