<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rummikub Win Tracker</title>
    <!-- Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <style>
        /* CSS Styles (keep existing styles from previous full HTML) */
        /* --- Basic Reset & Defaults --- */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; background-color: #f4f7f6; color: #333; padding-bottom: 50px; }
        .app-container { max-width: 600px; margin: 0 auto; padding: 15px; position: relative; z-index: 1; }
        h1, h2, h3 { margin-bottom: 0.8em; color: #0b4f6c; }
        h1 { text-align: center; margin-bottom: 1em; color: #012a4a; }
        p { margin-bottom: 1em; }
        button { display: inline-block; padding: 10px 18px; font-size: 1rem; font-weight: bold; color: #fff; background-color: #219ebc; border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.2s ease; min-height: 44px; vertical-align: middle; -webkit-tap-highlight-color: transparent; }
        button:hover, button:focus { background-color: #1a7f9a; outline: none; }
        button:disabled { background-color: #adb5bd; cursor: not-allowed; }
        button.secondary { background-color: #6c757d; }
        button.secondary:hover, button.secondary:focus { background-color: #5a6268; }
        button.danger { background-color: #e76f51; }
        button.danger:hover, button.danger:focus { background-color: #d95a3a; }
        button.icon-button { padding: 8px 10px; font-size: 0.9rem; margin-left: 5px; }
        button.small-nav-button { padding: 5px 10px; font-size: 0.9rem; min-height: 30px; margin: 0 5px; }
        input[type="text"] { width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 1rem; }
        select { width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 1rem; background-color: white; min-height: 44px; }
        label { display: block; margin-bottom: 5px; font-weight: 500; font-size: 0.9em; }
        section { background-color: #fff; padding: 15px; margin-bottom: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); }
        header { margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; }
        header h1 { margin-bottom: 0; flex-grow: 1; text-align: left; margin-right: 10px; }
        .header-buttons { display: flex; align-items: center; }
        #togglePlayerManagement { flex-shrink: 0; margin-left: 5px; }
        #toggleTimerBtn { flex-shrink: 0; margin-left: 10px; background-color: #2a9d8f; padding: 8px 10px; font-size: 0.9rem; }
        #toggleTimerBtn:hover, #toggleTimerBtn:focus { background-color: #258a7f; }
        #playerManagement { border: 1px dashed #ccc; }
        #playerManagement.hidden { display: none; }
        .player-management-entry { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #eee; }
        .player-management-entry:last-child { border-bottom: none; }
        .player-management-entry span.player-name-display { flex-grow: 1; margin-right: 10px; }
        .rename-controls { display: flex; align-items: center; }
        .rename-controls input { width: 120px; margin-bottom: 0; margin-right: 5px; font-size: 0.9rem; padding: 5px 8px; }
        #timerAudioSettings { margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee; }
        #timerAudioSettings h4 { margin-bottom: 0.5em; color: #333; }
        #timerAudioSettings button { margin-top: 5px; margin-right: 5px; font-size:0.9rem; padding: 8px 12px; }
        #customUrlGroup { margin-top: 10px; padding: 10px; border: 1px solid #e0e0e0; border-radius: 4px; background-color: #f9f9f9; }
        #customUrlGroup label { font-size: 0.85em; }
        #customUrlGroup input[type="text"] { margin-bottom: 8px; }
        #audioUrlStatus { font-size: 0.9em; margin-top: 8px; line-height: 1.3; }
        #audioUrlStatus .success { color: green; }
        #audioUrlStatus .error { color: red; }
        #audioUrlStatus .info { color: #333; }
        #scoreTrackingList li, #todaysWinsList li { display: flex; justify-content: space-between; align-items: center; padding: 12px 5px; border-bottom: 1px solid #eee; }
        #scoreTrackingList li:last-child, #todaysWinsList li:last-child { border-bottom: none; }
        .player-info { flex-grow: 1; margin-right: 10px; }
        .player-name { font-weight: bold; display: block; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .win-timestamp { font-size: 0.85em; color: #666; margin-left: 10px; margin-right: 10px; white-space: nowrap; }
        .win-feedback { display: block; font-size: 0.85em; color: #28a745; margin-top: 2px; font-style: italic; animation: fadeOut 3s forwards; line-height: 1.2; }
        @keyframes fadeOut { 0% { opacity: 1; } 80% { opacity: 1; } 100% { opacity: 0; } }
        .dashboard-controls { display: flex; justify-content: space-around; margin-bottom: 15px; flex-wrap: wrap; }
        .dashboard-controls button { flex-grow: 1; margin: 5px; background-color: #f8f9fa; color: #0b4f6c; border: 1px solid #dee2e6; }
        .dashboard-controls button.active { background-color: #0b4f6c; color: #fff; font-weight: bold; border-color: #0b4f6c; }
        .dashboard-view-toggle { text-align: center; margin-bottom: 15px; }
        .dashboard-view-toggle .small-nav-button { background-color: #e9ecef; color: #495057; border: 1px solid #ced4da; font-weight: normal; }
        .dashboard-view-toggle .small-nav-button.active { background-color: #0b4f6c; color: #ffffff; border-color: #0b4f6c; font-weight: bold; box-shadow: inset 0 1px 2px rgba(0,0,0,0.1); }
        .chart-title-container { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .chart-title-container h3 { margin-bottom: 0; text-align: center; flex-grow: 1; color: #333; font-weight: bold; }
        #winChartContainer, #monthlyChartContainer { background-color: #f8f9fa; padding: 20px 10px 10px 10px; border-radius: 5px; min-height: 320px; position: relative; }
        #chart, #monthlyChart { position: relative; height: 270px; width: 100%; }
        canvas.hidden { display: none; }
        .hidden { display: none !important; }
        .text-center { text-align: center; }
        .error-message { color: #d95a3a; font-size: 0.9em; margin-top: -5px; margin-bottom: 10px; }
        .no-data { color: #6c757d; text-align: center; padding: 20px; font-style: italic; margin-top: 20px; }
        ul { list-style: none; padding: 0; }
        .total-wins-display { font-size: 0.9em; color: #555; margin-top: -5px; margin-bottom: 10px; font-weight: bold; }
        .todays-summary { font-size: 0.95em; color: #444; background-color: #eef3f5; padding: 8px 12px; border-radius: 4px; margin-bottom: 15px; border-left: 3px solid #219ebc; }
        .todays-summary.hidden { display: none; }
        .todays-summary span { display: inline-block; margin-right: 15px; }
        .todays-summary span:last-child { margin-right: 0; }
        #timerOverlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: #333333; z-index: 1000; display: none; flex-direction: column; justify-content: center; align-items: center; overflow: hidden; }
        #timerFill { position: absolute; bottom: 0; left: 0; width: 100%; height: 100%; background-color: #4CAF50; transition: height 0.1s linear; z-index: 1; }
        #timerDisplay { font-size: 10em; font-weight: bold; color: white; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5); z-index: 2; position: relative; }
        #hideTimerBtn { position: absolute; top: 20px; right: 20px; padding: 12px 24px; font-size: 1.2rem; background-color: rgba(255, 255, 255, 0.7); color: #333; border: 1px solid #ccc; border-radius: 5px; cursor: pointer; z-index: 2; }
        #hideTimerBtn:hover { background-color: rgba(255, 255, 255, 0.9); }
        #nextTimerBtn { margin-top: 25px; padding: 18px 40px; font-size: 1.8rem; min-width: 150px; font-weight: bold; background-color: rgba(255, 255, 255, 0.7); color: #333; border: 1px solid #ccc; border-radius: 8px; cursor: pointer; z-index: 2; transition: background-color 0.2s ease; }
        #nextTimerBtn:hover { background-color: rgba(255, 255, 255, 0.95); }
        #geminiInsightsSection { background-color: #e9f5fd; border-top: 3px solid #0b4f6c; }
        #geminiInsightsSection h2 { color: #012a4a; }
        #geminiApiKeyInputGroup label { font-weight: bold; }
        #geminiApiKeyInputGroup input[type="text"] { margin-bottom: 5px; }
        #geminiApiKeyNote { font-size:0.8em; color:#555; margin-top: 0; margin-bottom: 10px;}
        #geminiInsightResult { margin-top: 10px; padding: 12px; background-color: #ffffff; border-radius: 4px; min-height: 40px; border-left: 4px solid #ffc107; line-height: 1.5; white-space: pre-wrap; /* Ensures full text is shown and wraps */ overflow-y: auto; /* Adds scroll if content overflows a max height */ max-height: 200px; /* Example max height */ }
        .gemini-buttons-flex { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px; }
        #changeApiKeyBtn { background-color: #6c757d; font-size: 0.9rem; padding: 8px 12px;}
        #firebaseConfigWarning, #firebaseError {
            padding: 10px; margin-top: 20px; border-radius: 5px; font-size: 0.9em;
            word-break: break-word; /* Ensure long messages wrap */
        }
        #firebaseConfigWarning { background-color: #fff3cd; border: 1px solid #ffeeba; }
        #firebaseError { background-color: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; display: none; }
    </style>
</head>
<body>

    <div id="timerOverlay">
        <div id="timerFill"></div>
        <div id="timerDisplay">1:00</div>
        <button id="nextTimerBtn" aria-label="Next Turn Timer">NEXT</button>
        <button id="hideTimerBtn" aria-label="Hide Timer">Hide Timer</button>
    </div>
    <audio id="timerAudio" preload="auto"></audio>


    <div class="app-container">
         <header>
            <h1>Rummikub Wins</h1>
            <div class="header-buttons">
                 <button id="toggleTimerBtn" aria-label="Show Timer">⏱️ Timer</button>
                 <button id="togglePlayerManagement" class="secondary icon-button" aria-label="Manage Players & Settings" title="Manage Players & Settings">⚙️ Manage</button>
            </div>
        </header>

        <section id="geminiInsightsSection">
            <h2>AI Game Insights ✨</h2>
            <div id="geminiApiKeyInputGroup">
                <label for="geminiApiKey">Google AI Studio API Key:</label>
                <input type="text" id="geminiApiKey" placeholder="Enter your Gemini API Key">
                <p id="geminiApiKeyNote">
                    Get your key from <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer">Google AI Studio</a>.
                    The key will be stored in your browser's local storage.
                    <br><strong>Note:</strong> This key will also be used for Text-to-Speech. Ensure the Cloud Text-to-Speech API is enabled in your Google Cloud Project.
                </p>
            </div>
            <div id="geminiApiKeyStoredInfo" class="hidden">
                <p style="color: green; margin-bottom: 5px;">API Key is stored. <button id="changeApiKeyBtn" class="small-nav-button">Change/Re-enter Key</button></p>
            </div>

            <div id="geminiInsightResult">
                Enter your API Key above to get started...
            </div>
            <div class="gemini-buttons-flex">
                <button id="getGeminiInsightBtn">Get New Funny Insight 😂</button>
                <!-- The Listen button will be added here by JavaScript -->
            </div>
        </section>

        <section id="playerManagement" class="hidden">
            <h3>Manage Players & Settings</h3>
            <div id="addPlayerForm">
                <label for="newPlayerName">Add New Player:</label>
                <input type="text" id="newPlayerName" placeholder="New Player Name">
                <button id="addPlayerBtn">Add Player</button>
                <div id="addPlayerError" class="error-message"></div>
            </div>
            <ul id="playerListManagement"></ul>
            <p id="noPlayersManaged" class="no-data hidden">No players added yet.</p>

            <div id="timerAudioSettings">
                <h4>Timer Alarm Sound</h4>
                <label for="audioSourceSelect">Select or Add Sound:</label>
                <select id="audioSourceSelect"></select>
                 <div id="audioUrlStatus"></div>
                <div id="customUrlGroup" class="hidden">
                    <label for="customAudioShortNameInput">Short Name (Required):</label>
                    <input type="text" id="customAudioShortNameInput" placeholder="e.g., My Awesome Beep">
                    <label for="customAudioUrlInput">Custom Audio URL:</label>
                    <input type="text" id="customAudioUrlInput" placeholder="Enter direct audio link (e.g., .mp3)">
                    <button id="saveCustomAudioBtn">Save & Use This Sound</button>
                </div>
                <button id="removeFavoriteBtn" class="secondary hidden">Remove Selected Sound</button>
            </div>
        </section>

        <section id="dashboard">
            <h2>Dashboard</h2>
            <div class="dashboard-controls"> <button data-period="month" class="active">This Month</button> <button data-period="week">This Week</button> <button data-period="year">This Year</button> </div>
            <div class="dashboard-view-toggle"> <button id="playerViewBtn" class="secondary small-nav-button active">Player Wins</button> <button id="monthlyViewBtn" class="secondary small-nav-button">Monthly Breakdown</button> </div>
            <div id="winChartContainer"> <div class="chart-title-container"> <button id="prevPeriodBtn" class="secondary small-nav-button hidden" aria-label="Previous Period">⬅️ Prev</button> <h3 id="winChartTitle">Wins This Week</h3> <button id="nextPeriodBtn" class="secondary small-nav-button hidden" aria-label="Next Period">Next ➡️</button> </div> <p id="totalPlayerWinsDisplay" class="total-wins-display text-center"></p> <div id="chart"> <canvas id="playerWinCanvas"></canvas> <p id="noChartData" class="no-data hidden">No wins recorded for this period.</p> </div> </div>
            <div id="monthlyChartContainer" class="hidden"> <div class="chart-title-container"> <button id="prevYearBtn" class="secondary small-nav-button" aria-label="Previous Year">⬅️ Prev Yr</button> <h3 id="monthlyChartTitle">Monthly Winners for 2023</h3> <button id="nextYearBtn" class="secondary small-nav-button" aria-label="Next Year">Next Yr ➡️</button> </div> <p id="totalMonthlyWinsDisplay" class="total-wins-display text-center"></p> <div id="monthlyChart"> <canvas id="monthlyWinsCanvas"></canvas> <p id="noMonthlyChartData" class="no-data hidden">No wins recorded for this year.</p> </div> </div>
        </section>
        <section id="scoreTracking"> <h2>Record a Win</h2> <ul id="scoreTrackingList"></ul> <p id="noPlayersForScoring" class="no-data hidden">Add players to track wins.</p> </section>
        <section id="todaysWins"> <h3>Recorded Today (<span id="todayDateDisplay"></span>)</h3> <div id="todaysSummary" class="todays-summary hidden"></div> <ul id="todaysWinsList"></ul> <p id="noWinsToday" class="no-data">No wins recorded yet today.</p> </section>

        <div id="firebaseConfigWarning"><strong>Firebase Setup:</strong> Initializing...</div>
        <div id="firebaseError"><strong>Firebase Error:</strong> <span id="firebaseErrorMessage"></span></div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getFirestore, collection, getDocs, getDoc, addDoc, deleteDoc, updateDoc, doc, query, orderBy, Timestamp, serverTimestamp, setDoc } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";

        // Firebase configuration (replace with your actual config)
        const firebaseConfig = {
          apiKey: "AIzaSyD-e3H5CaoQobBqFwzDnCGZCUbniZQg_J0", // Replace!
          authDomain: "i-am-awesome-tasker.firebaseapp.com", // Replace!
          projectId: "i-am-awesome-tasker", // Replace!
          storageBucket: "i-am-awesome-tasker.appspot.com", // Replace!
          messagingSenderId: "853316153385", // Replace!
          appId: "1:853316153385:web:db1fc1304b54a198a82c38", // Replace!
          measurementId: "G-ZDBF73CFXS" // Optional: Replace!
        };


        let app, db;
        let firebaseInitializedSuccessfully = false;

        // --- Global Variables ---
        let players = [];
        let wins = [];
        let currentDashboardPeriod = 'month';
        let currentDisplayDate = new Date();
        let currentView = 'player';
        let playerWinChartInstance = null;
        let monthlyChartInstance = null;
        let timerTimeoutId = null;
        const TIMER_DURATION_SECONDS = 60;
        let timerRemainingSeconds = TIMER_DURATION_SECONDS;
        const PRELOAD_AI_COMMENTARY_SECONDS_BEFORE_END = 5; // Preload AI commentary 5s before timer ends
        let isTimerVisible = false;
        let audioUnlocked = false;
        let wakeLockSentinel = null; // THIS IS THE WAKE LOCK SENTINEL
        let audioPreferences = [];
        let currentActiveAudioPreferenceId = "default";
        let insightAudio = null; // For TTS audio object for "Listen to Insight" button
        let isSpeaking = false; // For TTS state for "Listen to Insight" button
        let aiCommentaryAudio = null; // For preloaded AI timer commentary
        let isLoadingAiCommentary = false; // Flag to prevent multiple loads
        let currentTimerAiCommentaryText = ""; // Stores the text of the AI timer commentary
        let lastLongInsightText = ""; // ADDED: To store the last fetched long insight

        const DEFAULT_AUDIO_URL = "https://www.dropbox.com/scl/fi/540eent9p1es21f4ep2ix/trompo_1-edit.mp3?rlkey=m0hhk27s8892ow6eyogpqxm00&st=zi9nt3i9&dl=1";
        const AUDIO_PREFERENCES_COLLECTION = 'audioPreferences';
        const APP_CONFIG_COLLECTION = 'appConfiguration';
        const TIMER_SETTINGS_DOC_ID = 'timerSettings';
        const GEMINI_API_KEY_STORAGE_KEY = 'rummikubTrackerGeminiApiKey';
        const AI_COMMENTATOR_ID = "ai_commentator";


        // --- DOM Elements ---
        const dom = {
            togglePlayerManagementBtn: document.getElementById('togglePlayerManagement'),
            playerManagementSection: document.getElementById('playerManagement'),
            addPlayerBtn: document.getElementById('addPlayerBtn'),
            newPlayerNameInput: document.getElementById('newPlayerName'),
            addPlayerError: document.getElementById('addPlayerError'),
            playerListManagementUl: document.getElementById('playerListManagement'),
            noPlayersManagedMsg: document.getElementById('noPlayersManaged'),
            dashboardControls: document.querySelector('.dashboard-controls'),
            playerViewBtn: document.getElementById('playerViewBtn'),
            monthlyViewBtn: document.getElementById('monthlyViewBtn'),
            winChartContainer: document.getElementById('winChartContainer'),
            winChartTitle: document.getElementById('winChartTitle'),
            playerWinCanvas: document.getElementById('playerWinCanvas'),
            noChartDataMsg: document.getElementById('noChartData'),
            prevPeriodBtn: document.getElementById('prevPeriodBtn'),
            nextPeriodBtn: document.getElementById('nextPeriodBtn'),
            monthlyChartContainer: document.getElementById('monthlyChartContainer'),
            monthlyChartTitle: document.getElementById('monthlyChartTitle'),
            monthlyWinsCanvas: document.getElementById('monthlyWinsCanvas'),
            noMonthlyChartDataMsg: document.getElementById('noMonthlyChartData'),
            prevYearBtn: document.getElementById('prevYearBtn'),
            nextYearBtn: document.getElementById('nextYearBtn'),
            scoreTrackingListUl: document.getElementById('scoreTrackingList'),
            noPlayersForScoringMsg: document.getElementById('noPlayersForScoring'),
            todayDateDisplay: document.getElementById('todayDateDisplay'),
            todaysWinsListUl: document.getElementById('todaysWinsList'),
            noWinsTodayMsg: document.getElementById('noWinsToday'),
            todaysSummaryDiv: document.getElementById('todaysSummary'),
            toggleTimerBtn: document.getElementById('toggleTimerBtn'),
            timerOverlay: document.getElementById('timerOverlay'),
            timerFill: document.getElementById('timerFill'),
            timerDisplay: document.getElementById('timerDisplay'),
            hideTimerBtn: document.getElementById('hideTimerBtn'),
            timerAudio: document.getElementById('timerAudio'), // For default/custom static sounds
            nextTimerBtn: document.getElementById('nextTimerBtn'),
            totalPlayerWinsDisplay: document.getElementById('totalPlayerWinsDisplay'),
            totalMonthlyWinsDisplay: document.getElementById('totalMonthlyWinsDisplay'),
            audioSourceSelect: document.getElementById('audioSourceSelect'),
            customUrlGroup: document.getElementById('customUrlGroup'),
            customAudioShortNameInput: document.getElementById('customAudioShortNameInput'),
            customAudioUrlInput: document.getElementById('customAudioUrlInput'),
            saveCustomAudioBtn: document.getElementById('saveCustomAudioBtn'),
            removeFavoriteBtn: document.getElementById('removeFavoriteBtn'),
            audioUrlStatus: document.getElementById('audioUrlStatus'),
            geminiApiKeyInputGroup: document.getElementById('geminiApiKeyInputGroup'),
            geminiApiKeyInput: document.getElementById('geminiApiKey'),
            geminiApiKeyNote: document.getElementById('geminiApiKeyNote'),
            geminiApiKeyStoredInfo: document.getElementById('geminiApiKeyStoredInfo'),
            changeApiKeyBtn: document.getElementById('changeApiKeyBtn'),
            getGeminiInsightBtn: document.getElementById('getGeminiInsightBtn'),
            geminiInsightResultDiv: document.getElementById('geminiInsightResult'),
            geminiButtonsFlexDiv: document.querySelector('.gemini-buttons-flex'),
            listenToInsightBtn: null, // Will be created dynamically
            firebaseConfigWarningDiv: document.getElementById('firebaseConfigWarning'),
            firebaseErrorDiv: document.getElementById('firebaseError'),
            firebaseErrorMessageSpan: document.getElementById('firebaseErrorMessage'),
        };

        // --- Utility Functions ---
        const utils = { getTodayDateString: () => new Date().toDateString(), formatTime: (timestamp) => { if (!timestamp) return ''; const date = timestamp.toDate ? timestamp.toDate() : (timestamp instanceof Date ? timestamp : null); if (!date) return ''; return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); }, getMonthName: (monthIndex) => ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][monthIndex], getFullMonthName: (monthIndex) => ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"][monthIndex], getPeriodRange: (period, baseDate = new Date()) => { let start = new Date(baseDate); let end = new Date(baseDate); switch (period) { case 'week': const dayOfWeek = start.getDay(); const diff = start.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1); start = new Date(start.setDate(diff)); start.setHours(0, 0, 0, 0); end = new Date(start); end.setDate(start.getDate() + 6); end.setHours(23, 59, 59, 999); break; case 'month': start = new Date(start.getFullYear(), start.getMonth(), 1); start.setHours(0, 0, 0, 0); end = new Date(start.getFullYear(), start.getMonth() + 1, 0); end.setHours(23, 59, 59, 999); break; case 'year': start = new Date(start.getFullYear(), 0, 1); start.setHours(0, 0, 0, 0); end = new Date(start.getFullYear(), 11, 31); end.setHours(23, 59, 59, 999); break; } return { start, end }; }, sanitizeHTML: (str) => { const temp = document.createElement('div'); temp.textContent = str; return temp.innerHTML; }, pluralize: (count, singular, plural = null) => { plural = plural ?? singular + 's'; return count === 1 ? `${count} ${singular}` : `${count} ${plural}`; } };

        // --- Audio Settings Management ---
        async function loadAudioPreferencesFromFirebase() { if (!db) { audioPreferences = []; return; } try { const prefsCollection = collection(db, AUDIO_PREFERENCES_COLLECTION); const prefsQuery = query(prefsCollection, orderBy("name")); const snapshot = await getDocs(prefsQuery); audioPreferences = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); } catch (error) { console.error("Error loading audio preferences:", error); dom.audioUrlStatus.innerHTML = `<span class="error">Failed to load audio list: ${error.message}</span>`; audioPreferences = []; } }
        async function saveAudioPreferenceToFirebase(name, url) { if (!db) return null; name = name.trim(); url = url.trim(); const existingByName = audioPreferences.find(p => p.name.toLowerCase() === name.toLowerCase()); if (existingByName) { dom.audioUrlStatus.innerHTML = `<span class="error">A sound with the name "${utils.sanitizeHTML(name)}" already exists. Please choose a different name.</span>`; return null; } const existingByUrl = audioPreferences.find(p => p.url === url); if (existingByUrl) { dom.audioUrlStatus.innerHTML = `<span class="info">This URL is already saved as "${utils.sanitizeHTML(existingByUrl.name)}". To use it, select it from the list.</span>`; return null; } try { const docRef = await addDoc(collection(db, AUDIO_PREFERENCES_COLLECTION), { name: name, url: url, createdAt: serverTimestamp() }); const newPref = { id: docRef.id, name, url, createdAt: Timestamp.now() }; audioPreferences.push(newPref); audioPreferences.sort((a, b) => a.name.localeCompare(b.name)); return newPref; } catch (error) { console.error("Error saving audio preference:", error); dom.audioUrlStatus.innerHTML = `<span class="error">Failed to save sound: ${error.message}</span>`; return null; } }
        async function getActiveAudioPreferenceIdFromFirebase() { if (!db) return "default"; try { const configDocRef = doc(db, APP_CONFIG_COLLECTION, TIMER_SETTINGS_DOC_ID); const docSnap = await getDoc(configDocRef); if (docSnap.exists() && docSnap.data().activeAudioPreferenceId) { return docSnap.data().activeAudioPreferenceId; } return "default"; } catch (error) { console.error("Error getting active audio preference:", error); return "default"; } }
        async function setActiveAudioPreferenceIdInFirebase(preferenceId) { if (!db) return; currentActiveAudioPreferenceId = preferenceId; try { const configDocRef = doc(db, APP_CONFIG_COLLECTION, TIMER_SETTINGS_DOC_ID); await setDoc(configDocRef, { activeAudioPreferenceId: preferenceId }, { merge: true }); } catch (error) { console.error("Error setting active audio preference:", error); dom.audioUrlStatus.innerHTML = `<span class="error">Failed to save active sound choice: ${error.message}</span>`; } }
        const populateAudioSourceSelect = () => {
            const activeId = currentActiveAudioPreferenceId;
            dom.audioSourceSelect.innerHTML = '';
            const defaultOption = new Option("Default Sound", "default");
            dom.audioSourceSelect.add(defaultOption);

            // Add AI Comedic Commentator option
            const aiCommentatorOption = new Option("✨ AI Comedic Commentator", AI_COMMENTATOR_ID);
            dom.audioSourceSelect.add(aiCommentatorOption);

            audioPreferences.forEach(pref => {
                const option = new Option(utils.sanitizeHTML(pref.name), pref.id);
                dom.audioSourceSelect.add(option);
            });
            const customNewOption = new Option("Add New Custom Sound...", "custom_new");
            dom.audioSourceSelect.add(customNewOption);

            // Check if activeId is valid, considering AI_COMMENTATOR_ID
            if (activeId !== "default" && activeId !== AI_COMMENTATOR_ID && !audioPreferences.some(p => p.id === activeId)) {
                console.warn(`Stale activeAudioPreferenceId '${activeId}' found. Reverting to default.`);
                currentActiveAudioPreferenceId = "default";
                if(firebaseInitializedSuccessfully) setActiveAudioPreferenceIdInFirebase("default");
                dom.audioSourceSelect.value = "default";
            } else {
                dom.audioSourceSelect.value = activeId || "default";
            }
        };
        const updateCustomAudioUI = () => { const selectedValue = dom.audioSourceSelect.value; if (selectedValue === "custom_new") { dom.customUrlGroup.classList.remove('hidden'); dom.customAudioShortNameInput.value = ""; dom.customAudioUrlInput.value = ""; dom.customAudioShortNameInput.readOnly = false; dom.customAudioUrlInput.readOnly = false; dom.saveCustomAudioBtn.classList.remove('hidden'); dom.removeFavoriteBtn.classList.add('hidden'); dom.customAudioShortNameInput.focus(); } else { dom.customUrlGroup.classList.add('hidden'); dom.saveCustomAudioBtn.classList.add('hidden'); dom.customAudioShortNameInput.value = ""; dom.customAudioUrlInput.value = ""; if (selectedValue === "default" || selectedValue === AI_COMMENTATOR_ID) { dom.removeFavoriteBtn.classList.add('hidden'); } else { const selectedPref = audioPreferences.find(p => p.id === selectedValue); if (selectedPref) { dom.removeFavoriteBtn.classList.remove('hidden'); } else { dom.removeFavoriteBtn.classList.add('hidden'); } } } };
        const applyAudioChoice = async (preferenceId) => {
            let urlToLoad;
            let statusName;

            if (preferenceId === AI_COMMENTATOR_ID) {
                dom.timerAudio.src = ""; // Clear any previous static src for the main timerAudio element
                statusName = "✨ AI Comedic Commentator";
                // This choice is dynamic, audio generated on the fly.
            } else if (preferenceId === "default" || !preferenceId) {
                urlToLoad = DEFAULT_AUDIO_URL;
                statusName = "Default Sound";
                preferenceId = "default";
            } else {
                const pref = audioPreferences.find(p => p.id === preferenceId);
                if (pref) {
                    urlToLoad = pref.url;
                    statusName = utils.sanitizeHTML(pref.name);
                } else {
                    console.warn(`Audio preference ID "${preferenceId}" not found during apply. Reverting to default.`);
                    urlToLoad = DEFAULT_AUDIO_URL;
                    statusName = "Default Sound";
                    preferenceId = "default";
                }
            }

            if (urlToLoad && dom.timerAudio.src !== urlToLoad) {
                dom.timerAudio.src = urlToLoad;
                dom.timerAudio.load();
            } else if (urlToLoad && (!dom.timerAudio.src || dom.timerAudio.src === window.location.href)) {
                dom.timerAudio.src = urlToLoad;
                dom.timerAudio.load();
            }

            if (firebaseInitializedSuccessfully) await setActiveAudioPreferenceIdInFirebase(preferenceId);
            dom.audioUrlStatus.innerHTML = `<span class="info">Currently using: ${statusName}</span>`;
            console.log(`Audio choice applied: ${preferenceId} (${statusName})`);
            if (isTimerVisible || audioUnlocked) { unlockAudioContext(); }
        };


        // --- Firebase Data Functions ---
        const loadData = async () => { if (!firebaseInitializedSuccessfully || !db) { console.error("loadData: Firebase not initialized or DB unavailable."); dom.noPlayersForScoringMsg.textContent = "Error: Database unavailable."; dom.noPlayersForScoringMsg.classList.remove('hidden'); dom.noWinsTodayMsg.textContent = "Error: Database unavailable."; dom.noWinsTodayMsg.classList.remove('hidden'); return; } console.log("loadData: Attempting to load data from Firestore..."); dom.noPlayersForScoringMsg.textContent = "Loading players..."; dom.noPlayersForScoringMsg.classList.remove('hidden'); dom.noWinsTodayMsg.textContent = "Loading wins..."; dom.noWinsTodayMsg.classList.remove('hidden'); try { const playersCollectionRef = collection(db, "players"); const playerQuery = query(playersCollectionRef, orderBy("name")); const playerSnapshot = await getDocs(playerQuery); players = playerSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); console.log(`loadData: Players loaded: ${players.length}`, players); const winsCollectionRef = collection(db, "wins"); const winSnapshot = await getDocs(winsCollectionRef); wins = winSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); wins = wins.filter(w => w.timestamp && typeof w.timestamp.toDate === 'function'); wins.sort((a, b) => b.timestamp.toMillis() - a.timestamp.toMillis()); console.log(`loadData: Wins loaded: ${wins.length}`, wins); dom.noPlayersForScoringMsg.textContent = "Add players to track wins."; dom.noWinsTodayMsg.textContent = "No wins recorded yet today."; } catch (error) { console.error("loadData: Error loading data from Firestore:", error); if (dom.firebaseErrorDiv) { dom.firebaseErrorMessageSpan.textContent = `Failed to load game data. Error: ${error.message}. Check Firestore rules, API enablement, and console.`; dom.firebaseErrorDiv.style.display = 'block'; } players = []; wins = []; dom.noPlayersForScoringMsg.textContent = "Error loading players."; dom.noWinsTodayMsg.textContent = "Error loading wins."; } finally { renderApp(); } };
        const addPlayer = async (name) => { if (!firebaseInitializedSuccessfully || !db) { alert("Database connection error. Cannot add player."); return; } const tN = name.trim(); if (!tN) { dom.addPlayerError.textContent = "Name empty."; return; } if (players.some(p => p.name.toLowerCase() === tN.toLowerCase())) { dom.addPlayerError.textContent = "Name exists."; return; } dom.addPlayerError.textContent = ""; dom.addPlayerBtn.disabled = true; try { const dR = await addDoc(collection(db, "players"), { name: tN }); players.push({ id: dR.id, name: tN }); players.sort((a, b) => a.name.localeCompare(b.name)); renderApp(); dom.newPlayerNameInput.value = ''; if (getStoredGeminiApiKey()) handleGetGeminiInsight(false); } catch (error) { console.error("Error adding player:", error); dom.addPlayerError.textContent = `Failed to add player: ${error.message}`; } finally { dom.addPlayerBtn.disabled = false; } };
        const deletePlayer = async (playerId) => { if (!firebaseInitializedSuccessfully || !db) { alert("Database connection error. Cannot delete player."); return; } const p = players.find(pl => pl.id === playerId); if (!p || !confirm(`Delete ${utils.sanitizeHTML(p.name)}? Wins remain as 'Unknown'.`)) return; const delBtn = dom.playerListManagementUl.querySelector(`.player-management-entry[data-player-id="${playerId}"] .delete-player-btn`); if (delBtn) delBtn.disabled = true; try { await deleteDoc(doc(db, "players", playerId)); players = players.filter(pl => pl.id !== playerId); renderApp(); if (getStoredGeminiApiKey()) handleGetGeminiInsight(false); } catch (error) { console.error("Error deleting player:", error); alert(`Failed: ${error.message}`); if (delBtn) delBtn.disabled = false; } };
        const renamePlayer = async (playerId, newName) => { if (!firebaseInitializedSuccessfully || !db) { alert("Database connection error. Cannot rename player."); return false; } const tN = newName.trim(); if (!tN) { alert("Name empty."); return false; } if (players.some(p => p.id !== playerId && p.name.toLowerCase() === tN.toLowerCase())) { alert("Name exists."); return false; } const pI = players.findIndex(p => p.id === playerId); if (pI === -1) return false; const entry = dom.playerListManagementUl.querySelector(`.player-management-entry[data-player-id="${playerId}"]`); const saveBtn = entry?.querySelector('.save-rename-btn'); const cancelBtn = entry?.querySelector('.cancel-rename-btn'); if(saveBtn) saveBtn.disabled = true; if(cancelBtn) cancelBtn.disabled = true; try { await updateDoc(doc(db, "players", playerId), { name: tN }); players[pI].name = tN; players.sort((a, b) => a.name.localeCompare(b.name)); renderApp(); if (getStoredGeminiApiKey()) handleGetGeminiInsight(false); return true; } catch (error) { console.error("Error renaming player:", error); alert(`Failed: ${error.message}`); if(saveBtn) saveBtn.disabled = false; if(cancelBtn) cancelBtn.disabled = false; return false; } };
        const recordWin = async (playerId) => { if (!firebaseInitializedSuccessfully || !db) { alert("Database connection error. Cannot record win."); return; } const player = players.find(pl => pl.id === playerId); if (!player) return; const winButton = dom.scoreTrackingListUl.querySelector(`button.add-win-btn[data-player-id="${playerId}"]`); const playerInfoDiv = dom.scoreTrackingListUl.querySelector(`li[data-player-id="${playerId}"] .player-info`); if (winButton) winButton.disabled = true; const existingFeedback = playerInfoDiv?.querySelector('.win-feedback'); if (existingFeedback) existingFeedback.remove(); try { const docRef = await addDoc(collection(db, "wins"), { playerId: playerId, timestamp: serverTimestamp() }); const newWin = { id: docRef.id, playerId: playerId, timestamp: Timestamp.now() }; wins.unshift(newWin); const playerName = utils.sanitizeHTML(player.name); const feedbackSpan = document.createElement('span'); feedbackSpan.className = 'win-feedback'; feedbackSpan.textContent = `Win added for ${playerName}!`; if (playerInfoDiv) { playerInfoDiv.appendChild(feedbackSpan); setTimeout(() => { feedbackSpan.remove(); }, 3000); } renderTodaysWinsList(); renderDashboard(); if (getStoredGeminiApiKey()) handleGetGeminiInsight(false); } catch (error) { console.error("Error recording win:", error); alert(`Failed to record win: ${error.message}`); } finally { setTimeout(() => { if (winButton) winButton.disabled = false; }, 500); } };
        const deleteWin = async (winId) => { if (!firebaseInitializedSuccessfully || !db) { alert("Database connection error. Cannot delete win."); return; } const wI = wins.findIndex(w => w.id === winId); if (wI === -1) return; const wD = wins[wI]; if (!wD.timestamp || typeof wD.timestamp.toDate !== 'function') return; const pN = players.find(p=>p.id === wD.playerId)?.name ?? 'Unknown Player'; if (!confirm(`Delete win for ${utils.sanitizeHTML(pN)} at ${utils.formatTime(wD.timestamp)}?`)) return; const delBtn = dom.todaysWinsListUl.querySelector(`li[data-win-id="${winId}"] .delete-win-btn`); if(delBtn) delBtn.disabled = true; try { await deleteDoc(doc(db, "wins", winId)); wins.splice(wI, 1); renderTodaysWinsList(); renderDashboard(); if (getStoredGeminiApiKey()) handleGetGeminiInsight(false); } catch (error) { console.error("Error deleting win:", error); alert(`Failed: ${error.message}`); if(delBtn) delBtn.disabled = false; } };
        const getWinsForPeriodLocal = (period, baseDate = new Date()) => { const { start, end } = utils.getPeriodRange(period, baseDate); const sT = start.getTime(); const eT = end.getTime(); return wins.filter(w => { if (!w.timestamp || typeof w.timestamp.toDate !== 'function') return false; const wT = w.timestamp.toDate().getTime(); return wT >= sT && wT <= eT; }); };
        const getWinsForYearLocal = (year) => { const s = new Date(year, 0, 1); const e = new Date(year, 11, 31, 23, 59, 59, 999); const sT = s.getTime(); const eT = e.getTime(); return wins.filter(w => { if (!w.timestamp || typeof w.timestamp.toDate !== 'function') return false; const wT = w.timestamp.toDate().getTime(); return wT >= sT && wT <= eT; }); };

        // --- Rendering Functions ---
        const renderPlayerManagementList = () => { dom.playerListManagementUl.innerHTML = ''; dom.noPlayersManagedMsg.classList.toggle('hidden', players.length > 0 || !firebaseInitializedSuccessfully); if (players.length === 0 && firebaseInitializedSuccessfully) return; if(!firebaseInitializedSuccessfully && dom.playerListManagementUl) { dom.playerListManagementUl.innerHTML = '<p class="no-data">Player management unavailable (database error).</p>'; return; } players.forEach(p => { const li = document.createElement('li'); li.className = 'player-management-entry'; li.dataset.playerId = p.id; const sN = utils.sanitizeHTML(p.name); li.innerHTML = ` <span class="player-name-display">${sN}</span> <div class="rename-controls hidden"> <input type="text" class="rename-input" value="${sN}" aria-label="New name for ${sN}"> <button class="save-rename-btn icon-button" aria-label="Save rename">✔️</button> <button class="cancel-rename-btn icon-button secondary" aria-label="Cancel rename">❌</button> </div> <div class="action-buttons"> <button class="rename-btn icon-button secondary" aria-label="Rename ${sN}">✏️ Rename</button> <button class="delete-player-btn icon-button danger" aria-label="Delete ${sN}">🗑️ Delete</button> </div> `; dom.playerListManagementUl.appendChild(li); }); };
        const renderScoreTrackingList = () => { dom.scoreTrackingListUl.innerHTML = ''; dom.noPlayersForScoringMsg.classList.toggle('hidden', players.length > 0 || !firebaseInitializedSuccessfully); if (players.length === 0 && firebaseInitializedSuccessfully) { dom.noPlayersForScoringMsg.textContent = "Add players to track wins."; return; } if(!firebaseInitializedSuccessfully && dom.scoreTrackingListUl) { dom.scoreTrackingListUl.innerHTML = '<p class="no-data">Score tracking unavailable (database error).</p>'; dom.noPlayersForScoringMsg.classList.add('hidden'); return; } players.forEach(p => { const li = document.createElement('li'); li.dataset.playerId = p.id; const sN = utils.sanitizeHTML(p.name); li.innerHTML = ` <div class="player-info"> <span class="player-name">${sN}</span> </div> <button class="add-win-btn" data-player-id="${p.id}">+ Win</button> `; dom.scoreTrackingListUl.appendChild(li); }); };
        const renderTodaysWinsList = () => { dom.todaysWinsListUl.innerHTML = ''; dom.todaysSummaryDiv.innerHTML = ''; dom.todaysSummaryDiv.classList.add('hidden'); const todayStr = utils.getTodayDateString(); dom.todayDateDisplay.textContent = todayStr; if (!firebaseInitializedSuccessfully) { dom.noWinsTodayMsg.textContent="Win list unavailable (database error)."; dom.noWinsTodayMsg.classList.remove('hidden'); return;} const todaysWins = wins.filter(w => w.timestamp?.toDate().toDateString() === todayStr); dom.noWinsTodayMsg.classList.toggle('hidden', todaysWins.length > 0); if (todaysWins.length > 0) { const winsByPlayerToday = todaysWins.reduce((acc, win) => { acc[win.playerId] = (acc[win.playerId] || 0) + 1; return acc; }, {}); const summaryItems = []; const sortedPlayerIds = Object.keys(winsByPlayerToday).sort((a, b) => { const playerA = players.find(p => p.id === a); const playerB = players.find(p => p.id === b); const nameA = playerA ? playerA.name : 'Unknown'; const nameB = playerB ? playerB.name : 'Unknown'; return nameA.localeCompare(nameB); }); sortedPlayerIds.forEach(playerId => { const count = winsByPlayerToday[playerId]; const player = players.find(p => p.id === playerId); const playerName = player ? utils.sanitizeHTML(player.name) : 'Unknown Player'; summaryItems.push(`<span>${playerName}: ${utils.pluralize(count, 'win')}</span>`); }); if (summaryItems.length > 0) { dom.todaysSummaryDiv.innerHTML = `<strong>Summary:</strong> ${summaryItems.join(' ')}`; dom.todaysSummaryDiv.classList.remove('hidden'); } todaysWins.forEach(w => { const player = players.find(pl => pl.id === w.playerId); const playerName = player ? utils.sanitizeHTML(player.name) : 'Unknown Player'; const li = document.createElement('li'); li.dataset.winId = w.id; li.innerHTML = ` <span class="player-name">${playerName}</span> <span class="win-timestamp">${utils.formatTime(w.timestamp)}</span> <button class="delete-win-btn icon-button danger" aria-label="Delete this win">🗑️</button> `; dom.todaysWinsListUl.appendChild(li); }); } };
        const renderDashboard = () => { dom.dashboardControls.querySelectorAll('button[data-period]').forEach(b => { b.classList.toggle('active', b.dataset.period === currentDashboardPeriod); }); dom.playerViewBtn.classList.toggle('active', currentView === 'player'); dom.monthlyViewBtn.classList.toggle('active', currentView === 'monthly'); dom.winChartContainer.classList.toggle('hidden', currentView !== 'player'); dom.monthlyChartContainer.classList.toggle('hidden', currentView === 'player'); if (currentView === 'player') { renderPlayerWinsChart(currentDashboardPeriod, currentDisplayDate); } else if (currentView === 'monthly') { renderMonthlyBreakdownChart(currentDisplayDate.getFullYear()); } };
        const renderPlayerWinsChart = (period, displayDate) => { if (playerWinChartInstance) { playerWinChartInstance.destroy(); playerWinChartInstance = null; } if (!firebaseInitializedSuccessfully) {dom.noChartDataMsg.textContent="Charts unavailable (database error)."; dom.noChartDataMsg.classList.remove('hidden'); dom.playerWinCanvas.classList.add('hidden'); return;} const { start, end } = utils.getPeriodRange(period, displayDate); let chartTitleText = ''; const today = new Date(); today.setHours(0,0,0,0); const currentPeriodRange = utils.getPeriodRange(period, today); const isCurrentPeriod = currentPeriodRange.start.getTime() === start.getTime(); switch (period) { case 'week': chartTitleText = isCurrentPeriod ? 'Wins This Week' : `Week of ${start.toLocaleDateString()}`; break; case 'month': const monthName = utils.getFullMonthName(displayDate.getMonth()); chartTitleText = isCurrentPeriod ? `Wins This ${monthName}` : `Wins ${monthName} ${displayDate.getFullYear()}`; break; case 'year': chartTitleText = isCurrentPeriod ? `Wins This Year (${displayDate.getFullYear()})` : `Wins ${displayDate.getFullYear()}`; break; } dom.winChartTitle.textContent = chartTitleText; dom.prevPeriodBtn.classList.remove('hidden'); dom.nextPeriodBtn.classList.remove('hidden'); const endOfToday = new Date(); endOfToday.setHours(23,59,59,999); dom.nextPeriodBtn.disabled = end.getTime() >= endOfToday.getTime(); const periodWins = getWinsForPeriodLocal(period, displayDate); const totalWinsCount = periodWins.length; dom.totalPlayerWinsDisplay.textContent = `Total Wins: ${totalWinsCount}`; dom.totalPlayerWinsDisplay.classList.remove('hidden'); const hasPlayers = players.length > 0; const hasData = totalWinsCount > 0; let playerData = []; if (hasPlayers) { const winsByPlayer = players.reduce((acc, p) => { acc[p.id] = { name: p.name, count: 0 }; return acc; }, {}); periodWins.forEach(w => { if (w.playerId && winsByPlayer[w.playerId]) { winsByPlayer[w.playerId].count++; } }); playerData = Object.values(winsByPlayer); playerData.sort((a, b) => a.name.localeCompare(b.name)); } const showChart = hasPlayers && hasData; dom.playerWinCanvas.classList.toggle('hidden', !showChart); dom.noChartDataMsg.classList.toggle('hidden', showChart); if (!hasPlayers) { dom.noChartDataMsg.textContent = "Add players to see statistics."; dom.totalPlayerWinsDisplay.classList.add('hidden'); } else if (!hasData) { dom.noChartDataMsg.textContent = "No wins recorded for this period."; } if (showChart) { const ctx = dom.playerWinCanvas.getContext('2d'); if (!ctx) return; const labels = playerData.map(p => p.name); const dataCounts = playerData.map(p => p.count); playerWinChartInstance = new Chart(ctx, { type: 'bar', data: { labels: labels, datasets: [{ label: 'Wins', data: dataCounts, backgroundColor: '#219ebc', borderColor: '#1a7f9a', borderWidth: 1 }] }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true, ticks: { stepSize: 1, precision: 0 } } }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: function(c) { let l = c.dataset.label || ''; if (l) { l += ': '; } if (c.parsed.y !== null) { l += c.parsed.y + (c.parsed.y === 1 ? ' win' : ' wins'); } return l; } } } } } }); } };
        const renderMonthlyBreakdownChart = (year) => { if (monthlyChartInstance) { monthlyChartInstance.destroy(); monthlyChartInstance = null; } if (!firebaseInitializedSuccessfully) {dom.noMonthlyChartDataMsg.textContent="Charts unavailable (database error)."; dom.noMonthlyChartDataMsg.classList.remove('hidden'); dom.monthlyWinsCanvas.classList.add('hidden'); return;} dom.monthlyChartTitle.textContent = `Monthly Winners for ${year}`; dom.nextYearBtn.disabled = year >= new Date().getFullYear(); const yearWins = getWinsForYearLocal(year); const totalWinsCount = yearWins.length; const hasData = totalWinsCount > 0; dom.totalMonthlyWinsDisplay.textContent = `Total Wins: ${totalWinsCount}`; dom.totalMonthlyWinsDisplay.classList.remove('hidden'); let monthlyResults = []; let overallMaxWinningScore = 0; if(hasData) { const monthlyPlayerWins = {}; yearWins.forEach(win => { if (win.timestamp && typeof win.timestamp.toDate === 'function' && win.playerId) { const mI = win.timestamp.toDate().getMonth(); monthlyPlayerWins[mI] = monthlyPlayerWins[mI] || {}; monthlyPlayerWins[mI][win.playerId] = (monthlyPlayerWins[mI][win.playerId] || 0) + 1; } }); for (let i = 0; i < 12; i++) { const monthData = monthlyPlayerWins[i]; let winners = []; let maxScore = 0; if (monthData && Object.keys(monthData).length > 0) { maxScore = Math.max(...Object.values(monthData)); if (maxScore > overallMaxWinningScore) overallMaxWinningScore = maxScore; winners = Object.entries(monthData).filter(([_, score]) => score === maxScore).map(([playerId, _]) => utils.sanitizeHTML(players.find(p => p.id === playerId)?.name ?? 'Unknown')); } monthlyResults.push({ monthIndex: i, winnerNames: winners, winningScore: maxScore }); } } else { for (let i = 0; i < 12; i++) monthlyResults.push({ monthIndex: i, winnerNames: [], winningScore: 0 }); } dom.monthlyWinsCanvas.classList.toggle('hidden', !hasData); dom.noMonthlyChartDataMsg.classList.toggle('hidden', hasData); if (!hasData) dom.noMonthlyChartDataMsg.textContent = `No wins recorded for ${year}.`; if(hasData) { const ctx = dom.monthlyWinsCanvas.getContext('2d'); if (!ctx) return; const labels = monthlyResults.map(r => utils.getMonthName(r.monthIndex)); const dataScores = monthlyResults.map(r => r.winningScore); const yAxisMax = Math.max(3, overallMaxWinningScore + 2); monthlyChartInstance = new Chart(ctx, { type: 'bar', data: { labels: labels, datasets: [{ label: 'Winning Score', data: dataScores, backgroundColor: '#fdc500', borderColor: '#e8b700', borderWidth: 1 }] }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true, max: yAxisMax, ticks: { stepSize: 1, precision: 0 } } }, plugins: { legend: { display: false }, tooltip: { callbacks: { title: (tooltipItems) => `${utils.getFullMonthName(tooltipItems[0].dataIndex)} ${year}`, label: (context) => { const index = context.dataIndex; const result = monthlyResults[index]; let winnerLabel = (!result || result.winnerNames.length === 0) ? 'Winner: N/A' : (result.winnerNames.length === 1 ? `Winner: ${result.winnerNames[0]}` : `Tie: ${result.winnerNames.join(', ')}`); const scoreLabel = `Score: ${context.parsed.y}`; return [winnerLabel, scoreLabel]; } } }, datalabels: { display: (context) => context.dataset.data[context.dataIndex] > 0, anchor: 'end', align: 'top', offset: -2, color: '#555', font: { size: 10, weight: 'bold' }, formatter: (value, context) => { const index = context.dataIndex; const result = monthlyResults[index]; if (!result || result.winnerNames.length === 0) return ''; let name = result.winnerNames.length === 1 ? result.winnerNames[0] : 'Tie'; return name.length > 8 ? name.substring(0, 7) + '…' : name; } } } } }); } };
        const renderApp = () => { renderPlayerManagementList(); renderScoreTrackingList(); renderTodaysWinsList(); renderDashboard(); console.log("renderApp: UI rendered/updated.");};

        // --- Timer Functions ---
        const formatTimerTime = (totalSeconds) => { const minutes = Math.floor(totalSeconds / 60); const seconds = totalSeconds % 60; return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`; };
        const updateTimerDisplay = () => { if(dom.timerDisplay) dom.timerDisplay.textContent = formatTimerTime(timerRemainingSeconds); };
        const updateTimerFill = () => { if(dom.timerFill) {const percentage = (timerRemainingSeconds / TIMER_DURATION_SECONDS) * 100; dom.timerFill.style.height = `${percentage}%`; }};
        const unlockAudioContext = () => {
             // Unlock main timer audio if it's configured
            if (dom.timerAudio && dom.timerAudio.src && dom.timerAudio.readyState < 1 && currentActiveAudioPreferenceId !== AI_COMMENTATOR_ID) {
                const playPromise = dom.timerAudio.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => dom.timerAudio.pause()).catch(e => { if(e.name !== 'AbortError') console.warn("Main audio unlock failed", e);});
                }
            }
            // General unlock for dynamic audio (like TTS) by playing a silent mp3 or trying to play a dummy audio
            // This part might be redundant if the TTS functions handle their own audio context unlocking.
            // For now, we assume TTS functions will manage their playback attempts.
            if (!audioUnlocked) {
                console.log("Attempting to unlock audio context generally.");
                // Could play a very short silent audio here if needed, but often first user interaction on TTS play works.
                audioUnlocked = true; // Assume unlocked after first user interaction (like starting timer)
            }
        };

        const playStandardBeepSound = () => { if (!dom.timerAudio || !dom.timerAudio.src || currentActiveAudioPreferenceId === AI_COMMENTATOR_ID) { console.warn("Standard timer audio source not set or AI commentator active."); return; } if (!audioUnlocked) { console.warn("Audio context not unlocked, attempting to unlock for beep."); unlockAudioContext(); } if (dom.timerAudio.readyState >= 2) { dom.timerAudio.currentTime = 0; const playPromise = dom.timerAudio.play(); if (playPromise !== undefined) { playPromise.catch(error => { console.error("Timer audio playback failed:", error); audioUnlocked = false; }); } } else { console.warn(`Audio not ready (readyState: ${dom.timerAudio.readyState}). Loading.`); dom.timerAudio.load(); } };

        const timerTick = async () => {
            if (!isTimerVisible) { stopTimer(); return; }
            timerRemainingSeconds--;

            if (currentActiveAudioPreferenceId === AI_COMMENTATOR_ID &&
                timerRemainingSeconds === PRELOAD_AI_COMMENTARY_SECONDS_BEFORE_END &&
                !isLoadingAiCommentary && !aiCommentaryAudio) {
                console.log("Timer tick: Preloading AI commentary...");
                await preloadAiTimerCommentary();
            }

            if (timerRemainingSeconds < 0) {
                if (currentActiveAudioPreferenceId === AI_COMMENTATOR_ID) {
                    if (aiCommentaryAudio && aiCommentaryAudio.readyState >= HTMLMediaElement.HAVE_ENOUGH_DATA) {
                        aiCommentaryAudio.play().catch(e => {
                            console.error("Error playing preloaded AI commentary:", e);
                            playStandardBeepSound(); // Fallback
                        });
                        // REMOVED: Do not update main insight div with timer commentary
                        // if (currentTimerAiCommentaryText) {
                        //     dom.geminiInsightResultDiv.textContent = currentTimerAiCommentaryText;
                        //     toggleListenButton(true, currentTimerAiCommentaryText);
                        // }
                        aiCommentaryAudio = null; // Consumed
                        currentTimerAiCommentaryText = "";
                    } else {
                        console.warn("AI commentary audio not ready, playing fallback or fetching now.");
                        await fetchAndPlayAiTimerCommentary(true); // true to indicate it's a timer end event
                    }
                } else {
                    playStandardBeepSound();
                }
                timerRemainingSeconds = TIMER_DURATION_SECONDS;
            }
            updateTimerDisplay();
            updateTimerFill();
            timerTimeoutId = setTimeout(timerTick, 1000);
        };

        const startTimer = () => { stopTimer(); isTimerVisible = true; timerRemainingSeconds = (timerRemainingSeconds > 0 && timerRemainingSeconds <= TIMER_DURATION_SECONDS) ? timerRemainingSeconds : TIMER_DURATION_SECONDS; updateTimerDisplay(); updateTimerFill(); timerTimeoutId = setTimeout(timerTick, 1000); };
        const stopTimer = () => { if (timerTimeoutId) { clearTimeout(timerTimeoutId); timerTimeoutId = null; } isLoadingAiCommentary = false; if (aiCommentaryAudio) { aiCommentaryAudio.pause(); aiCommentaryAudio = null;} currentTimerAiCommentaryText = ""; };

        const handleNextTimerClick = async () => {
            unlockAudioContext(); // Ensure audio context is active
            stopTimer(); // Clears existing timer and any preloaded AI audio
            timerRemainingSeconds = TIMER_DURATION_SECONDS;
            updateTimerDisplay();
            updateTimerFill();

            if (currentActiveAudioPreferenceId === AI_COMMENTATOR_ID) {
                console.log("Next Click: Fetching and playing AI commentary...");
                await fetchAndPlayAiTimerCommentary(false); // false as it's a next click, not timer end
            } else {
                setTimeout(playStandardBeepSound, 50); // Small delay to ensure visual reset then sound
            }
            startTimer(); // Restart the timer sequence
        };

        // --- WAKE LOCK FUNCTIONS ---
        const requestWakeLock = async () => {
            if ('wakeLock' in navigator) {
                try {
                    wakeLockSentinel = await navigator.wakeLock.request('screen');
                    wakeLockSentinel.addEventListener('release', () => {
                        if (isTimerVisible) console.warn('Wake Lock released while timer visible.');
                        wakeLockSentinel = null;
                    });
                    console.log('Wake Lock active.');
                } catch (err) {
                    console.error(`Wake Lock Failed: ${err.name}, ${err.message}`);
                    wakeLockSentinel = null;
                }
            } else {
                console.warn('Wake Lock API not supported.');
            }
        };

        const releaseWakeLock = async () => {
            if (wakeLockSentinel) {
                await wakeLockSentinel.release();
                wakeLockSentinel = null;
                console.log('Wake Lock released.');
            }
        };
        // --- END WAKE LOCK FUNCTIONS ---


        const showTimer = async () => {
            if (isTimerVisible) return;
            unlockAudioContext();
            dom.timerOverlay.style.display = 'flex';
            dom.toggleTimerBtn.textContent = '⏱️ Hide Timer';
            await requestWakeLock(); // REQUEST WAKE LOCK
            startTimer();
        };
        
        const hideTimer = async () => {
            if (!isTimerVisible) return;
            isTimerVisible = false;
            stopTimer();
            dom.timerOverlay.style.display = 'none';
            dom.toggleTimerBtn.textContent = '⏱️ Timer';
            await releaseWakeLock(); // RELEASE WAKE LOCK
            if (dom.timerAudio) {
                dom.timerAudio.pause();
                dom.timerAudio.currentTime = 0;
            }
            if(aiCommentaryAudio) {
                aiCommentaryAudio.pause();
                aiCommentaryAudio = null;
            }
            dom.timerFill.style.height = '100%';
            timerRemainingSeconds = TIMER_DURATION_SECONDS;
            updateTimerDisplay();

            if (getStoredGeminiApiKey() && firebaseInitializedSuccessfully) {
                console.log("Timer hidden. Refreshing main Gemini insight.");
                handleGetGeminiInsight(false);
            } else if (lastLongInsightText && lastLongInsightText.trim() !== "") {
                console.log("Timer hidden. Restoring last long Gemini insight.");
                dom.geminiInsightResultDiv.textContent = lastLongInsightText;
                toggleListenButton(true, lastLongInsightText);
            } else {
                const defaultMsg = 'Enter your API Key above to get started...';
                dom.geminiInsightResultDiv.textContent = defaultMsg;
                lastLongInsightText = defaultMsg;
                toggleListenButton(false);
            }
        };

        // --- Gemini AI & TTS Insight Functions ---
        function getStoredGeminiApiKey() { return localStorage.getItem(GEMINI_API_KEY_STORAGE_KEY); }
        function storeGeminiApiKey(apiKey) { localStorage.setItem(GEMINI_API_KEY_STORAGE_KEY, apiKey); }

        function isValidInsightText(text) { if (!text) return false; const lowerText = text.toLowerCase(); const placeholders = [ 'enter your api key', 'please enter your gemini api key', 'api key is stored', 'fetching initial insight', 'conjuring witticisms', 'rethinking...', 'spicy error:', 'api key needed', 'database not connected', 'creative block', 'generating commentary...', 'loading commentary...' ]; return !placeholders.some(p => lowerText.includes(p)); }

        function toggleListenButton(show, insightText = "") { if (!dom.listenToInsightBtn) return; const canListen = show && isValidInsightText(insightText); if (canListen) { dom.listenToInsightBtn.style.display = 'inline-block'; dom.listenToInsightBtn.disabled = isSpeaking; if (!isSpeaking) { dom.listenToInsightBtn.innerHTML = '🔊 Audiable Insight!'; } } else { dom.listenToInsightBtn.style.display = 'none'; if (insightAudio && !insightAudio.paused) { insightAudio.pause(); insightAudio.currentTime = 0; } } }

        function addListenToInsightButton() { if (dom.listenToInsightBtn || !dom.geminiButtonsFlexDiv) return; const button = document.createElement('button'); button.id = 'listenToInsightBtn'; button.innerHTML = '🔊 Listen'; button.classList.add('icon-button', 'secondary'); button.style.marginLeft = '0px'; button.style.display = 'none'; dom.geminiButtonsFlexDiv.appendChild(button); dom.listenToInsightBtn = button; dom.listenToInsightBtn.addEventListener('click', async () => { if (isSpeaking) { if (insightAudio && !insightAudio.paused) { insightAudio.pause(); insightAudio.currentTime = 0; } isSpeaking = false; dom.listenToInsightBtn.innerHTML = '🔊 Listen'; dom.listenToInsightBtn.disabled = false; return; } const textToSpeak = dom.geminiInsightResultDiv.textContent; if (!isValidInsightText(textToSpeak)) { alert("No valid insight available to listen to."); toggleListenButton(false); return; } await speakTextWithGoogleTTS(textToSpeak); }); }

        async function speakTextWithGoogleTTS(textToSpeak) {
            const apiKey = getStoredGeminiApiKey();
            if (!apiKey) { alert("API Key needed for Text-to-Speech. Please enter it in the AI Insights section."); toggleListenButton(false); return; }
            if (isSpeaking) return;
            isSpeaking = true;
            dom.listenToInsightBtn.disabled = true;
            dom.listenToInsightBtn.innerHTML = '🔊 Loading...';

            const voices = [ { name: "en-US-Chirp3-HD-Achernar", gender: "FEMALE" },
                            { name: "en-US-Chirp3-HD-algenib", gender: "MALE" },
            { name: "en-US-Chirp3-HD-Aoede", gender: "FAMALE" }
     ];
            const selectedVoice = voices[Math.floor(Math.random() * voices.length)];
            const TTS_API_URL = `https://texttospeech.googleapis.com/v1/text:synthesize?key=${apiKey}`;

            try {
                const response = await fetch(TTS_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        input: { text: textToSpeak },
                        voice: { languageCode: 'en-US', name: selectedVoice.name },
                        audioConfig: { audioEncoding: 'MP3', speakingRate: 1.1, pitch: 0 }
                    })
                });
                if (!response.ok) { const errorData = await response.json(); console.error('Google TTS API Error:', errorData); let errorMessage = `TTS API Error (${response.status}): ${errorData?.error?.message || response.statusText}.`; errorMessage += " Ensure Cloud Text-to-Speech API is enabled for your key and project."; throw new Error(errorMessage); }
                const data = await response.json();
                if (data.audioContent) {
                    const audioBytes = Uint8Array.from(atob(data.audioContent), c => c.charCodeAt(0));
                    const audioBlob = new Blob([audioBytes], { type: 'audio/mp3' });
                    const audioUrl = URL.createObjectURL(audioBlob);
                    if (!insightAudio) insightAudio = new Audio();
                    insightAudio.src = audioUrl;
                    dom.listenToInsightBtn.innerHTML = '🔊 Playing...';
                    await insightAudio.play();
                    insightAudio.onended = () => { isSpeaking = false; dom.listenToInsightBtn.innerHTML = '🔊 Listen'; dom.listenToInsightBtn.disabled = false; toggleListenButton(true, textToSpeak); URL.revokeObjectURL(audioUrl); };
                    insightAudio.onerror = (e) => { console.error("Audio playback error object:", e); isSpeaking = false; dom.listenToInsightBtn.innerHTML = '🔊 Listen (Err)'; dom.listenToInsightBtn.disabled = false; toggleListenButton(true, textToSpeak); URL.revokeObjectURL(audioUrl); alert("Error during audio playback. Check console."); };
                } else { throw new Error("No audio content received from TTS API."); }
            } catch (error) { console.error('Error with TTS:', error); alert(`Could not play insight: ${error.message}`); isSpeaking = false; dom.listenToInsightBtn.innerHTML = '🔊 Listen'; dom.listenToInsightBtn.disabled = false; toggleListenButton(true, textToSpeak); }
        }

        async function synthesizeTimerCommentarySpeech(textToSpeak, playImmediately = false) {
            const apiKey = getStoredGeminiApiKey();
            if (!apiKey) { console.error("TTS Internal: API Key missing."); return null; }
            if (!textToSpeak || textToSpeak.trim() === "") { console.error("TTS Internal: No text to speak."); return null;}

            const commentatorVoices = [ { name: "en-US-Chirp3-HD-Achernar", gender: "FEMALE" },
                                       { name: "en-US-Chirp3-HD-algenib", gender: "MALE" },
                                       { name: "en-US-Chirp3-HD-Aoede", gender: "FEMALE" }];
            const selectedVoice = commentatorVoices[Math.floor(Math.random() * commentatorVoices.length)];
            const TTS_API_URL = `https://texttospeech.googleapis.com/v1/text:synthesize?key=${apiKey}`;

            try {
                const response = await fetch(TTS_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        input: { text: textToSpeak },
                        voice: { languageCode: 'en-US', name: selectedVoice.name },
                        audioConfig: { audioEncoding: 'MP3', speakingRate: 1.1, pitch: 0 }
                    })
                });
                if (!response.ok) { const errorData = await response.json(); console.error('Google TTS API Error (Timer):', errorData); throw new Error(`TTS API Error (${response.status}): ${errorData?.error?.message || response.statusText}`); }
                const data = await response.json();
                if (data.audioContent) {
                    const audioBytes = Uint8Array.from(atob(data.audioContent), c => c.charCodeAt(0));
                    const audioBlob = new Blob([audioBytes], { type: 'audio/mp3' });
                    const audioUrl = URL.createObjectURL(audioBlob);
                    const audio = new Audio(audioUrl);

                    return new Promise((resolve, reject) => {
                        audio.oncanplaythrough = () => {
                            if (playImmediately) {
                                audio.play()
                                    .then(() => {
                                        console.log("Timer commentary play initiated.");
                                        resolve(audio);
                                    })
                                    .catch(e => {
                                        console.error("Error playing timer commentary immediately:", e);
                                        URL.revokeObjectURL(audioUrl);
                                        reject(e);
                                    });
                                audio.onended = () => {
                                    console.log("Timer commentary finished playing.");
                                    URL.revokeObjectURL(audioUrl);
                                };
                            } else {
                                resolve(audio);
                            }
                        };
                        audio.onerror = (e) => {
                            console.error("Audio object error (Timer TTS):", e);
                            URL.revokeObjectURL(audioUrl);
                            reject(new Error("Failed to load/play synthesized timer audio."));
                        };
                        audio.load();
                    });
                } else { throw new Error("No audio content received from TTS API (Timer)."); }
            } catch (error) { console.error('Error with Timer TTS:', error); return Promise.reject(error); }
        }


        function updateApiKeySectionVisibility() { const storedKey = getStoredGeminiApiKey(); if (storedKey) { dom.geminiApiKeyInputGroup.classList.add('hidden'); dom.geminiApiKeyStoredInfo.classList.remove('hidden'); dom.getGeminiInsightBtn.disabled = !firebaseInitializedSuccessfully; } else { dom.geminiApiKeyInputGroup.classList.remove('hidden'); dom.geminiApiKeyStoredInfo.classList.add('hidden'); dom.geminiApiKeyInput.value = ''; dom.getGeminiInsightBtn.disabled = true; dom.geminiInsightResultDiv.textContent = 'Please enter your Gemini API Key to enable AI insights.'; lastLongInsightText = dom.geminiInsightResultDiv.textContent; toggleListenButton(false); } }

        async function fetchFromGemini(apiKey, promptText, model = "gemini-2.0-flash", generationConfigOverrides = {}) {
            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
            const defaultConfig = {
                temperature: 0.9,
                topK: 40,
                topP: 0.95,
                maxOutputTokens: 300
            };
            const finalConfig = { ...defaultConfig, ...generationConfigOverrides };

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: promptText }] }],
                        generationConfig: finalConfig
                    }),
                });
                if (!response.ok) { const errorData = await response.json(); console.error('Gemini API Error:', errorData); throw new Error(`Gemini API Error (${response.status}): ${errorData?.error?.message || response.statusText}. Ensure API is enabled and model name is correct.`); }
                const data = await response.json();
                if (data.candidates && data.candidates[0]?.content?.parts[0]?.text) { return data.candidates[0].content.parts[0].text; }
                else if (data.promptFeedback?.blockReason) { throw new Error(`Content blocked: ${data.promptFeedback.blockReason}. ${data.promptFeedback.blockReasonMessage || ''}`); }
                throw new Error('Could not extract response from Gemini.');
            } catch (error) { console.error('Error fetching from Gemini:', error); throw error; }
        }

        function prepareDataForGemini() { let dataSummary = "Rummikub Game Stats:\n"; if (players.length === 0 && firebaseInitializedSuccessfully) return dataSummary + "No players yet. It's a lonely game so far!\n"; if (!firebaseInitializedSuccessfully) return dataSummary + "Database not connected. Cannot provide stats.\n"; dataSummary += `Players: ${players.map(p => utils.sanitizeHTML(p.name)).join(', ')}\n\n`; const totalWinsByPlayer = players.map(p => ({ name: utils.sanitizeHTML(p.name), count: wins.filter(w => w.playerId === p.id).length })).sort((a, b) => b.count - a.count); dataSummary += "Overall Leaderboard (All Time):\n"; if (totalWinsByPlayer.some(p => p.count > 0)) { totalWinsByPlayer.forEach(p => dataSummary += `- ${p.name}: ${utils.pluralize(p.count, 'win')}\n`); } else { dataSummary += "- No one has won yet! The trophy is still up for grabs!\n"; } dataSummary += "\n"; const { start: currentStart, end: currentEnd } = utils.getPeriodRange(currentDashboardPeriod, currentDisplayDate); const currentPeriodWinsData = getWinsForPeriodLocal(currentDashboardPeriod, currentDisplayDate); let currentPeriodTitle = ''; switch (currentDashboardPeriod) { case 'week': currentPeriodTitle = `This Week (${currentStart.toLocaleDateString()} - ${currentEnd.toLocaleDateString()})`; break; case 'month': currentPeriodTitle = `This Month (${utils.getFullMonthName(currentDisplayDate.getMonth())} ${currentDisplayDate.getFullYear()})`; break; case 'year': currentPeriodTitle = `This Year (${currentDisplayDate.getFullYear()})`; break; } dataSummary += `Performance - ${currentPeriodTitle}:\n`; if (currentPeriodWinsData.length > 0) { const winsByPlayer = players.reduce((acc, p) => ({...acc, [p.id]: { name: utils.sanitizeHTML(p.name), count: 0 }}), {}); currentPeriodWinsData.forEach(w => { if (winsByPlayer[w.playerId]) winsByPlayer[w.playerId].count++; }); Object.values(winsByPlayer).filter(p=>p.count > 0).sort((a,b) => b.count - a.count).forEach(p => dataSummary += `- ${p.name}: ${utils.pluralize(p.count, 'win')}\n`); } else { dataSummary += `- No wins recorded in this period. Is everyone on vacation?\n`; } dataSummary += "\n"; let prevDate = new Date(currentDisplayDate); let prevPeriodTitle = ""; if (currentDashboardPeriod === 'week') { prevDate.setDate(prevDate.getDate() - 7); prevPeriodTitle = "Last Week"; } else if (currentDashboardPeriod === 'month') { prevDate.setMonth(prevDate.getMonth() - 1); prevPeriodTitle = "Last Month"; } else if (currentDashboardPeriod === 'year') { prevDate.setFullYear(prevDate.getFullYear() - 1); prevPeriodTitle = "Last Year"; } if (prevPeriodTitle) { const prevPeriodWinsData = getWinsForPeriodLocal(currentDashboardPeriod, prevDate); dataSummary += `For Comparison - ${prevPeriodTitle}:\n`; if (prevPeriodWinsData.length > 0) { const winsByPlayerPrev = players.reduce((acc, p) => ({...acc, [p.id]: { name: utils.sanitizeHTML(p.name), count: 0 }}), {}); prevPeriodWinsData.forEach(w => { if (winsByPlayerPrev[w.playerId]) winsByPlayerPrev[w.playerId].count++; }); Object.values(winsByPlayerPrev).filter(p=>p.count > 0).sort((a,b) => b.count - a.count).forEach(p => dataSummary += `- ${p.name}: ${utils.pluralize(p.count, 'win')}\n`); } else { dataSummary += `- No wins recorded in ${prevPeriodTitle}. A fresh start perhaps!\n`; } dataSummary += "\n"; } const threeDaysAgo = new Date(); threeDaysAgo.setDate(threeDaysAgo.getDate() - 2); threeDaysAgo.setHours(0,0,0,0); const recentWinsRaw = wins.filter(w => w.timestamp?.toDate() >= threeDaysAgo); if(recentWinsRaw.length > 0){ dataSummary += "Hot Streaks (Last 3 Days including Today):\n"; const recentSummary = recentWinsRaw.reduce((acc,w) => { const pName = players.find(p=>p.id === w.playerId)?.name || "An Unknown Force"; acc[utils.sanitizeHTML(pName)] = (acc[utils.sanitizeHTML(pName)] || 0) + 1; return acc; }, {}); Object.entries(recentSummary).sort(([,a],[,b]) => b-a).forEach(([name, count]) => dataSummary += `- ${name} won ${utils.pluralize(count, 'time')}\n`); } else { dataSummary += "Recent Activity: A bit quiet lately. Time to shuffle the tiles!\n" } return dataSummary; }

        async function handleGetGeminiInsight(isButtonPress = true) {
            const apiKey = dom.geminiApiKeyInput.value.trim() || getStoredGeminiApiKey();
            if (!apiKey) {
                const msg = `<span style="color:red;">API Key needed! Please enter it above.</span>`;
                dom.geminiInsightResultDiv.innerHTML = msg;
                lastLongInsightText = msg;
                updateApiKeySectionVisibility();
                toggleListenButton(false);
                return;
            }
            if (!firebaseInitializedSuccessfully) {
                const msg = `<span style="color:orange;">Database not connected. AI insights need game data.</span>`;
                dom.geminiInsightResultDiv.innerHTML = msg;
                lastLongInsightText = msg;
                toggleListenButton(false);
                return;
            }

            if (isButtonPress || !getStoredGeminiApiKey()) storeGeminiApiKey(apiKey);
            updateApiKeySectionVisibility();
            dom.getGeminiInsightBtn.disabled = true;
            dom.getGeminiInsightBtn.textContent = 'Rethinking... 😂';
            if (isSpeaking && insightAudio) { insightAudio.pause(); insightAudio.currentTime = 0; isSpeaking = false; }
            toggleListenButton(false);

            const loadingMsg = isButtonPress ? 'Conjuring witticisms... 🧠' : 'Fetching initial insight... 🧠';
            dom.geminiInsightResultDiv.innerHTML = loadingMsg;

            const gameDataSummary = prepareDataForGemini();
            const promptForLongInsight = `
            **Primary Directive: Your ONLY output will be 1-3 senteces of text. No preambles, no explanations, no apologies, nothing but the commentary itself.**
You are a witty, observant, and slightly sarcastic Rummikub game commentator with a knack for comedic timing. Your audience loves your playful jabs and insightful, humorous takes. Your commentary should sound like a friend chatting excitedly, sometimes conspiratorially, with another friend about the game.

Based on the Rummikub game stats below, provide a funny and insightful commentary. 
CRITITAL: use Rummi only instead of the entire RUMMIKUB word.

**Your Comedic Style & Delivery (for Text Generation):**
*   Natural & Conversational: Write like you're speaking directly to a friend. Use informal language, contractions, and a relaxed tone. Think stand-up comedian observing the game.
*   Punctuation for Nuance & Pacing:
    *   Pauses: Use ellipses (...) strategically for comedic effect, to indicate a thought trailing off, or a moment of mock disbelief. Short, punchy sentences or even well-placed sentence fragments can also create natural pauses.
    *   Excitement & Exclamation: Don't be shy with exclamation points! If a point is particularly surprising or funny, let it show! Occasionally, you might even use ALL CAPS for a *single* word or very short phrase if you want to convey shouting or extreme emphasis (e.g., "NO WAY!").
    *   Wondering & Sarcasm: Use question marks to pose rhetorical questions or express mock wonder. Sarcasm can be conveyed through word choice and by stating something that's clearly a bit absurd given the context (e.g., "Oh, Player X is just being *generous* this month with those scores, right?").
*   Show, Don't Just Tell Emotion:
    *   Instead of writing "(laughs)", craft a line that is genuinely funny or highlights an absurd situation that would make someone chuckle. For example, "Player Y's tile rack must be looking like a abstract art project with those moves... or maybe it's avant-garde?"
    *   For excitement, use vivid adjectives and verbs.
*   Playful Teasing & Comparisons:
    *   Gently tease players. Who's dominating this month vs. last? Who's on an undeniable hot streak (or a hilarious cold one)? Is anyone surprisingly ahead overall, or perhaps their recent performance is... let's say, *unexpected*?
    *   Celebrate or gently mock streaks and the competitive spirit.
    *   If someone has won today, definitely add some comments about it specially if they're catching up to someone else or 2 players are too close to each other.
*   Humor Techniques: Employ puns (if they're clever!), witty observations, and a generally amusing and light-hearted tone.
*   Sparse Data Joke: If data is sparse, lean into it: "Well, the scoreboard's looking a bit minimalist this period. Are we going for a 'less is more' vibe, or did someone hide the good tiles?"

**Content Specifics:**
*   Ensure your commentary flows well, even when transitioning between players. No bullet points in the final output.
*   **Mountain Biking Banter (Conditional):** For players JB and Mike (both guys), who enjoy mountain biking, feel free to randomly sprinkle in a funny, short mountain biking-related quip or comparison if it fits the commentary. Sometimes include it, sometimes don't – keep it surprising! (e.g., "Looks like JB's navigating the leaderboard like a technical downhill course this month!" or "Mike's scores are climbing steadier than a granny gear on a steep ascent! Meanwhile...")
*   **Mention Every Player:** Critically, every player active in the \`gameDataSummary\` must be mentioned in your commentary, even if it's a brief, witty aside.
*   Use overall stats or trends but focus on the stats mainly display like mfor this month, week, or year, but be funny and sarcastic about it that are genuinly funny.
*   Info about players: They've known each other for a good part of 5 years, live nearby. Jovany and Rosie (Mexican, 2 kids), Beatriz and Mike (Filipino-American, 2 kids). Neighbors: one nosy family, another nosy neighbor, mean HOA president. Ongoing drama with a neighbor (domestic violence, mental health - make fun LIGHTLY and CAREFULLY, if at all, focusing on absurdity rather than malice). Main players do outings (dinners, museums, parks, camping), discuss family issues (Rosie & Beatriz). Use this info LIGHTLY, RANDOMLY, and FUNNILY.
*   Focus on the gameDataSummary provided.

**Examples (Illustrating Tone & Punctuation for Nuance for LONGER insights):**
*   "Okay, so Player X is CLEARLY channeling some kind of Rummikub wizard this week... leaving everyone else wondering if their tiles are just decorative. And Player Y? Their lucky streak from last month seems to have... well, taken an extended vacation, shall we say?"
*   "Player Z is playing the long game, folks! Sneaking up that overall leaderboard while everyone's distracted by the weekly fireworks. Clever, Z, very clever... or just very patient?"

**Game Data:**
${gameDataSummary}
`;
            try {
                const insight = await fetchFromGemini(apiKey, promptForLongInsight, "gemini-2.0-flash");
                const finalInsightText = insight.trim();
                dom.geminiInsightResultDiv.textContent = finalInsightText;
                lastLongInsightText = finalInsightText;
                toggleListenButton(true, finalInsightText);
            } catch (error) {
                const errorMsg = `<span style="color:red;">Spicy Error: ${utils.sanitizeHTML(error.message)}</span> <br>Maybe the AI is on a coffee break? Check API key & console.`;
                dom.geminiInsightResultDiv.innerHTML = errorMsg;
                lastLongInsightText = errorMsg;
                toggleListenButton(false);
            }
            finally {
                dom.getGeminiInsightBtn.disabled = false;
                dom.getGeminiInsightBtn.textContent = 'Get New Funny Insight 😂';
            }
        }

        function getAiTimerCommentaryPromptText(gameDataSummary) {
            return `
**Primary Directive: Your ONLY output will be ONE (1) single line of text. No preambles, no explanations, no apologies, nothing but the commentary itself.**
**Secondary Directive: Never prefrence one single player. Randomize the punch line and the players.
You are a witty, observant, and heavily sarcastic and heavy humoristic Rummikub game commentator for a timer with a knack for short, punchy lines. Your audience loves your playful jabs and insightful, humorous takes delivered quickly.
Based on the Rummikub game stats below, provide a funny and insightful commentary. Also, make more generic punch lines to point out that it's the next player's turn.
CRITICAL: Your response MUST be 10-15 words ONLY. This is for a quick audio alert. This is for text-to-speech google API for Chirp3-HD voices so format it so it sounds natural with nuances and expressions.
CRITICAL: DO NOT always mentioned the top players with wins, also focus on those with low scores. Mix it up. Also, use "Rummi", NEVER use the full word rummikub.
CRITICAL: Use slang and heavy and light humor in jokes. Any player could be the next player (hard to tell).
CRITICAL: JOVANY is said "Jovaaany" so spell it like that with emphasis in VAh. Mike is said Mike. Beatriz is spelled Be-aa-triz. Rosie is spell the same, Rosie.
CRITICAL: Talk shit to the players. Be aggressive in the jokes.

Your Comedic Style & Delivery (for Text Generation):
- Punctuation for Pacing: Use ellipses (...), exclamation points (!) sparingly.
- Humor: Witty observations, playful but also hard teasing, scores or trends, or sarcastic comments. Mock heavily.
- Player Mentions: If possible, briefly allude to a player's performance or not performing.
- Mountain Biking Banter (Conditional, for Jovany/Mike): "Jovanys climbing again!" or "Mike's on a roll... downhill?"
- Focus: Recent stats (current period, hot streaks from Game Data).
- If data is sparse (from Game Data): "Scoreboard's quiet... too quiet." or "Anyone playing today?"

Examples (Illustrating 10-15 word count and tone):
CRITICAL: Do not always use the top scorers, you can use also low scorers. Audience likes a good chuckle so mock every just alike.
"Wow, [PlayerX] is UNSTOPPABLE today!"
"[PlayerY]... a tactical retreat, perhaps?"
"[PlayerY] come on man. Try harder just like you try biking!"
"[PlayerX] still pedaling to victory!"
"[playerx] cooking up another win!"
"[playery].. masterclass in progress!"
"Everyone's so quiet... planning something?"
"Next up! Who's feeling lucky?"
"Come on Ni-gg-aa"

CRITICAL: You can use other punch items like the ones below mixed with player stats mentioned earlier in ONE SINGLE PUNCH LINE:
"Hey hey, don't be sad, we know who will win"
"time is up, seriously, just stop"
"you got 60 seconds left, not like it matters"
"who will be the winner this time? You know who!"

**FINAL, ABSOLUTE INSTRUCTION: Your entire response MUST be just ONE single line of commentary. Nothing before it, nothing after it. Just the line.**

Game Data:
${gameDataSummary}
`;
        }

        async function preloadAiTimerCommentary() {
            if (isLoadingAiCommentary || !firebaseInitializedSuccessfully) return;
            const apiKey = getStoredGeminiApiKey();
            if (!apiKey) { console.warn("AI Timer: API Key missing for preloading."); return; }

            isLoadingAiCommentary = true;
            console.log("Preloading AI timer commentary...");
            try {
                const gameDataSummary = prepareDataForGemini();
                const promptText = getAiTimerCommentaryPromptText(gameDataSummary);
                const commentaryText = await fetchFromGemini(apiKey, promptText, "gemini-2.0-flash", { maxOutputTokens: 100 });

                if (commentaryText && commentaryText.trim() !== "") {
                    currentTimerAiCommentaryText = commentaryText.trim();
                    console.log("AI Timer Text (preload):", currentTimerAiCommentaryText);
                    aiCommentaryAudio = await synthesizeTimerCommentarySpeech(currentTimerAiCommentaryText, false); 
                    if(aiCommentaryAudio) console.log("AI Timer Audio preloaded.");
                    else console.warn("AI Timer Audio preloading failed (no audio object).");
                } else {
                    console.warn("AI Timer: Gemini returned empty text for commentary.");
                    currentTimerAiCommentaryText = "";
                }
            } catch (error) {
                console.error("Error preloading AI timer commentary:", error);
                aiCommentaryAudio = null;
                currentTimerAiCommentaryText = "";
            } finally {
                isLoadingAiCommentary = false;
            }
        }

        async function fetchAndPlayAiTimerCommentary(isTimerEndEvent = false) {
            if (!firebaseInitializedSuccessfully) return;
            const apiKey = getStoredGeminiApiKey();
            if (!apiKey) { console.warn("AI Timer: API Key missing for fetch and play."); if (isTimerEndEvent) playStandardBeepSound(); return; }

            isLoadingAiCommentary = true;
            try {
                const gameDataSummary = prepareDataForGemini();
                const promptText = getAiTimerCommentaryPromptText(gameDataSummary);
                const commentaryText = await fetchFromGemini(apiKey, promptText, "gemini-2.0-flash", { maxOutputTokens: 100 });

                if (commentaryText && commentaryText.trim() !== "") {
                    currentTimerAiCommentaryText = commentaryText.trim();
                    console.log("AI Timer Text (fetch/play):", currentTimerAiCommentaryText);
                    await synthesizeTimerCommentarySpeech(currentTimerAiCommentaryText, true);
                } else {
                    console.warn("AI Timer: Gemini returned empty text. Playing fallback.");
                    if (isTimerEndEvent) playStandardBeepSound();
                }
            } catch (error) {
                console.error("Error fetching and playing AI timer commentary:", error);
                if (isTimerEndEvent) playStandardBeepSound();
            } finally {
                isLoadingAiCommentary = false;
                if (!isTimerEndEvent) {
                    currentTimerAiCommentaryText = "";
                }
            }
        }


        // --- Event Listeners ---
        dom.togglePlayerManagementBtn.addEventListener('click', () => { dom.playerManagementSection.classList.toggle('hidden'); const i = dom.playerManagementSection.classList.contains('hidden'); dom.togglePlayerManagementBtn.textContent = i ? '⚙️ Manage' : '🔽 Close'; });
        dom.addPlayerBtn.addEventListener('click', () => addPlayer(dom.newPlayerNameInput.value));
        dom.newPlayerNameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') { e.preventDefault(); addPlayer(dom.newPlayerNameInput.value); } dom.addPlayerError.textContent = ""; });
        dom.playerListManagementUl.addEventListener('click', (e) => { const t = e.target; const pE = t.closest('.player-management-entry'); if (!pE) return; const pId = pE.dataset.playerId; if (t.classList.contains('delete-player-btn')) { deletePlayer(pId); } else if (t.classList.contains('rename-btn')) { dom.playerListManagementUl.querySelectorAll('.rename-controls:not(.hidden)').forEach(c => { const en = c.closest('.player-management-entry'); if (en && en !== pE) { en.querySelector('.rename-controls').classList.add('hidden'); en.querySelector('.player-name-display').classList.remove('hidden'); en.querySelector('.action-buttons').classList.remove('hidden'); } }); pE.querySelector('.player-name-display').classList.add('hidden'); pE.querySelector('.action-buttons').classList.add('hidden'); const rC = pE.querySelector('.rename-controls'); rC.classList.remove('hidden'); rC.querySelector('.rename-input').focus(); } else if (t.classList.contains('save-rename-btn')) { renamePlayer(pId, pE.querySelector('.rename-input').value); } else if (t.classList.contains('cancel-rename-btn')) { pE.querySelector('.rename-input').value = pE.querySelector('.player-name-display').textContent; pE.querySelector('.rename-controls').classList.add('hidden'); pE.querySelector('.player-name-display').classList.remove('hidden'); pE.querySelector('.action-buttons').classList.remove('hidden'); } });
        dom.playerListManagementUl.addEventListener('keypress', (e) => { if (e.key === 'Enter' && e.target.classList.contains('rename-input')) { e.preventDefault(); renamePlayer(e.target.closest('.player-management-entry').dataset.playerId, e.target.value); } });
        dom.scoreTrackingListUl.addEventListener('click', (e) => { if (e.target.classList.contains('add-win-btn') && !e.target.disabled) recordWin(e.target.dataset.playerId); });
        dom.todaysWinsListUl.addEventListener('click', (e) => { if (e.target.classList.contains('delete-win-btn') && !e.target.disabled) { const wL = e.target.closest('li'); if (wL?.dataset.winId) deleteWin(wL.dataset.winId); } });
        dom.dashboardControls.addEventListener('click', (e) => { if (e.target.tagName === 'BUTTON' && e.target.dataset.period) { currentDisplayDate = new Date(); currentDashboardPeriod = e.target.dataset.period; currentView = 'player'; renderDashboard(); if (getStoredGeminiApiKey() && firebaseInitializedSuccessfully) handleGetGeminiInsight(false); } });
        dom.playerViewBtn.addEventListener('click', () => { if (currentView !== 'player') { currentView = 'player'; renderDashboard(); } });
        dom.monthlyViewBtn.addEventListener('click', () => { if (currentView !== 'monthly') { currentView = 'monthly'; renderDashboard(); } });
        dom.prevPeriodBtn.addEventListener('click', () => { if (currentDashboardPeriod === 'week') currentDisplayDate.setDate(currentDisplayDate.getDate() - 7); else if (currentDashboardPeriod === 'month') currentDisplayDate.setMonth(currentDisplayDate.getMonth() - 1); else if (currentDashboardPeriod === 'year') currentDisplayDate.setFullYear(currentDisplayDate.getFullYear() - 1); renderDashboard(); if (getStoredGeminiApiKey() && firebaseInitializedSuccessfully) handleGetGeminiInsight(false); });
        dom.nextPeriodBtn.addEventListener('click', () => { let allowNav = true; const tempDate = new Date(currentDisplayDate); if (currentDashboardPeriod === 'week') tempDate.setDate(tempDate.getDate() + 7); else if (currentDashboardPeriod === 'month') tempDate.setMonth(tempDate.getMonth() + 1); else if (currentDashboardPeriod === 'year') tempDate.setFullYear(tempDate.getFullYear() + 1); const today = new Date(); if (tempDate.getFullYear() > today.getFullYear() || (tempDate.getFullYear() === today.getFullYear() && (currentDashboardPeriod === 'month' ? tempDate.getMonth() > today.getMonth() : false)) || (currentDashboardPeriod === 'week' && tempDate > today) ) { allowNav = false; } if(allowNav) { currentDisplayDate = tempDate; renderDashboard(); if (getStoredGeminiApiKey() && firebaseInitializedSuccessfully) handleGetGeminiInsight(false); } else { dom.nextPeriodBtn.disabled = true;} });
        dom.prevYearBtn.addEventListener('click', () => { currentDisplayDate.setFullYear(currentDisplayDate.getFullYear() - 1); renderDashboard(); if (getStoredGeminiApiKey() && firebaseInitializedSuccessfully) handleGetGeminiInsight(false); });
        dom.nextYearBtn.addEventListener('click', () => { if (currentDisplayDate.getFullYear() + 1 <= new Date().getFullYear()) { currentDisplayDate.setFullYear(currentDisplayDate.getFullYear() + 1); renderDashboard(); if (getStoredGeminiApiKey() && firebaseInitializedSuccessfully) handleGetGeminiInsight(false); } else { dom.nextYearBtn.disabled = true; } });
        dom.toggleTimerBtn.addEventListener('click', () => { if (isTimerVisible) hideTimer(); else showTimer(); });
        dom.hideTimerBtn.addEventListener('click', hideTimer);
        dom.nextTimerBtn.addEventListener('click', handleNextTimerClick);
        dom.audioSourceSelect.addEventListener('change', async () => { const selectedValue = dom.audioSourceSelect.value; dom.audioUrlStatus.innerHTML = ""; if (selectedValue !== "custom_new") { await applyAudioChoice(selectedValue); } else { const activePrefName = currentActiveAudioPreferenceId === AI_COMMENTATOR_ID ? "✨ AI Comedic Commentator" : (audioPreferences.find(p => p.id === currentActiveAudioPreferenceId)?.name || "Default Sound"); dom.audioUrlStatus.innerHTML = `<span class="info">Currently using: ${utils.sanitizeHTML(activePrefName)}</span>`; } updateCustomAudioUI(); });
        dom.saveCustomAudioBtn.addEventListener('click', async () => { if (!firebaseInitializedSuccessfully) {alert("Database not connected. Cannot save audio."); return;} const shortName = dom.customAudioShortNameInput.value.trim(); let customUrl = dom.customAudioUrlInput.value.trim(); dom.audioUrlStatus.innerHTML = ""; if (!shortName) { dom.audioUrlStatus.innerHTML = '<span class="error">Short Name is required.</span>'; dom.customAudioShortNameInput.focus(); return; } if (!customUrl) { dom.audioUrlStatus.innerHTML = '<span class="error">Audio URL cannot be empty.</span>'; dom.customAudioUrlInput.focus(); return; } try { new URL(customUrl); } catch (e) { dom.audioUrlStatus.innerHTML = '<span class="error">Invalid URL format.</span>'; dom.customAudioUrlInput.focus(); return; } if (customUrl.includes("dropbox.com/")) { const originalUrl = customUrl; customUrl = customUrl.replace(/([?&])dl=0(&|$)/, '$1dl=1$2'); if (customUrl !== originalUrl) { console.log("Corrected Dropbox URL from:", originalUrl, "to:", customUrl); } } dom.saveCustomAudioBtn.disabled = true; dom.saveCustomAudioBtn.textContent = "Saving..."; const newPref = await saveAudioPreferenceToFirebase(shortName, customUrl); if (newPref) { await applyAudioChoice(newPref.id); populateAudioSourceSelect(); updateCustomAudioUI(); dom.audioUrlStatus.innerHTML = `<span class="success">Sound "${utils.sanitizeHTML(newPref.name)}" saved. </span>` + dom.audioUrlStatus.innerHTML; } else { if (dom.audioSourceSelect.value === "custom_new") { dom.saveCustomAudioBtn.textContent = "Save & Use This Sound"; } } dom.saveCustomAudioBtn.disabled = false; if (dom.audioSourceSelect.value !== "custom_new") { dom.saveCustomAudioBtn.textContent = "Save & Use This Sound"; } });
        dom.removeFavoriteBtn.addEventListener('click', async () => { if (!firebaseInitializedSuccessfully) {alert("Database not connected. Cannot remove audio."); return;} const prefIdToRemove = dom.audioSourceSelect.value; if (prefIdToRemove === "default" || prefIdToRemove === "custom_new" || prefIdToRemove === AI_COMMENTATOR_ID) return; const prefToRemove = audioPreferences.find(p => p.id === prefIdToRemove); if (!prefToRemove) { console.warn("Could not find preference to remove:", prefIdToRemove); return; } if (!confirm(`Are you sure you want to remove the sound "${utils.sanitizeHTML(prefToRemove.name)}"?`)) { return; } dom.removeFavoriteBtn.disabled = true; dom.removeFavoriteBtn.textContent = "Removing..."; let previousStatus = dom.audioUrlStatus.innerHTML; try { await deleteDoc(doc(db, AUDIO_PREFERENCES_COLLECTION, prefIdToRemove)); audioPreferences = audioPreferences.filter(p => p.id !== prefIdToRemove); let newActiveId = currentActiveAudioPreferenceId; if (currentActiveAudioPreferenceId === prefIdToRemove) { newActiveId = "default"; } await applyAudioChoice(newActiveId); populateAudioSourceSelect(); updateCustomAudioUI(); dom.audioUrlStatus.innerHTML = `<span class="success">Removed "${utils.sanitizeHTML(prefToRemove.name)}". </span>` + dom.audioUrlStatus.innerHTML; } catch (error) { console.error("Error removing audio preference:", error); dom.audioUrlStatus.innerHTML = `<span class="error">Failed to remove sound: ${error.message}</span>` + previousStatus; } finally { dom.removeFavoriteBtn.disabled = false; dom.removeFavoriteBtn.textContent = "Remove Selected Sound"; } });
        dom.geminiApiKeyInput.addEventListener('change', () => { const apiKey = dom.geminiApiKeyInput.value.trim(); if (apiKey) { storeGeminiApiKey(apiKey); updateApiKeySectionVisibility(); if (firebaseInitializedSuccessfully) handleGetGeminiInsight(false); } });
        dom.changeApiKeyBtn.addEventListener('click', () => { localStorage.removeItem(GEMINI_API_KEY_STORAGE_KEY); updateApiKeySectionVisibility(); dom.geminiApiKeyInput.focus(); });
        dom.getGeminiInsightBtn.addEventListener('click', () => handleGetGeminiInsight(true));
        document.addEventListener('visibilitychange', async () => { // WAKE LOCK RELATED
            if (document.visibilityState === 'visible') {
                if (isTimerVisible && !wakeLockSentinel) {
                     await requestWakeLock(); // If timer is on and lock was lost, re-request
                }
                if (isTimerVisible || audioUnlocked) unlockAudioContext();
            }
        });

        // --- Initialization (IIFE) ---
        (async () => {
            console.log("App initialization started.");
            addListenToInsightButton();
            lastLongInsightText = dom.geminiInsightResultDiv.textContent;

            try {
                if (!firebaseConfig.apiKey || firebaseConfig.apiKey.includes("YOUR_") || firebaseConfig.apiKey.includes("Replace!") || !firebaseConfig.projectId || firebaseConfig.projectId.includes("YOUR_") || firebaseConfig.projectId.includes("Replace!")) {
                    dom.firebaseConfigWarningDiv.innerHTML = '<strong>Firebase Setup: CRITICAL!</strong> Please replace placeholder values in `firebaseConfig` (like YOUR_API_KEY, YOUR_PROJECT_ID) with your actual Firebase project configuration. Stats will not load without this.';
                    dom.firebaseConfigWarningDiv.style.backgroundColor = '#f8d7da';
                    console.error("Firebase config contains placeholder values. Halting Firebase initialization.");
                } else {
                    app = initializeApp(firebaseConfig);
                    db = getFirestore(app);
                    firebaseInitializedSuccessfully = true;
                    dom.firebaseConfigWarningDiv.style.display = 'none';
                    console.log("Firebase initialized successfully.");
                }
            } catch (error) {
                console.error("Firebase Initialization Error:", error);
                if (dom.firebaseErrorDiv) { dom.firebaseErrorMessageSpan.textContent = `Firebase Init Error: ${error.message}. Check console, ensure config is correct & Firebase services (Firestore API) are enabled in Google Cloud.`; dom.firebaseErrorDiv.style.display = 'block'; }
                dom.firebaseConfigWarningDiv.innerHTML = '<strong>Firebase Initialization Failed!</strong> Check console for details.';
                dom.firebaseConfigWarningDiv.style.backgroundColor = '#f8d7da';
            }

            if (typeof Chart !== 'undefined' && typeof ChartDataLabels !== 'undefined') { Chart.register(ChartDataLabels); console.log("Chart.js and Datalabels registered."); }
            else { console.warn("Chart or ChartDataLabels not fully loaded. Datalabels might not work."); }

            currentView = 'player';
            currentDashboardPeriod = 'month';
            currentDisplayDate = new Date();
            updateApiKeySectionVisibility();
            updateTimerDisplay();

            if (firebaseInitializedSuccessfully) {
                console.log("Proceeding with Firebase-dependent setup.");
                try {
                    await loadAudioPreferencesFromFirebase();
                    currentActiveAudioPreferenceId = await getActiveAudioPreferenceIdFromFirebase();
                    populateAudioSourceSelect();
                    await applyAudioChoice(currentActiveAudioPreferenceId);
                    updateCustomAudioUI();
                    console.log("Audio preferences loaded.");
                    await loadData();
                    console.log("Game data loading initiated (players, wins).");
                    if (getStoredGeminiApiKey()) {
                        console.log("Attempting to fetch initial Gemini insight.");
                        handleGetGeminiInsight(false);
                    } else {
                        toggleListenButton(false);
                        dom.getGeminiInsightBtn.disabled = true;
                    }
                } catch (error) {
                    console.error("Error during Firebase-dependent setup (audio/data/gemini):", error);
                    renderApp();
                    const errorMsg = "Error loading app data. Check console.";
                    dom.noPlayersForScoringMsg.textContent = errorMsg;
                    dom.noPlayersForScoringMsg.classList.remove('hidden');
                    dom.geminiInsightResultDiv.textContent = errorMsg;
                    lastLongInsightText = errorMsg;
                    toggleListenButton(false);
                }
            } else {
                console.warn("Firebase not initialized. Skipping Firebase-dependent setup.");
                populateAudioSourceSelect();
                applyAudioChoice("default");
                updateCustomAudioUI();
                renderApp();
                dom.noPlayersForScoringMsg.textContent = "Database connection failed. Cannot load players.";
                dom.noPlayersForScoringMsg.classList.remove('hidden');
                dom.noWinsTodayMsg.textContent = "Database connection failed.Cannot load wins.";
                dom.noWinsTodayMsg.classList.remove('hidden');
                if(dom.scoreTrackingListUl) dom.scoreTrackingListUl.innerHTML = '<p class="no-data">Score tracking unavailable (database error).</p>';

                const noDbMsg = 'Database connection failed. AI insights require game data.';
                if (!getStoredGeminiApiKey()) {
                    const noKeyMsg = 'Please enter your Gemini API Key. AI features also require database connection.';
                    dom.geminiInsightResultDiv.textContent = noKeyMsg;
                    lastLongInsightText = noKeyMsg;
                } else {
                    dom.geminiInsightResultDiv.textContent = noDbMsg;
                    lastLongInsightText = noDbMsg;
                }
                toggleListenButton(false);
                dom.getGeminiInsightBtn.disabled = true;
            }
            console.log("App initialization finished.");
        })();
    </script>
</body>
</html>
