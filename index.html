<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rummikub Win Tracker</title>
    <!-- 1. Include Chart.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- 2. Include Chart.js Datalabels Plugin (AFTER Chart.js) -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <style>
        /* --- Basic Reset & Defaults --- */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; background-color: #f4f7f6; color: #333; padding-bottom: 50px; }
        .app-container { max-width: 600px; margin: 0 auto; padding: 15px; }
        /* --- Typography --- */
        h1, h2, h3 { margin-bottom: 0.8em; color: #0b4f6c; }
        h1 { text-align: center; margin-bottom: 1em; color: #012a4a; }
        p { margin-bottom: 1em; }
        /* --- Buttons --- */
        button { display: inline-block; padding: 10px 18px; font-size: 1rem; font-weight: bold; color: #fff; background-color: #219ebc; border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.2s ease; min-height: 44px; vertical-align: middle; }
        button:hover, button:focus { background-color: #1a7f9a; outline: none; }
        button:disabled { background-color: #adb5bd; cursor: not-allowed; }
        button.secondary { background-color: #6c757d; }
        button.secondary:hover, button.secondary:focus { background-color: #5a6268; }
        button.danger { background-color: #e76f51; }
        button.danger:hover, button.danger:focus { background-color: #d95a3a; }
        button.icon-button { padding: 8px 10px; font-size: 0.9rem; margin-left: 5px; }
        button.small-nav-button { padding: 5px 10px; font-size: 0.9rem; min-height: 30px; margin: 0 5px; }
        /* --- Forms --- */
        input[type="text"] { width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 1rem; }
        /* --- Layout Sections --- */
        section { background-color: #fff; padding: 15px; margin-bottom: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); }
        /* --- Header & Player Management Toggle --- */
        header { margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; }
        header h1 { margin-bottom: 0; flex-grow: 1; text-align: left; }
        #togglePlayerManagement { flex-shrink: 0; }
        /* --- Player Management Section --- */
        #playerManagement { border: 1px dashed #ccc; }
        #playerManagement.hidden { display: none; }
        .player-management-entry { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #eee; }
        .player-management-entry:last-child { border-bottom: none; }
        .player-management-entry span { flex-grow: 1; margin-right: 10px; }
        .rename-controls { display: flex; align-items: center; }
        .rename-controls input { width: 120px; margin-bottom: 0; margin-right: 5px; font-size: 0.9rem; padding: 5px 8px; }
        /* --- Score Tracking Section --- */
        #scoreTrackingList li, #todaysWinsList li { display: flex; justify-content: space-between; align-items: center; padding: 12px 5px; border-bottom: 1px solid #eee; }
        #scoreTrackingList li:last-child, #todaysWinsList li:last-child { border-bottom: none; }
        .player-name { font-weight: bold; margin-right: 10px; flex-grow: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .win-timestamp { font-size: 0.85em; color: #666; margin-left: 10px; margin-right: 10px; white-space: nowrap; }
        /* --- Dashboard --- */
        .dashboard-controls { display: flex; justify-content: space-around; margin-bottom: 15px; flex-wrap: wrap; }
        .dashboard-controls button { flex-grow: 1; margin: 5px; background-color: #f8f9fa; color: #0b4f6c; border: 1px solid #dee2e6; }
        .dashboard-controls button.active { background-color: #0b4f6c; color: #fff; font-weight: bold; border-color: #0b4f6c; }
        .dashboard-view-toggle { text-align: center; margin-bottom: 15px; }
        .chart-title-container { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .chart-title-container h3 { margin-bottom: 0; text-align: center; flex-grow: 1; color: #333; font-weight: bold; }
        #winChartContainer, #monthlyChartContainer { background-color: #f8f9fa; padding: 20px 10px 10px 10px; border-radius: 5px; min-height: 320px; position: relative; }
        #chart, #monthlyChart { position: relative; height: 270px; width: 100%; }
        canvas.hidden { display: none; }
        /* --- Utility Classes --- */
        .hidden { display: none !important; }
        .text-center { text-align: center; }
        .error-message { color: #d95a3a; font-size: 0.9em; margin-top: -5px; margin-bottom: 10px; }
        .no-data { color: #6c757d; text-align: center; padding: 20px; font-style: italic; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 90%; }
        /* --- List Styling --- */
        ul { list-style: none; padding: 0; }
    </style>
</head>
<body>

    <div class="app-container">
        <header>
            <h1>Rummikub Wins</h1>
            <button id="togglePlayerManagement" class="secondary icon-button" aria-label="Manage Players" title="Manage Players">‚öôÔ∏è Manage</button>
        </header>

        <!-- Player Management Section -->
        <section id="playerManagement" class="hidden">
            <h3>Manage Players</h3>
            <div id="addPlayerForm">
                <input type="text" id="newPlayerName" placeholder="New Player Name">
                <button id="addPlayerBtn">Add Player</button>
                <div id="addPlayerError" class="error-message"></div>
            </div>
            <ul id="playerListManagement"></ul>
             <p id="noPlayersManaged" class="no-data hidden">No players added yet.</p>
        </section>

        <!-- Dashboard / Statistics Section -->
        <section id="dashboard">
            <h2>Dashboard</h2>
            <div class="dashboard-controls">
                <button data-period="week" class="active">This Week</button>
                <button data-period="month">This Month</button>
                <button data-period="year">This Year</button>
            </div>
            <div class="dashboard-view-toggle">
                 <button id="playerViewBtn" class="secondary small-nav-button active">Player Wins</button>
                 <button id="monthlyViewBtn" class="secondary small-nav-button">Monthly Breakdown</button>
            </div>

            <!-- Player Wins Chart (Default View) -->
            <div id="winChartContainer">
                 <div class="chart-title-container">
                     <button id="prevPeriodBtn" class="secondary small-nav-button hidden" aria-label="Previous Period">‚¨ÖÔ∏è Prev</button>
                     <h3 id="winChartTitle">Wins This Week</h3>
                     <button id="nextPeriodBtn" class="secondary small-nav-button hidden" aria-label="Next Period">Next ‚û°Ô∏è</button>
                 </div>
                 <div id="chart">
                     <canvas id="playerWinCanvas"></canvas>
                 </div>
                 <p id="noChartData" class="no-data hidden">No wins recorded for this period.</p>
            </div>

            <!-- Monthly Breakdown Chart (Initially Hidden) -->
            <div id="monthlyChartContainer" class="hidden">
                 <div class="chart-title-container">
                     <button id="prevYearBtn" class="secondary small-nav-button" aria-label="Previous Year">‚¨ÖÔ∏è Prev Yr</button>
                     <h3 id="monthlyChartTitle">Monthly Winners for 2023</h3>
                     <button id="nextYearBtn" class="secondary small-nav-button" aria-label="Next Year">Next Yr ‚û°Ô∏è</button>
                 </div>
                 <div id="monthlyChart">
                      <canvas id="monthlyWinsCanvas"></canvas>
                 </div>
                 <p id="noMonthlyChartData" class="no-data hidden">No wins recorded for this year.</p>
            </div>
        </section>

        <!-- Score Tracking Interface -->
        <section id="scoreTracking">
            <h2>Today's Wins</h2>
            <ul id="scoreTrackingList"></ul>
             <p id="noPlayersForScoring" class="no-data hidden">Add players in 'Manage Players' to track wins.</p>
        </section>

        <!-- Today's Recorded Wins Management -->
        <section id="todaysWins">
             <h3>Recorded Today (<span id="todayDateDisplay"></span>)</h3>
             <ul id="todaysWinsList"></ul>
             <p id="noWinsToday" class="no-data">No wins recorded yet today.</p>
        </section>

        <!-- Firebase Placeholders -->
        <div id="firebaseConfigWarning" style="padding: 10px; margin-top: 20px; background-color: #fff3cd; border: 1px solid #ffeeba; border-radius: 5px; font-size: 0.9em;">
            <strong>Firebase Setup:</strong> Ensure the `firebaseConfig` in the JavaScript below is correct...
        </div>
        <div id="firebaseError" style="display: none; padding: 10px; margin-top: 10px; background-color: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; border-radius: 5px; font-size: 0.9em;">
             <strong>Firebase Error:</strong> <span id="firebaseErrorMessage"></span>
        </div>

    </div><!-- /app-container -->

    <script type="module">

        // --- Firebase SDK Imports ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getFirestore, collection, getDocs, addDoc, deleteDoc, updateDoc, doc, query, where, orderBy, Timestamp, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";

        // --- Firebase Configuration (Replace with your actual config!) ---
        const firebaseConfig = {
  apiKey: "AIzaSyD-e3H5CaoQobBqFwzDnCGZCUbniZQg_J0",
  authDomain: "i-am-awesome-tasker.firebaseapp.com",
  projectId: "i-am-awesome-tasker",
  storageBucket: "i-am-awesome-tasker.firebasestorage.app",
  messagingSenderId: "853316153385",
  appId: "1:853316153385:web:db1fc1304b54a198a82c38",
  measurementId: "G-ZDBF73CFXS"
};

        // --- Firebase Initialization ---
        let app, db;
        try { /* ... same init ... */ app = initializeApp(firebaseConfig); db = getFirestore(app); console.log("Firebase Initialized Successfully"); document.getElementById('firebaseConfigWarning').style.display = 'none'; } catch (error) { console.error("Firebase Initialization Error:", error); const e = document.getElementById('firebaseError'); document.getElementById('firebaseErrorMessage').textContent = `Could not initialize Firebase. Check config/console. Error: ${error.message}`; e.style.display = 'block'; document.getElementById('firebaseConfigWarning').style.backgroundColor = '#f8d7da'; document.querySelectorAll('button').forEach(b => { if(b.id !== 'togglePlayerManagement') b.disabled = true; }); }

        // --- Global State ---
        let players = []; let wins = []; let currentDashboardPeriod = 'week'; let currentDisplayDate = new Date(); let currentView = 'player'; let playerWinChartInstance = null; let monthlyChartInstance = null;

        // --- DOM Elements ---
        const togglePlayerManagementBtn = document.getElementById('togglePlayerManagement'); const playerManagementSection = document.getElementById('playerManagement'); const addPlayerBtn = document.getElementById('addPlayerBtn'); const newPlayerNameInput = document.getElementById('newPlayerName'); const addPlayerError = document.getElementById('addPlayerError'); const playerListManagementUl = document.getElementById('playerListManagement'); const noPlayersManagedMsg = document.getElementById('noPlayersManaged'); const dashboardControls = document.querySelector('.dashboard-controls'); const playerViewBtn = document.getElementById('playerViewBtn'); const monthlyViewBtn = document.getElementById('monthlyViewBtn'); const winChartContainer = document.getElementById('winChartContainer'); const winChartTitle = document.getElementById('winChartTitle'); const playerWinCanvas = document.getElementById('playerWinCanvas'); const noChartDataMsg = document.getElementById('noChartData'); const prevPeriodBtn = document.getElementById('prevPeriodBtn'); const nextPeriodBtn = document.getElementById('nextPeriodBtn'); const monthlyChartContainer = document.getElementById('monthlyChartContainer'); const monthlyChartTitle = document.getElementById('monthlyChartTitle'); const monthlyWinsCanvas = document.getElementById('monthlyWinsCanvas'); const noMonthlyChartDataMsg = document.getElementById('noMonthlyChartData'); const prevYearBtn = document.getElementById('prevYearBtn'); const nextYearBtn = document.getElementById('nextYearBtn'); const scoreTrackingListUl = document.getElementById('scoreTrackingList'); const noPlayersForScoringMsg = document.getElementById('noPlayersForScoring'); const todayDateDisplay = document.getElementById('todayDateDisplay'); const todaysWinsListUl = document.getElementById('todaysWinsList'); const noWinsTodayMsg = document.getElementById('noWinsToday');

        // --- Utility Functions ---
        const getTodayDateString = () => new Date().toDateString();
        const formatTime = (timestamp) => { /* ... same ... */ if (!timestamp) return ''; const date = timestamp.toDate ? timestamp.toDate() : (timestamp instanceof Date ? timestamp : null); if (!date) return ''; return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); };
        const getMonthName = (monthIndex) => ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][monthIndex];
        const getFullMonthName = (monthIndex) => ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"][monthIndex];
        const getPeriodRange = (period, baseDate = new Date()) => { /* ... same ... */ let start = new Date(baseDate); let end = new Date(baseDate); switch (period) { case 'week': const dayOfWeek = start.getDay(); const diff = start.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1); start = new Date(start.setDate(diff)); start.setHours(0, 0, 0, 0); end = new Date(start); end.setDate(start.getDate() + 6); end.setHours(23, 59, 59, 999); break; case 'month': start = new Date(start.getFullYear(), start.getMonth(), 1); start.setHours(0, 0, 0, 0); end = new Date(start.getFullYear(), start.getMonth() + 1, 0); end.setHours(23, 59, 59, 999); break; case 'year': start = new Date(start.getFullYear(), 0, 1); start.setHours(0, 0, 0, 0); end = new Date(start.getFullYear(), 11, 31); end.setHours(23, 59, 59, 999); break; } return { start, end }; };
        const sanitizeHTML = (str) => { const temp = document.createElement('div'); temp.textContent = str; return temp.innerHTML; };

        // --- Data Handling Functions (Firebase) ---
        // loadData, addPlayer, deletePlayer, renamePlayer, recordWin, deleteWin, getWinsForPeriodLocal, getWinsForYearLocal
        const loadData = async () => { /* ... same ... */ if (!db) { console.error("DB not available."); return; } console.log("Loading data..."); try { const playersCollection = collection(db, "players"); const playerQuery = query(playersCollection, orderBy("name")); const playerSnapshot = await getDocs(playerQuery); players = playerSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); const winsCollection = collection(db, "wins"); const winSnapshot = await getDocs(winsCollection); wins = winSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); wins = wins.filter(w => w.timestamp && typeof w.timestamp.toDate === 'function'); wins.sort((a, b) => b.timestamp.toMillis() - a.timestamp.toMillis()); } catch (error) { console.error("Error loading data:", error); const e = document.getElementById('firebaseError'); document.getElementById('firebaseErrorMessage').textContent = `Failed to load data. Error: ${error.message}`; e.style.display = 'block'; players = []; wins = []; } renderApp(); };
        const addPlayer = async (name) => { /* ... same ... */ if (!db) { alert("DB error."); return; } const tN = name.trim(); if (!tN) { addPlayerError.textContent = "Name empty."; return; } if (players.some(p => p.name.toLowerCase() === tN.toLowerCase())) { addPlayerError.textContent = "Name exists."; return; } addPlayerError.textContent = ""; addPlayerBtn.disabled = true; try { const dR = await addDoc(collection(db, "players"), { name: tN }); players.push({ id: dR.id, name: tN }); players.sort((a, b) => a.name.localeCompare(b.name)); renderApp(); newPlayerNameInput.value = ''; } catch (error) { console.error("Error adding:", error); addPlayerError.textContent = `Failed: ${error.message}`; } finally { addPlayerBtn.disabled = false; } };
        const deletePlayer = async (playerId) => { /* ... same ... */ if (!db) { alert("DB error."); return; } const p = players.find(pl => pl.id === playerId); if (!p || !confirm(`Delete ${p.name}? Wins remain as 'Unknown'.`)) return; const dB = playerListManagementUl.querySelector(`.player-management-entry[data-player-id="${playerId}"] .delete-player-btn`); if (dB) dB.disabled = true; try { await deleteDoc(doc(db, "players", playerId)); players = players.filter(pl => pl.id !== playerId); renderApp(); } catch (error) { console.error("Error deleting:", error); alert(`Failed: ${error.message}`); if (dB) dB.disabled = false; } };
        const renamePlayer = async (playerId, newName) => { /* ... same ... */ if (!db) { alert("DB error."); return false; } const tN = newName.trim(); if (!tN) { alert("Name empty."); return false; } if (players.some(p => p.id !== playerId && p.name.toLowerCase() === tN.toLowerCase())) { alert("Name exists."); return false; } const pI = players.findIndex(p => p.id === playerId); if (pI === -1) return false; const en = playerListManagementUl.querySelector(`.player-management-entry[data-player-id="${playerId}"]`); const sB = en?.querySelector('.save-rename-btn'); const cB = en?.querySelector('.cancel-rename-btn'); if(sB) sB.disabled = true; if(cB) cB.disabled = true; try { await updateDoc(doc(db, "players", playerId), { name: tN }); players[pI].name = tN; players.sort((a, b) => a.name.localeCompare(b.name)); renderApp(); return true; } catch (error) { console.error("Error renaming:", error); alert(`Failed: ${error.message}`); if(sB) sB.disabled = false; if(cB) cB.disabled = false; return false; } };
        const recordWin = async (playerId) => { /* ... same ... */ if (!db) { alert("DB error."); return; } const p = players.find(pl => pl.id === playerId); if (!p) return; const wB = scoreTrackingListUl.querySelector(`button.add-win-btn[data-player-id="${playerId}"]`); if(wB) wB.disabled = true; try { const dR = await addDoc(collection(db, "wins"), { playerId: playerId, timestamp: serverTimestamp() }); wins.unshift({ id: dR.id, playerId: playerId, timestamp: Timestamp.now() }); renderTodaysWinsList(); renderDashboard(); } catch (error) { console.error("Error recording win:", error); alert(`Failed: ${error.message}`); } finally { if(wB) wB.disabled = false; } };
        const deleteWin = async (winId) => { /* ... same ... */ if (!db) { alert("DB error."); return; } const wI = wins.findIndex(w => w.id === winId); if (wI === -1) return; const wD = wins[wI]; if (!wD.timestamp || typeof wD.timestamp.toDate !== 'function') return; if (!confirm(`Delete win for ${players.find(p=>p.id === wD.playerId)?.name ?? 'Unknown'} at ${formatTime(wD.timestamp)}?`)) return; const dB = todaysWinsListUl.querySelector(`li[data-win-id="${winId}"] .delete-win-btn`); if(dB) dB.disabled = true; try { await deleteDoc(doc(db, "wins", winId)); wins.splice(wI, 1); renderTodaysWinsList(); renderDashboard(); } catch (error) { console.error("Error deleting win:", error); alert(`Failed: ${error.message}`); if(dB) dB.disabled = false; } };
        const getWinsForPeriodLocal = (period, baseDate = new Date()) => { /* ... same ... */ const { start, end } = getPeriodRange(period, baseDate); const sT = start.getTime(); const eT = end.getTime(); return wins.filter(w => { if (!w.timestamp || typeof w.timestamp.toDate !== 'function') return false; const wT = w.timestamp.toDate().getTime(); return wT >= sT && wT <= eT; }); };
        const getWinsForYearLocal = (year) => { /* ... same ... */ const s = new Date(year, 0, 1); const e = new Date(year, 11, 31, 23, 59, 59, 999); const sT = s.getTime(); const eT = e.getTime(); return wins.filter(w => { if (!w.timestamp || typeof w.timestamp.toDate !== 'function') return false; const wT = w.timestamp.toDate().getTime(); return wT >= sT && wT <= eT; }); };

        // --- Rendering Functions ---
        const renderPlayerManagementList = () => { /* ... same ... */ playerListManagementUl.innerHTML = ''; noPlayersManagedMsg.classList.toggle('hidden', players.length > 0); if (players.length === 0) return; players.forEach(p => { const li = document.createElement('li'); li.className = 'player-management-entry'; li.dataset.playerId = p.id; const sN = sanitizeHTML(p.name); li.innerHTML = ` <span class="player-name-display">${sN}</span> <div class="rename-controls hidden"> <input type="text" class="rename-input" value="${sN}" aria-label="New name for ${sN}"> <button class="save-rename-btn icon-button" aria-label="Save rename">‚úîÔ∏è</button> <button class="cancel-rename-btn icon-button secondary" aria-label="Cancel rename">‚ùå</button> </div> <div class="action-buttons"> <button class="rename-btn icon-button secondary" aria-label="Rename ${sN}">‚úèÔ∏è Rename</button> <button class="delete-player-btn icon-button danger" aria-label="Delete ${sN}">üóëÔ∏è Delete</button> </div> `; playerListManagementUl.appendChild(li); }); };
        const renderScoreTrackingList = () => { /* ... same ... */ scoreTrackingListUl.innerHTML = ''; noPlayersForScoringMsg.classList.toggle('hidden', players.length > 0); if (players.length === 0) return; players.forEach(p => { const li = document.createElement('li'); li.dataset.playerId = p.id; const sN = sanitizeHTML(p.name); li.innerHTML = ` <span class="player-name">${sN}</span> <button class="add-win-btn" data-player-id="${p.id}">+ Win</button> `; scoreTrackingListUl.appendChild(li); }); };
        const renderTodaysWinsList = () => { /* ... same ... */ todaysWinsListUl.innerHTML = ''; const t = getTodayDateString(); todayDateDisplay.textContent = t; const tW = wins.filter(w => w.timestamp?.toDate().toDateString() === t); noWinsTodayMsg.classList.toggle('hidden', tW.length > 0); if (tW.length === 0) return; tW.forEach(w => { const p = players.find(pl => pl.id === w.playerId); const pN = p ? sanitizeHTML(p.name) : 'Unknown Player'; const li = document.createElement('li'); li.dataset.winId = w.id; li.innerHTML = ` <span class="player-name">${pN}</span> <span class="win-timestamp">${formatTime(w.timestamp)}</span> <button class="delete-win-btn icon-button danger" aria-label="Delete this win">üóëÔ∏è</button> `; todaysWinsListUl.appendChild(li); }); };

        const renderDashboard = () => { /* ... same ... */ console.log("Rendering dashboard for view:", currentView, "Period:", currentDashboardPeriod, "Date:", currentDisplayDate.toLocaleDateString()); if (currentView === 'player') { renderPlayerWinsChart(currentDashboardPeriod, currentDisplayDate); } else if (currentView === 'monthly') { renderMonthlyBreakdownChart(currentDisplayDate.getFullYear()); } };

        // --- Chart.js Player Wins Chart (No change) ---
        const renderPlayerWinsChart = (period, displayDate) => { /* ... same ... */ if (playerWinChartInstance) { playerWinChartInstance.destroy(); playerWinChartInstance = null; } dashboardControls.querySelectorAll('button').forEach(b => { b.classList.toggle('active', b.dataset.period === period); }); const { start, end } = getPeriodRange(period, displayDate); let tT = ''; const today = new Date(); today.setHours(0,0,0,0); const cPRT = getPeriodRange(period, today); const isCP = cPRT.start.getTime() === start.getTime(); switch(period) { case 'week': tT = isCP ? 'Wins This Week' : `Week of ${start.toLocaleDateString()}`; break; case 'month': const mN = getFullMonthName(displayDate.getMonth()); tT = isCP ? `Wins This ${mN}` : `Wins ${mN} ${displayDate.getFullYear()}`; break; case 'year': tT = isCP ? `Wins This Year (${displayDate.getFullYear()})` : `Wins ${displayDate.getFullYear()}`; break; } winChartTitle.textContent = tT; prevPeriodBtn.classList.remove('hidden'); nextPeriodBtn.classList.remove('hidden'); const tEOD = new Date(); tEOD.setHours(23, 59, 59, 999); nextPeriodBtn.disabled = end.getTime() >= tEOD.getTime(); const pW = getWinsForPeriodLocal(period, displayDate); const hP = players.length > 0; const hD = pW.length > 0; let pD = []; if (hP) { const wBP = players.reduce((acc, p) => { acc[p.id] = { name: p.name, count: 0 }; return acc; }, {}); pW.forEach(w => { if (w.playerId && wBP[w.playerId]) { wBP[w.playerId].count++; } }); pD = Object.values(wBP); pD.sort((a, b) => a.name.localeCompare(b.name)); } if (!hP) { noChartDataMsg.textContent = "Add players to see statistics."; noChartDataMsg.classList.remove('hidden'); playerWinCanvas.classList.add('hidden'); return; } else if (!hD) { noChartDataMsg.textContent = "No wins recorded for this period."; noChartDataMsg.classList.remove('hidden'); playerWinCanvas.classList.add('hidden'); return; } else { noChartDataMsg.classList.add('hidden'); playerWinCanvas.classList.remove('hidden'); } const ctx = playerWinCanvas.getContext('2d'); if (!ctx) return; const l = pD.map(p => p.name); const dC = pD.map(p => p.count); playerWinChartInstance = new Chart(ctx, { type: 'bar', data: { labels: l, datasets: [{ label: 'Wins', data: dC, backgroundColor: '#219ebc', borderColor: '#1a7f9a', borderWidth: 1 }] }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true, ticks: { stepSize: 1, precision: 0 } } }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: function(c) { let l = c.dataset.label || ''; if (l) { l += ': '; } if (c.parsed.y !== null) { l += c.parsed.y + (c.parsed.y === 1 ? ' win' : ' wins'); } return l; } } } } } }); };

        // --- Chart.js Monthly Breakdown Chart (UPDATED Y-AXIS MAX) ---
        const renderMonthlyBreakdownChart = (year) => {
            if (monthlyChartInstance) {
                monthlyChartInstance.destroy();
                monthlyChartInstance = null;
            }

            monthlyChartTitle.textContent = `Monthly Winners for ${year}`;
            nextYearBtn.disabled = year >= new Date().getFullYear();

            const yearWins = getWinsForYearLocal(year);
            const hasData = yearWins.length > 0;

            // Calculate monthly results AND overall max score
            const monthlyPlayerWins = {};
            yearWins.forEach(win => { /* ... same data aggregation ... */ if (win.timestamp && typeof win.timestamp.toDate === 'function' && win.playerId) { const mI = win.timestamp.toDate().getMonth(); monthlyPlayerWins[mI] = monthlyPlayerWins[mI] || {}; monthlyPlayerWins[mI][win.playerId] = (monthlyPlayerWins[mI][win.playerId] || 0) + 1; } });

             const monthlyResults = [];
             let overallMaxWinningScore = 0; // Calculate max score here
             for (let i = 0; i < 12; i++) {
                  const monthData = monthlyPlayerWins[i];
                  let winners = [];
                  let maxScore = 0;
                  if (monthData && Object.keys(monthData).length > 0) {
                      maxScore = Math.max(...Object.values(monthData));
                      if (maxScore > overallMaxWinningScore) { // Update overall max
                          overallMaxWinningScore = maxScore;
                      }
                      winners = Object.entries(monthData)
                          .filter(([_, score]) => score === maxScore)
                          .map(([playerId, _]) => sanitizeHTML(players.find(p => p.id === playerId)?.name ?? 'Unknown'));
                  }
                  monthlyResults.push({ monthIndex: i, winnerNames: winners, winningScore: maxScore });
              }

             if (!hasData) {
                noMonthlyChartDataMsg.textContent = `No wins recorded for ${year}.`;
                noMonthlyChartDataMsg.classList.remove('hidden');
                monthlyWinsCanvas.classList.add('hidden');
                return;
             } else {
                noMonthlyChartDataMsg.classList.add('hidden');
                monthlyWinsCanvas.classList.remove('hidden');
             }

            const ctx = monthlyWinsCanvas.getContext('2d');
             if (!ctx) { console.error("Failed to get canvas context for monthly wins"); return; }

            const labels = monthlyResults.map(r => getMonthName(r.monthIndex));
            const dataScores = monthlyResults.map(r => r.winningScore);

            // *** Calculate Y-axis max value ***
            // Add a buffer (e.g., 2) to the highest score to give labels space
            // Ensure the max is at least a certain value (e.g., 3 or 4) if all scores are 0 or 1.
            const yAxisMax = Math.max(3, overallMaxWinningScore + 2); // Ensures scale goes up to at least 3, adds 2 otherwise

            monthlyChartInstance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Winning Score',
                        data: dataScores,
                        backgroundColor: '#fdc500',
                        borderColor: '#e8b700',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            // *** SET THE MAX VALUE HERE ***
                            max: yAxisMax,
                            ticks: {
                                stepSize: 1, // Keep integer steps
                                precision: 0
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: { // Tooltip config remains the same
                            callbacks: {
                                title: (tooltipItems) => `${getFullMonthName(tooltipItems[0].dataIndex)} ${year}`,
                                label: (context) => { /* ... same multi-line label logic ... */ const index = context.dataIndex; const result = monthlyResults[index]; let winnerLabel = ''; if (!result || result.winnerNames.length === 0) winnerLabel = 'Winner: N/A'; else if (result.winnerNames.length === 1) winnerLabel = `Winner: ${result.winnerNames[0]}`; else winnerLabel = `Tie: ${result.winnerNames.join(', ')}`; const scoreLabel = `Score: ${context.parsed.y}`; return [winnerLabel, scoreLabel]; }
                            }
                        },
                        datalabels: { // Datalabels config remains the same
                            display: (context) => context.dataset.data[context.dataIndex] > 0,
                            anchor: 'end',
                            align: 'top',
                            offset: -2, // You might tweak this slightly if needed after scale change
                            color: '#555',
                            font: { size: 10, weight: 'bold' },
                            formatter: (value, context) => { /* ... same formatter logic ... */ const index = context.dataIndex; const result = monthlyResults[index]; if (!result || result.winnerNames.length === 0) { return ''; } else if (result.winnerNames.length === 1) { let name = result.winnerNames[0]; return name.length > 8 ? name.substring(0, 7) + '‚Ä¶' : name; } else { return 'Tie'; } }
                        }
                    }
                }
            });
        };


        // Renders all sections
        const renderApp = () => { /* ... same ... */ renderPlayerManagementList(); renderScoreTrackingList(); renderTodaysWinsList(); renderDashboard(); };

        // --- Event Listeners ---
        // (No changes needed in listeners)
        togglePlayerManagementBtn.addEventListener('click', () => { /* ... */ playerManagementSection.classList.toggle('hidden'); const i = playerManagementSection.classList.contains('hidden'); togglePlayerManagementBtn.setAttribute('aria-expanded',!i); togglePlayerManagementBtn.textContent = i?'‚öôÔ∏è Manage':'üîΩ Close'; });
        addPlayerBtn.addEventListener('click', () => addPlayer(newPlayerNameInput.value));
        newPlayerNameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') { e.preventDefault(); addPlayer(newPlayerNameInput.value); } addPlayerError.textContent = ""; });
        playerListManagementUl.addEventListener('click', (e) => { const t = e.target; const pE = t.closest('.player-management-entry'); if (!pE) return; const pId = pE.dataset.playerId; if (t.classList.contains('delete-player-btn')) { deletePlayer(pId); } else if (t.classList.contains('rename-btn')) { /* ... show rename */ playerListManagementUl.querySelectorAll('.rename-controls:not(.hidden)').forEach(c => { const en = c.closest('.player-management-entry'); if (en && en !== pE) { en.querySelector('.rename-controls').classList.add('hidden'); en.querySelector('.player-name-display').classList.remove('hidden'); en.querySelector('.action-buttons').classList.remove('hidden'); } }); pE.querySelector('.player-name-display').classList.add('hidden'); pE.querySelector('.action-buttons').classList.add('hidden'); const rC = pE.querySelector('.rename-controls'); rC.classList.remove('hidden'); const i = rC.querySelector('.rename-input'); i.focus(); i.select(); } else if (t.classList.contains('save-rename-btn')) { const i = pE.querySelector('.rename-input'); renamePlayer(pId, i.value); } else if (t.classList.contains('cancel-rename-btn')) { /* ... hide rename */ const oN = pE.querySelector('.player-name-display').textContent; pE.querySelector('.rename-input').value = oN; pE.querySelector('.rename-controls').classList.add('hidden'); pE.querySelector('.player-name-display').classList.remove('hidden'); pE.querySelector('.action-buttons').classList.remove('hidden'); } });
        playerListManagementUl.addEventListener('keypress', (e) => { if (e.key === 'Enter' && e.target.classList.contains('rename-input')) { e.preventDefault(); const pE = e.target.closest('.player-management-entry'); if (pE) renamePlayer(pE.dataset.playerId, e.target.value); } });
        scoreTrackingListUl.addEventListener('click', (e) => { if (e.target.classList.contains('add-win-btn')) { recordWin(e.target.dataset.playerId); } });
        todaysWinsListUl.addEventListener('click', (e) => { if (e.target.classList.contains('delete-win-btn')) { const wL = e.target.closest('li'); if (wL?.dataset.winId) deleteWin(wL.dataset.winId); } });
        dashboardControls.addEventListener('click', (e) => { if (e.target.tagName === 'BUTTON' && e.target.dataset.period) { currentDashboardPeriod = e.target.dataset.period; currentDisplayDate = new Date(); if (currentView !== 'player') { switchToPlayerView(); } else { renderDashboard(); } } });
        playerViewBtn.addEventListener('click', switchToPlayerView);
        monthlyViewBtn.addEventListener('click', switchToMonthlyView);
        function switchToPlayerView() { /* ... same ... */ if (currentView === 'player') return; currentView = 'player'; winChartContainer.classList.remove('hidden'); monthlyChartContainer.classList.add('hidden'); playerViewBtn.classList.add('active'); monthlyViewBtn.classList.remove('active'); renderDashboard(); }
        function switchToMonthlyView() { /* ... same ... */ if (currentView === 'monthly') return; currentView = 'monthly'; winChartContainer.classList.add('hidden'); monthlyChartContainer.classList.remove('hidden'); playerViewBtn.classList.remove('active'); monthlyViewBtn.classList.add('active'); renderDashboard(); }
        prevPeriodBtn.addEventListener('click', () => { const nD=new Date(currentDisplayDate); if(currentDashboardPeriod==='week')nD.setDate(nD.getDate()-7); else if(currentDashboardPeriod==='month')nD.setMonth(nD.getMonth()-1); else if(currentDashboardPeriod==='year')nD.setFullYear(nD.getFullYear()-1); currentDisplayDate=nD; renderDashboard(); });
        nextPeriodBtn.addEventListener('click', () => { const nD=new Date(currentDisplayDate); if(currentDashboardPeriod==='week')nD.setDate(nD.getDate()+7); else if(currentDashboardPeriod==='month')nD.setMonth(nD.getMonth()+1); else if(currentDashboardPeriod==='year')nD.setFullYear(nD.getFullYear()+1); const{end}=getPeriodRange(currentDashboardPeriod,nD); const tE=new Date(); tE.setHours(23,59,59,999); if(end.getTime()<=tE.getTime()){currentDisplayDate=nD; renderDashboard();} else{nextPeriodBtn.disabled=true;} });
        prevYearBtn.addEventListener('click', () => { const nD=new Date(currentDisplayDate); nD.setFullYear(nD.getFullYear()-1); currentDisplayDate=nD; renderDashboard(); });
        nextYearBtn.addEventListener('click', () => { const nD=new Date(currentDisplayDate); nD.setFullYear(nD.getFullYear()+1); if(nD.getFullYear()<=new Date().getFullYear()){currentDisplayDate=nD; renderDashboard();} else{nextYearBtn.disabled=true;} });


        // --- Initial Load ---
        (async () => {
            // Register plugin globally
            if (typeof ChartDataLabels !== 'undefined') {
                Chart.register(ChartDataLabels);
            } else { console.error("ChartDataLabels plugin not loaded!"); }

            switchToPlayerView();
            await loadData();
        })();

    </script>

</body>
</html>
