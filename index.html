<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rummikub Win Tracker</title>
    <!-- Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <style>
        /* CSS Styles (keep existing styles) */
        /* --- Basic Reset & Defaults --- */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; /* Ensure body takes full height */ }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; background-color: #f4f7f6; color: #333; padding-bottom: 50px; }
        .app-container { max-width: 600px; margin: 0 auto; padding: 15px; position: relative; z-index: 1; /* Ensure app content is below timer */ }
        /* --- Typography --- */
        h1, h2, h3 { margin-bottom: 0.8em; color: #0b4f6c; }
        h1 { text-align: center; margin-bottom: 1em; color: #012a4a; }
        p { margin-bottom: 1em; }
        /* --- Buttons --- */
        button { display: inline-block; padding: 10px 18px; font-size: 1rem; font-weight: bold; color: #fff; background-color: #219ebc; border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.2s ease; min-height: 44px; vertical-align: middle; -webkit-tap-highlight-color: transparent; /* Prevent flash on mobile tap */ }
        button:hover, button:focus { background-color: #1a7f9a; outline: none; }
        button:disabled { background-color: #adb5bd; cursor: not-allowed; }
        button.secondary { background-color: #6c757d; }
        button.secondary:hover, button.secondary:focus { background-color: #5a6268; }
        button.danger { background-color: #e76f51; }
        button.danger:hover, button.danger:focus { background-color: #d95a3a; }
        button.icon-button { padding: 8px 10px; font-size: 0.9rem; margin-left: 5px; }
        button.small-nav-button { padding: 5px 10px; font-size: 0.9rem; min-height: 30px; margin: 0 5px; }
        /* --- Forms --- */
        input[type="text"] { width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 1rem; }
        /* --- Layout Sections --- */
        section { background-color: #fff; padding: 15px; margin-bottom: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); }
        /* --- Header & Player Management Toggle --- */
        header { margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; /* Allow wrapping */ }
        header h1 { margin-bottom: 0; flex-grow: 1; text-align: left; margin-right: 10px; /* Space before buttons */ }
        .header-buttons { display: flex; align-items: center; }
        #togglePlayerManagement { flex-shrink: 0; margin-left: 5px; } /* Spacing for manage button */
        #toggleTimerBtn { /* Style for the new timer button */
            flex-shrink: 0;
            margin-left: 10px; /* Space between buttons */
            background-color: #2a9d8f; /* Different color? */
            padding: 8px 10px;
            font-size: 0.9rem;
        }
        #toggleTimerBtn:hover, #toggleTimerBtn:focus {
            background-color: #258a7f;
        }

        /* --- Player Management Section --- */
        #playerManagement { border: 1px dashed #ccc; }
        #playerManagement.hidden { display: none; }
        .player-management-entry { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #eee; }
        .player-management-entry:last-child { border-bottom: none; }
        .player-management-entry span.player-name-display { flex-grow: 1; margin-right: 10px; } /* Target specific span */
        .rename-controls { display: flex; align-items: center; }
        .rename-controls input { width: 120px; margin-bottom: 0; margin-right: 5px; font-size: 0.9rem; padding: 5px 8px; }
        /* --- Score Tracking Section --- */
        #scoreTrackingList li, #todaysWinsList li { display: flex; justify-content: space-between; align-items: center; padding: 12px 5px; border-bottom: 1px solid #eee; }
        #scoreTrackingList li:last-child, #todaysWinsList li:last-child { border-bottom: none; }

        /* UPDATED: Player Info Wrapper Styling */
        .player-info {
            flex-grow: 1; /* Take up available space */
            margin-right: 10px; /* Space before button */
        }
        .player-name {
            font-weight: bold;
            display: block; /* Ensure name is on its own line */
            overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
        }
        .win-timestamp { font-size: 0.85em; color: #666; margin-left: 10px; margin-right: 10px; white-space: nowrap; }

        /* UPDATED: Win Feedback Message Styling */
        .win-feedback {
            display: block; /* Place on new line */
            font-size: 0.85em; /* Slightly smaller */
            color: #28a745; /* Green */
            margin-top: 2px; /* Small space below name */
            font-style: italic;
            animation: fadeOut 3s forwards; /* Make it fade out */
            line-height: 1.2; /* Adjust line height if needed */
        }
        @keyframes fadeOut {
            0% { opacity: 1; }
            80% { opacity: 1; } /* Stay visible for most of the duration */
            100% { opacity: 0; }
        }

        /* --- Dashboard --- */
        .dashboard-controls { display: flex; justify-content: space-around; margin-bottom: 15px; flex-wrap: wrap; }
        .dashboard-controls button { flex-grow: 1; margin: 5px; background-color: #f8f9fa; color: #0b4f6c; border: 1px solid #dee2e6; }
        .dashboard-controls button.active { background-color: #0b4f6c; color: #fff; font-weight: bold; border-color: #0b4f6c; }
        .dashboard-view-toggle { text-align: center; margin-bottom: 15px; }
        .dashboard-view-toggle .small-nav-button {
            background-color: #e9ecef;  /* Light grey background */
            color: #495057;           /* Dark grey text */
            border: 1px solid #ced4da; /* Visible but subtle border */
            font-weight: normal;       /* Ensure text is not bold */
        }
        .dashboard-view-toggle .small-nav-button.active {
            background-color: #0b4f6c;  /* Dark blue background (matches period buttons) */
            color: #ffffff;           /* White text */
            border-color: #0b4f6c;   /* Border matches background (looks solid) */
            font-weight: bold;         /* Bold text */
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.1); /* Optional: subtle inset shadow */
        }
        .chart-title-container { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .chart-title-container h3 { margin-bottom: 0; text-align: center; flex-grow: 1; color: #333; font-weight: bold; }
        #winChartContainer, #monthlyChartContainer { background-color: #f8f9fa; padding: 20px 10px 10px 10px; border-radius: 5px; min-height: 320px; position: relative; }
        #chart, #monthlyChart { position: relative; height: 270px; width: 100%; }
        canvas.hidden { display: none; }
        /* --- Utility Classes --- */
        .hidden { display: none !important; }
        .text-center { text-align: center; }
        .error-message { color: #d95a3a; font-size: 0.9em; margin-top: -5px; margin-bottom: 10px; }
        .no-data {
            color: #6c757d;
            text-align: center;
            padding: 20px;
            font-style: italic;
            margin-top: 20px; /* Add some space */
        }
        /* --- List Styling --- */
        ul { list-style: none; padding: 0; }

        /* --- Style for Total Wins Display --- */
        .total-wins-display {
            font-size: 0.9em;
            color: #555;
            margin-top: -5px; /* Adjust spacing relative to title */
            margin-bottom: 10px;
            font-weight: bold;
        }
        /* --- Today's Summary Style --- */
        .todays-summary {
            font-size: 0.95em;
            color: #444;
            background-color: #eef3f5; /* Light background */
            padding: 8px 12px;
            border-radius: 4px;
            margin-bottom: 15px; /* Space before the list */
            border-left: 3px solid #219ebc; /* Accent border */
        }
        .todays-summary.hidden {
            display: none;
        }
        .todays-summary span { /* Style for individual player summaries */
             display: inline-block; /* Allow spacing */
             margin-right: 15px; /* Space between players */
        }
        .todays-summary span:last-child {
            margin-right: 0;
        }

        /* --- Timer Overlay Styles --- */
        #timerOverlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #333333; z-index: 1000;
            display: none; flex-direction: column; justify-content: center; align-items: center;
            overflow: hidden;
        }
        #timerFill {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 100%;
            background-color: #4CAF50; transition: height 0.1s linear; z-index: 1;
        }
        #timerDisplay {
            font-size: 10em; font-weight: bold; color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 2; position: relative;
        }
        #hideTimerBtn {
            position: absolute; top: 20px; right: 20px;
            padding: 12px 24px; font-size: 1.2rem;
            background-color: rgba(255, 255, 255, 0.7); color: #333;
            border: 1px solid #ccc; border-radius: 5px; cursor: pointer; z-index: 2;
        }
        #hideTimerBtn:hover { background-color: rgba(255, 255, 255, 0.9); }
        #nextTimerBtn {
            margin-top: 25px; padding: 18px 40px; font-size: 1.8rem; min-width: 150px;
            font-weight: bold; background-color: rgba(255, 255, 255, 0.7); color: #333;
            border: 1px solid #ccc; border-radius: 8px; cursor: pointer; z-index: 2;
            transition: background-color 0.2s ease;
        }
        #nextTimerBtn:hover { background-color: rgba(255, 255, 255, 0.95); }

    </style>
</head>
<body>

    <!-- Timer Overlay -->
    <div id="timerOverlay">
        <div id="timerFill"></div>
        <div id="timerDisplay">1:00</div>
        <button id="nextTimerBtn" aria-label="Next Turn Timer">NEXT</button>
        <button id="hideTimerBtn" aria-label="Hide Timer">Hide Timer</button>
    </div>
    <!-- Audio Element for Timer -->
    <audio id="timerAudio" src="https://www.dropbox.com/scl/fi/evdnaujbchtbk24mryfwf/VoicesAI_Snoop_Thats_a_wrap-_nigga-_143435_13052025.mp3?rlkey=zglusykxd7te77en2bydj9d3f&st=40oha7za&dl=1" preload="auto"></audio>

    <!-- App Container -->
    <div class="app-container">
        <!-- Header, Player Management, Dashboard, Score Tracking, Today's Wins (keep existing structure) -->
         <header>
            <h1>Rummikub Wins</h1>
            <div class="header-buttons">
                 <button id="toggleTimerBtn" aria-label="Show Timer">⏱️ Timer</button>
                 <button id="togglePlayerManagement" class="secondary icon-button" aria-label="Manage Players" title="Manage Players">⚙️ Manage</button>
            </div>
        </header>

        <!-- Player Management Section -->
        <section id="playerManagement" class="hidden">
            <h3>Manage Players</h3>
            <div id="addPlayerForm">
                <input type="text" id="newPlayerName" placeholder="New Player Name">
                <button id="addPlayerBtn">Add Player</button>
                <div id="addPlayerError" class="error-message"></div>
            </div>
            <ul id="playerListManagement"></ul>
             <p id="noPlayersManaged" class="no-data hidden">No players added yet.</p>
        </section>

        <!-- Dashboard / Statistics Section -->
        <section id="dashboard">
            <h2>Dashboard</h2>
            <div class="dashboard-controls">
                <button data-period="month" class="active">This Month</button>
                <button data-period="week">This Week</button>
                <button data-period="year">This Year</button>
            </div>
            <div class="dashboard-view-toggle">
                 <button id="playerViewBtn" class="secondary small-nav-button active">Player Wins</button>
                 <button id="monthlyViewBtn" class="secondary small-nav-button">Monthly Breakdown</button>
            </div>

            <!-- Player Wins Chart (Default View) -->
            <div id="winChartContainer">
                 <div class="chart-title-container">
                     <button id="prevPeriodBtn" class="secondary small-nav-button hidden" aria-label="Previous Period">⬅️ Prev</button>
                     <h3 id="winChartTitle">Wins This Week</h3>
                     <button id="nextPeriodBtn" class="secondary small-nav-button hidden" aria-label="Next Period">Next ➡️</button>
                 </div>
                 <p id="totalPlayerWinsDisplay" class="total-wins-display text-center"></p>
                 <div id="chart">
                     <canvas id="playerWinCanvas"></canvas>
                     <p id="noChartData" class="no-data hidden">No wins recorded for this period.</p>
                 </div>
            </div>

            <!-- Monthly Breakdown Chart (Initially Hidden) -->
            <div id="monthlyChartContainer" class="hidden">
                 <div class="chart-title-container">
                     <button id="prevYearBtn" class="secondary small-nav-button" aria-label="Previous Year">⬅️ Prev Yr</button>
                     <h3 id="monthlyChartTitle">Monthly Winners for 2023</h3>
                     <button id="nextYearBtn" class="secondary small-nav-button" aria-label="Next Year">Next Yr ➡️</button>
                 </div>
                 <p id="totalMonthlyWinsDisplay" class="total-wins-display text-center"></p>
                 <div id="monthlyChart">
                      <canvas id="monthlyWinsCanvas"></canvas>
                      <p id="noMonthlyChartData" class="no-data hidden">No wins recorded for this year.</p>
                 </div>
            </div>
        </section>

        <!-- Score Tracking Interface -->
        <section id="scoreTracking">
            <h2>Record a Win</h2>
            <ul id="scoreTrackingList"></ul>
             <p id="noPlayersForScoring" class="no-data hidden">Add players in 'Manage Players' to track wins.</p>
        </section>

        <!-- Today's Recorded Wins Management -->
        <section id="todaysWins">
             <h3>Recorded Today (<span id="todayDateDisplay"></span>)</h3>
             <div id="todaysSummary" class="todays-summary hidden"></div>
             <ul id="todaysWinsList"></ul>
             <p id="noWinsToday" class="no-data">No wins recorded yet today.</p>
        </section>

        <!-- Firebase Placeholders -->
        <div id="firebaseConfigWarning" style="padding: 10px; margin-top: 20px; background-color: #fff3cd; border: 1px solid #ffeeba; border-radius: 5px; font-size: 0.9em;">
            <strong>Firebase Setup:</strong> Ensure the `firebaseConfig` in the JavaScript below is correct...
        </div>
        <div id="firebaseError" style="display: none; padding: 10px; margin-top: 10px; background-color: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; border-radius: 5px; font-size: 0.9em;">
             <strong>Firebase Error:</strong> <span id="firebaseErrorMessage"></span>
        </div>
    </div><!-- /app-container -->

    <script type="module">

        // --- Firebase SDK Imports ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getFirestore, collection, getDocs, addDoc, deleteDoc, updateDoc, doc, query, where, orderBy, Timestamp, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";

        // --- Firebase Configuration (Replace with your actual config!) ---
        const firebaseConfig = {
          apiKey: "AIzaSyD-e3H5CaoQobBqFwzDnCGZCUbniZQg_J0", // Replace!
          authDomain: "i-am-awesome-tasker.firebaseapp.com", // Replace!
          projectId: "i-am-awesome-tasker", // Replace!
          storageBucket: "i-am-awesome-tasker.appspot.com", // Replace!
          messagingSenderId: "853316153385", // Replace!
          appId: "1:853316153385:web:db1fc1304b54a198a82c38", // Replace!
          measurementId: "G-ZDBF73CFXS" // Optional: Replace!
        };

        // --- Firebase Initialization ---
        let app, db;
        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            console.log("Firebase Initialized Successfully");
            document.getElementById('firebaseConfigWarning').style.display = 'none';
        } catch (error) {
            console.error("Firebase Initialization Error:", error);
            const e = document.getElementById('firebaseError');
            document.getElementById('firebaseErrorMessage').textContent = `Could not initialize Firebase. Check config/console. Error: ${error.message}`;
            e.style.display = 'block';
            document.getElementById('firebaseConfigWarning').style.backgroundColor = '#f8d7da';
            document.querySelectorAll('button').forEach(b => {
                if(b.id !== 'togglePlayerManagement' && b.id !== 'toggleTimerBtn') b.disabled = true;
            });
            throw new Error("Firebase initialization failed, stopping script execution.");
        }

        // --- Global State ---
        let players = [];
        let wins = [];
        let currentDashboardPeriod = 'month';
        let currentDisplayDate = new Date();
        let currentView = 'player';
        let playerWinChartInstance = null;
        let monthlyChartInstance = null;
        // --- Timer State ---
        let timerTimeoutId = null; // CHANGED: Use timeout ID instead of interval ID
        const TIMER_DURATION_SECONDS = 60;
        let timerRemainingSeconds = TIMER_DURATION_SECONDS;
        let isTimerVisible = false;
        let audioUnlocked = false;
        // --- Wake Lock State ---
        let wakeLockSentinel = null;

        // --- DOM Elements ---
        // (Keep existing DOM element references)
         const togglePlayerManagementBtn = document.getElementById('togglePlayerManagement');
         const playerManagementSection = document.getElementById('playerManagement');
         const addPlayerBtn = document.getElementById('addPlayerBtn');
         const newPlayerNameInput = document.getElementById('newPlayerName');
         const addPlayerError = document.getElementById('addPlayerError');
         const playerListManagementUl = document.getElementById('playerListManagement');
         const noPlayersManagedMsg = document.getElementById('noPlayersManaged');
         const dashboardControls = document.querySelector('.dashboard-controls');
         const playerViewBtn = document.getElementById('playerViewBtn');
         const monthlyViewBtn = document.getElementById('monthlyViewBtn');
         const winChartContainer = document.getElementById('winChartContainer');
         const winChartTitle = document.getElementById('winChartTitle');
         const playerWinCanvas = document.getElementById('playerWinCanvas');
         const noChartDataMsg = document.getElementById('noChartData');
         const prevPeriodBtn = document.getElementById('prevPeriodBtn');
         const nextPeriodBtn = document.getElementById('nextPeriodBtn');
         const monthlyChartContainer = document.getElementById('monthlyChartContainer');
         const monthlyChartTitle = document.getElementById('monthlyChartTitle');
         const monthlyWinsCanvas = document.getElementById('monthlyWinsCanvas');
         const noMonthlyChartDataMsg = document.getElementById('noMonthlyChartData');
         const prevYearBtn = document.getElementById('prevYearBtn');
         const nextYearBtn = document.getElementById('nextYearBtn');
         const scoreTrackingListUl = document.getElementById('scoreTrackingList');
         const noPlayersForScoringMsg = document.getElementById('noPlayersForScoring');
         const todayDateDisplay = document.getElementById('todayDateDisplay');
         const todaysWinsListUl = document.getElementById('todaysWinsList');
         const noWinsTodayMsg = document.getElementById('noWinsToday');
         const todaysSummaryDiv = document.getElementById('todaysSummary');
         const toggleTimerBtn = document.getElementById('toggleTimerBtn');
         const timerOverlay = document.getElementById('timerOverlay');
         const timerFill = document.getElementById('timerFill');
         const timerDisplay = document.getElementById('timerDisplay');
         const hideTimerBtn = document.getElementById('hideTimerBtn');
         const timerAudio = document.getElementById('timerAudio');
         const nextTimerBtn = document.getElementById('nextTimerBtn');
         const totalPlayerWinsDisplay = document.getElementById('totalPlayerWinsDisplay');
         const totalMonthlyWinsDisplay = document.getElementById('totalMonthlyWinsDisplay');

        // --- Utility Functions ---
        // (Keep existing utility functions: getTodayDateString, formatTime, getMonthName, getFullMonthName, getPeriodRange, sanitizeHTML, pluralize)
        const getTodayDateString = () => new Date().toDateString();
        const formatTime = (timestamp) => { if (!timestamp) return ''; const date = timestamp.toDate ? timestamp.toDate() : (timestamp instanceof Date ? timestamp : null); if (!date) return ''; return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); };
        const getMonthName = (monthIndex) => ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][monthIndex];
        const getFullMonthName = (monthIndex) => ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"][monthIndex];
        const getPeriodRange = (period, baseDate = new Date()) => { let start = new Date(baseDate); let end = new Date(baseDate); switch (period) { case 'week': const dayOfWeek = start.getDay(); const diff = start.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1); start = new Date(start.setDate(diff)); start.setHours(0, 0, 0, 0); end = new Date(start); end.setDate(start.getDate() + 6); end.setHours(23, 59, 59, 999); break; case 'month': start = new Date(start.getFullYear(), start.getMonth(), 1); start.setHours(0, 0, 0, 0); end = new Date(start.getFullYear(), start.getMonth() + 1, 0); end.setHours(23, 59, 59, 999); break; case 'year': start = new Date(start.getFullYear(), 0, 1); start.setHours(0, 0, 0, 0); end = new Date(start.getFullYear(), 11, 31); end.setHours(23, 59, 59, 999); break; } return { start, end }; };
        const sanitizeHTML = (str) => { const temp = document.createElement('div'); temp.textContent = str; return temp.innerHTML; };
        const pluralize = (count, singular, plural = null) => { plural = plural ?? singular + 's'; return count === 1 ? `${count} ${singular}` : `${count} ${plural}`; }

        // --- Data Handling Functions (Firebase) ---
        // (Keep existing Firebase functions)
        const loadData = async () => { if (!db) { console.error("DB not available."); return; } console.log("Loading data..."); try { const playersCollection = collection(db, "players"); const playerQuery = query(playersCollection, orderBy("name")); const playerSnapshot = await getDocs(playerQuery); players = playerSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); const winsCollection = collection(db, "wins"); const winSnapshot = await getDocs(winsCollection); wins = winSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); wins = wins.filter(w => w.timestamp && typeof w.timestamp.toDate === 'function'); wins.sort((a, b) => b.timestamp.toMillis() - a.timestamp.toMillis()); } catch (error) { console.error("Error loading data:", error); const e = document.getElementById('firebaseError'); document.getElementById('firebaseErrorMessage').textContent = `Failed to load data. Error: ${error.message}`; e.style.display = 'block'; players = []; wins = []; } renderApp(); };
        const addPlayer = async (name) => { if (!db) { alert("DB error."); return; } const tN = name.trim(); if (!tN) { addPlayerError.textContent = "Name empty."; return; } if (players.some(p => p.name.toLowerCase() === tN.toLowerCase())) { addPlayerError.textContent = "Name exists."; return; } addPlayerError.textContent = ""; addPlayerBtn.disabled = true; try { const dR = await addDoc(collection(db, "players"), { name: tN }); players.push({ id: dR.id, name: tN }); players.sort((a, b) => a.name.localeCompare(b.name)); renderApp(); newPlayerNameInput.value = ''; } catch (error) { console.error("Error adding:", error); addPlayerError.textContent = `Failed: ${error.message}`; } finally { addPlayerBtn.disabled = false; } };
        const deletePlayer = async (playerId) => { if (!db) { alert("DB error."); return; } const p = players.find(pl => pl.id === playerId); if (!p || !confirm(`Delete ${p.name}? Wins remain as 'Unknown'.`)) return; const dB = playerListManagementUl.querySelector(`.player-management-entry[data-player-id="${playerId}"] .delete-player-btn`); if (dB) dB.disabled = true; try { await deleteDoc(doc(db, "players", playerId)); players = players.filter(pl => pl.id !== playerId); renderApp(); } catch (error) { console.error("Error deleting:", error); alert(`Failed: ${error.message}`); if (dB) dB.disabled = false; } };
        const renamePlayer = async (playerId, newName) => { if (!db) { alert("DB error."); return false; } const tN = newName.trim(); if (!tN) { alert("Name empty."); return false; } if (players.some(p => p.id !== playerId && p.name.toLowerCase() === tN.toLowerCase())) { alert("Name exists."); return false; } const pI = players.findIndex(p => p.id === playerId); if (pI === -1) return false; const en = playerListManagementUl.querySelector(`.player-management-entry[data-player-id="${playerId}"]`); const sB = en?.querySelector('.save-rename-btn'); const cB = en?.querySelector('.cancel-rename-btn'); if(sB) sB.disabled = true; if(cB) cB.disabled = true; try { await updateDoc(doc(db, "players", playerId), { name: tN }); players[pI].name = tN; players.sort((a, b) => a.name.localeCompare(b.name)); renderApp(); return true; } catch (error) { console.error("Error renaming:", error); alert(`Failed: ${error.message}`); if(sB) sB.disabled = false; if(cB) cB.disabled = false; return false; } };
        const recordWin = async (playerId) => { if (!db) { alert("DB error."); return; } const player = players.find(pl => pl.id === playerId); if (!player) return; const winButton = scoreTrackingListUl.querySelector(`button.add-win-btn[data-player-id="${playerId}"]`); const playerInfoDiv = scoreTrackingListUl.querySelector(`li[data-player-id="${playerId}"] .player-info`); if (winButton) winButton.disabled = true; const existingFeedback = playerInfoDiv?.querySelector('.win-feedback'); if (existingFeedback) existingFeedback.remove(); try { const docRef = await addDoc(collection(db, "wins"), { playerId: playerId, timestamp: serverTimestamp() }); const newWin = { id: docRef.id, playerId: playerId, timestamp: Timestamp.now() }; wins.unshift(newWin); const playerName = sanitizeHTML(player.name); const feedbackSpan = document.createElement('span'); feedbackSpan.className = 'win-feedback'; feedbackSpan.textContent = `Win added for ${playerName}!`; if (playerInfoDiv) { playerInfoDiv.appendChild(feedbackSpan); setTimeout(() => { feedbackSpan.remove(); }, 3000); } renderTodaysWinsList(); renderDashboard(); } catch (error) { console.error("Error recording win:", error); alert(`Failed to record win: ${error.message}`); } finally { setTimeout(() => { if (winButton) winButton.disabled = false; }, 500); } };
        const deleteWin = async (winId) => { if (!db) { alert("DB error."); return; } const wI = wins.findIndex(w => w.id === winId); if (wI === -1) return; const wD = wins[wI]; if (!wD.timestamp || typeof wD.timestamp.toDate !== 'function') return; const pN = players.find(p=>p.id === wD.playerId)?.name ?? 'Unknown Player'; if (!confirm(`Delete win for ${sanitizeHTML(pN)} at ${formatTime(wD.timestamp)}?`)) return; const dB = todaysWinsListUl.querySelector(`li[data-win-id="${winId}"] .delete-win-btn`); if(dB) dB.disabled = true; try { await deleteDoc(doc(db, "wins", winId)); wins.splice(wI, 1); renderTodaysWinsList(); renderDashboard(); } catch (error) { console.error("Error deleting win:", error); alert(`Failed: ${error.message}`); if(dB) dB.disabled = false; } };
        const getWinsForPeriodLocal = (period, baseDate = new Date()) => { const { start, end } = getPeriodRange(period, baseDate); const sT = start.getTime(); const eT = end.getTime(); return wins.filter(w => { if (!w.timestamp || typeof w.timestamp.toDate !== 'function') return false; const wT = w.timestamp.toDate().getTime(); return wT >= sT && wT <= eT; }); };
        const getWinsForYearLocal = (year) => { const s = new Date(year, 0, 1); const e = new Date(year, 11, 31, 23, 59, 59, 999); const sT = s.getTime(); const eT = e.getTime(); return wins.filter(w => { if (!w.timestamp || typeof w.timestamp.toDate !== 'function') return false; const wT = w.timestamp.toDate().getTime(); return wT >= sT && wT <= eT; }); };

        // --- Rendering Functions ---
        // (Keep existing rendering functions)
        const renderPlayerManagementList = () => { playerListManagementUl.innerHTML = ''; noPlayersManagedMsg.classList.toggle('hidden', players.length > 0); if (players.length === 0) return; players.forEach(p => { const li = document.createElement('li'); li.className = 'player-management-entry'; li.dataset.playerId = p.id; const sN = sanitizeHTML(p.name); li.innerHTML = ` <span class="player-name-display">${sN}</span> <div class="rename-controls hidden"> <input type="text" class="rename-input" value="${sN}" aria-label="New name for ${sN}"> <button class="save-rename-btn icon-button" aria-label="Save rename">✔️</button> <button class="cancel-rename-btn icon-button secondary" aria-label="Cancel rename">❌</button> </div> <div class="action-buttons"> <button class="rename-btn icon-button secondary" aria-label="Rename ${sN}">✏️ Rename</button> <button class="delete-player-btn icon-button danger" aria-label="Delete ${sN}">🗑️ Delete</button> </div> `; playerListManagementUl.appendChild(li); }); };
        const renderScoreTrackingList = () => { scoreTrackingListUl.innerHTML = ''; noPlayersForScoringMsg.classList.toggle('hidden', players.length > 0); if (players.length === 0) return; players.forEach(p => { const li = document.createElement('li'); li.dataset.playerId = p.id; const sN = sanitizeHTML(p.name); li.innerHTML = ` <div class="player-info"> <span class="player-name">${sN}</span> </div> <button class="add-win-btn" data-player-id="${p.id}">+ Win</button> `; scoreTrackingListUl.appendChild(li); }); };
        const renderTodaysWinsList = () => { todaysWinsListUl.innerHTML = ''; todaysSummaryDiv.innerHTML = ''; todaysSummaryDiv.classList.add('hidden'); const todayStr = getTodayDateString(); todayDateDisplay.textContent = todayStr; const todaysWins = wins.filter(w => w.timestamp?.toDate().toDateString() === todayStr); noWinsTodayMsg.classList.toggle('hidden', todaysWins.length > 0); if (todaysWins.length > 0) { const winsByPlayerToday = todaysWins.reduce((acc, win) => { acc[win.playerId] = (acc[win.playerId] || 0) + 1; return acc; }, {}); const summaryItems = []; const sortedPlayerIds = Object.keys(winsByPlayerToday).sort((a, b) => { const playerA = players.find(p => p.id === a); const playerB = players.find(p => p.id === b); const nameA = playerA ? playerA.name : 'Unknown'; const nameB = playerB ? playerB.name : 'Unknown'; return nameA.localeCompare(nameB); }); sortedPlayerIds.forEach(playerId => { const count = winsByPlayerToday[playerId]; const player = players.find(p => p.id === playerId); const playerName = player ? sanitizeHTML(player.name) : 'Unknown Player'; summaryItems.push(`<span>${playerName}: ${pluralize(count, 'win')}</span>`); }); if (summaryItems.length > 0) { todaysSummaryDiv.innerHTML = `<strong>Summary:</strong> ${summaryItems.join(' ')}`; todaysSummaryDiv.classList.remove('hidden'); } todaysWins.forEach(w => { const player = players.find(pl => pl.id === w.playerId); const playerName = player ? sanitizeHTML(player.name) : 'Unknown Player'; const li = document.createElement('li'); li.dataset.winId = w.id; li.innerHTML = ` <span class="player-name">${playerName}</span> <span class="win-timestamp">${formatTime(w.timestamp)}</span> <button class="delete-win-btn icon-button danger" aria-label="Delete this win">🗑️</button> `; todaysWinsListUl.appendChild(li); }); } };
        const renderDashboard = () => { /* console.log(`renderDashboard - View: ${currentView}, Period: ${currentDashboardPeriod}, Date: ${currentDisplayDate.toDateString()}`); */ dashboardControls.querySelectorAll('button[data-period]').forEach(b => { b.classList.toggle('active', b.dataset.period === currentDashboardPeriod); }); playerViewBtn.classList.toggle('active', currentView === 'player'); monthlyViewBtn.classList.toggle('active', currentView === 'monthly'); winChartContainer.classList.toggle('hidden', currentView !== 'player'); monthlyChartContainer.classList.toggle('hidden', currentView === 'player'); if (currentView === 'player') { renderPlayerWinsChart(currentDashboardPeriod, currentDisplayDate); } else if (currentView === 'monthly') { renderMonthlyBreakdownChart(currentDisplayDate.getFullYear()); } };
        const renderPlayerWinsChart = (period, displayDate) => { /* console.log(`renderPlayerWinsChart - Period: ${period}, Date: ${displayDate.toDateString()}`); */ if (playerWinChartInstance) { playerWinChartInstance.destroy(); playerWinChartInstance = null; } const { start, end } = getPeriodRange(period, displayDate); let chartTitleText = ''; const today = new Date(); today.setHours(0, 0, 0, 0); const currentPeriodRange = getPeriodRange(period, today); const isCurrentPeriod = currentPeriodRange.start.getTime() === start.getTime(); switch (period) { case 'week': chartTitleText = isCurrentPeriod ? 'Wins This Week' : `Week of ${start.toLocaleDateString()}`; break; case 'month': const monthName = getFullMonthName(displayDate.getMonth()); chartTitleText = isCurrentPeriod ? `Wins This ${monthName}` : `Wins ${monthName} ${displayDate.getFullYear()}`; break; case 'year': chartTitleText = isCurrentPeriod ? `Wins This Year (${displayDate.getFullYear()})` : `Wins ${displayDate.getFullYear()}`; break; } winChartTitle.textContent = chartTitleText; prevPeriodBtn.classList.remove('hidden'); nextPeriodBtn.classList.remove('hidden'); const endOfToday = new Date(); endOfToday.setHours(23, 59, 59, 999); nextPeriodBtn.disabled = end.getTime() >= endOfToday.getTime(); const periodWins = getWinsForPeriodLocal(period, displayDate); const totalWinsCount = periodWins.length; totalPlayerWinsDisplay.textContent = `Total Wins: ${totalWinsCount}`; totalPlayerWinsDisplay.classList.remove('hidden'); const hasPlayers = players.length > 0; const hasData = totalWinsCount > 0; let playerData = []; if (hasPlayers) { const winsByPlayer = players.reduce((acc, p) => { acc[p.id] = { name: p.name, count: 0 }; return acc; }, {}); periodWins.forEach(w => { if (w.playerId && winsByPlayer[w.playerId]) { winsByPlayer[w.playerId].count++; } }); playerData = Object.values(winsByPlayer); playerData.sort((a, b) => a.name.localeCompare(b.name)); } const showChart = hasPlayers && hasData; playerWinCanvas.classList.toggle('hidden', !showChart); noChartDataMsg.classList.toggle('hidden', showChart); if (!hasPlayers) { noChartDataMsg.textContent = "Add players to see statistics."; totalPlayerWinsDisplay.classList.add('hidden'); } else if (!hasData) { noChartDataMsg.textContent = "No wins recorded for this period."; } if (showChart) { const ctx = playerWinCanvas.getContext('2d'); if (!ctx) { console.error("Failed to get playerWinCanvas context"); return; } const labels = playerData.map(p => p.name); const dataCounts = playerData.map(p => p.count); playerWinChartInstance = new Chart(ctx, { type: 'bar', data: { labels: labels, datasets: [{ label: 'Wins', data: dataCounts, backgroundColor: '#219ebc', borderColor: '#1a7f9a', borderWidth: 1 }] }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true, ticks: { stepSize: 1, precision: 0 } } }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: function(c) { let l = c.dataset.label || ''; if (l) { l += ': '; } if (c.parsed.y !== null) { l += c.parsed.y + (c.parsed.y === 1 ? ' win' : ' wins'); } return l; } } } } } }); } };
        const renderMonthlyBreakdownChart = (year) => { /* console.log(`renderMonthlyBreakdownChart - Year: ${year}`); */ if (monthlyChartInstance) { monthlyChartInstance.destroy(); monthlyChartInstance = null; } monthlyChartTitle.textContent = `Monthly Winners for ${year}`; nextYearBtn.disabled = year >= new Date().getFullYear(); const yearWins = getWinsForYearLocal(year); const totalWinsCount = yearWins.length; const hasData = totalWinsCount > 0; totalMonthlyWinsDisplay.textContent = `Total Wins: ${totalWinsCount}`; totalMonthlyWinsDisplay.classList.remove('hidden'); let monthlyResults = []; let overallMaxWinningScore = 0; if(hasData) { const monthlyPlayerWins = {}; yearWins.forEach(win => { if (win.timestamp && typeof win.timestamp.toDate === 'function' && win.playerId) { const mI = win.timestamp.toDate().getMonth(); monthlyPlayerWins[mI] = monthlyPlayerWins[mI] || {}; monthlyPlayerWins[mI][win.playerId] = (monthlyPlayerWins[mI][win.playerId] || 0) + 1; } }); for (let i = 0; i < 12; i++) { const monthData = monthlyPlayerWins[i]; let winners = []; let maxScore = 0; if (monthData && Object.keys(monthData).length > 0) { maxScore = Math.max(...Object.values(monthData)); if (maxScore > overallMaxWinningScore) { overallMaxWinningScore = maxScore; } winners = Object.entries(monthData) .filter(([_, score]) => score === maxScore) .map(([playerId, _]) => sanitizeHTML(players.find(p => p.id === playerId)?.name ?? 'Unknown')); } monthlyResults.push({ monthIndex: i, winnerNames: winners, winningScore: maxScore }); } } else { for (let i = 0; i < 12; i++) { monthlyResults.push({ monthIndex: i, winnerNames: [], winningScore: 0 }); } } monthlyWinsCanvas.classList.toggle('hidden', !hasData); noMonthlyChartDataMsg.classList.toggle('hidden', hasData); if (!hasData) { noMonthlyChartDataMsg.textContent = `No wins recorded for ${year}.`; } if(hasData) { const ctx = monthlyWinsCanvas.getContext('2d'); if (!ctx) { console.error("Failed to get monthlyWinsCanvas context"); return; } const labels = monthlyResults.map(r => getMonthName(r.monthIndex)); const dataScores = monthlyResults.map(r => r.winningScore); const yAxisMax = Math.max(3, overallMaxWinningScore + 2); monthlyChartInstance = new Chart(ctx, { type: 'bar', data: { labels: labels, datasets: [{ label: 'Winning Score', data: dataScores, backgroundColor: '#fdc500', borderColor: '#e8b700', borderWidth: 1 }] }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true, max: yAxisMax, ticks: { stepSize: 1, precision: 0 } } }, plugins: { legend: { display: false }, tooltip: { callbacks: { title: (tooltipItems) => `${getFullMonthName(tooltipItems[0].dataIndex)} ${year}`, label: (context) => { const index = context.dataIndex; const result = monthlyResults[index]; let winnerLabel = ''; if (!result || result.winnerNames.length === 0) winnerLabel = 'Winner: N/A'; else if (result.winnerNames.length === 1) winnerLabel = `Winner: ${result.winnerNames[0]}`; else winnerLabel = `Tie: ${result.winnerNames.join(', ')}`; const scoreLabel = `Score: ${context.parsed.y}`; return [winnerLabel, scoreLabel]; } } }, datalabels: { display: (context) => context.dataset.data[context.dataIndex] > 0, anchor: 'end', align: 'top', offset: -2, color: '#555', font: { size: 10, weight: 'bold' }, formatter: (value, context) => { const index = context.dataIndex; const result = monthlyResults[index]; if (!result || result.winnerNames.length === 0) { return ''; } else if (result.winnerNames.length === 1) { let name = result.winnerNames[0]; return name.length > 8 ? name.substring(0, 7) + '…' : name; } else { return 'Tie'; } } } } } }); } };
        const renderApp = () => { renderPlayerManagementList(); renderScoreTrackingList(); renderTodaysWinsList(); renderDashboard(); };


        // --- Timer Functions ---
        const formatTimerTime = (totalSeconds) => { const minutes = Math.floor(totalSeconds / 60); const seconds = totalSeconds % 60; return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`; };
        const updateTimerDisplay = () => { timerDisplay.textContent = formatTimerTime(timerRemainingSeconds); };
        const updateTimerFill = () => { const percentage = (timerRemainingSeconds / TIMER_DURATION_SECONDS) * 100; timerFill.style.height = `${percentage}%`; };

        // Audio Unlock Function (Revised)
        const unlockAudioContext = () => {
            // No need to check audioUnlocked flag here, as we might need to re-unlock
            if (!timerAudio || timerAudio.readyState < 1) { // Ensure audio element exists and potentially loaded
                 console.warn("Audio element not ready for unlock attempt.");
                 return;
            }
            // Play and immediately pause/reset.
            const playPromise = timerAudio.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    timerAudio.pause();
                    // Don't reset currentTime here if we want the beep to play from start later
                    // timerAudio.currentTime = 0;
                    if (!audioUnlocked) {
                         console.log("Audio context unlocked by user interaction.");
                         audioUnlocked = true; // Set flag only on first successful unlock
                    } else {
                         console.log("Audio context potentially re-activated.");
                    }
                }).catch(error => {
                     // Ignore 'AbortError' which can happen if pause() interrupts play() quickly
                     if (error.name !== 'AbortError') {
                         console.warn("Audio unlock/reactivation attempt failed:", error.name, error.message);
                         audioUnlocked = false; // Consider it locked if a real error occurs
                     } else {
                         // If it's just AbortError, the unlock likely worked fine
                          if (!audioUnlocked) {
                             console.log("Audio context unlocked (AbortError ignored).");
                             audioUnlocked = true;
                          } else {
                             console.log("Audio context potentially re-activated (AbortError ignored).");
                          }
                     }
                });
            }
            // No fallback needed here as we call this from user interaction context
        };

        // Play Beep Sound Function (Keep previous robust version)
        const playBeepSound = () => {
            if (!timerAudio) return;
            console.log(`Attempting to play beep sound (Audio Unlocked: ${audioUnlocked}, Ready State: ${timerAudio.readyState})`);

            if (!audioUnlocked) {
                 console.warn("Audio context is not unlocked. Beep may fail.");
                 // Optional: Attempt a last-ditch unlock here? Risky as it's not user-initiated.
                 // unlockAudioContext(); // Probably won't work reliably here.
            }

            // Ensure audio is ready to play
             if (timerAudio.readyState >= 2) { // HAVE_CURRENT_DATA or more
                 timerAudio.currentTime = 0; // Reset playback position first
                 const playPromise = timerAudio.play();

                 if (playPromise !== undefined) {
                     playPromise.then(() => {
                         console.log("Beep sound played successfully.");
                     }).catch(error => {
                         console.error("Timer audio playback failed:", error.name, error.message);
                         // If it fails here, the context might have been suspended again.
                         audioUnlocked = false; // Mark as potentially locked again
                     });
                 }
             } else {
                 console.warn("Audio not ready to play (readyState < 2). Attempting to load.");
                 timerAudio.load(); // Try to trigger loading
                 // We could try playing again after a short delay, but it gets complex.
                 // Best effort is to rely on initial unlock + visibilitychange unlock.
             }
        };

        // Timer Tick function (using setTimeout)
        const timerTick = () => {
             // Check if timer should still be running
             if (!isTimerVisible) {
                 console.log("Timer tick called but timer is hidden. Stopping.");
                 stopTimer(); // Ensure cleanup if somehow called while hidden
                 return;
             }

             timerRemainingSeconds--;
             // console.log(`Timer Tick: ${timerRemainingSeconds}s remaining`); // Optional: Debug log

             if (timerRemainingSeconds < 0) {
                 console.log("Timer reached 0 - Attempting Beep"); // Log before playing
                 playBeepSound();
                 timerRemainingSeconds = TIMER_DURATION_SECONDS; // Reset for next cycle
                 // NOTE: The timer visually resets here. If you want it to STOP at 0,
                 // you'd call stopTimer() here instead of resetting.
                 // The current logic assumes it keeps running/cycling until manually stopped or hidden.
             }

             updateTimerDisplay();
             updateTimerFill();

             // Schedule the next tick
             timerTimeoutId = setTimeout(timerTick, 1000);
        };

        // Function to start the timer using chained setTimeout
        const startTimer = () => {
            stopTimer(); // Clear any existing timer first
            console.log("Starting timer (using setTimeout chain)...");
            isTimerVisible = true; // Mark as visible when started

            // Make sure initial state is correct before first tick
            timerRemainingSeconds = (timerRemainingSeconds > 0 && timerRemainingSeconds <= TIMER_DURATION_SECONDS)
                 ? timerRemainingSeconds // Resume if already started (e.g. after NEXT)
                 : TIMER_DURATION_SECONDS; // Start fresh otherwise

            updateTimerDisplay();
            updateTimerFill();

            // Start the first tick
            timerTimeoutId = setTimeout(timerTick, 1000);
        };

        // Function to stop the timer
        const stopTimer = () => {
            if (timerTimeoutId) {
                clearTimeout(timerTimeoutId);
                timerTimeoutId = null;
                console.log("Timer stopped (cleared timeout).");
            }
             // Note: We don't set isTimerVisible = false here, that's done by hideTimer()
        };


        // UPDATED: Call unlockAudioContext on "NEXT" button press
        const handleNextTimerClick = () => {
            console.log("Next Timer button clicked");
            unlockAudioContext(); // Ensure audio is ready on this interaction
            stopTimer(); // Stop current timer chain
            timerRemainingSeconds = TIMER_DURATION_SECONDS; // Reset time
            updateTimerDisplay();
            updateTimerFill();
            // Play immediately on NEXT click
            // Small delay to potentially allow UI update before sound
             setTimeout(() => {
                playBeepSound();
             }, 50);
            startTimer(); // Start the countdown again
        };

        // --- Wake Lock Functions (Keep existing) ---
        const requestWakeLock = async () => { if ('wakeLock' in navigator) { try { wakeLockSentinel = await navigator.wakeLock.request('screen'); console.log('Screen Wake Lock requested successfully.'); wakeLockSentinel.addEventListener('release', () => { console.log('Screen Wake Lock was released'); if (isTimerVisible) { console.warn('Wake Lock released unexpectedly while timer visible.'); /* Consider re-requesting? */ } wakeLockSentinel = null; }); } catch (err) { console.error(`Wake Lock Request Failed: ${err.name}, ${err.message}`); wakeLockSentinel = null; } } else { console.warn('Screen Wake Lock API not supported.'); } };
        const releaseWakeLock = async () => { if (wakeLockSentinel !== null && typeof wakeLockSentinel.release === 'function') { try { await wakeLockSentinel.release(); wakeLockSentinel = null; console.log('Screen Wake Lock released.'); } catch (err) { console.error(`Failed to release Wake Lock: ${err.name}, ${err.message}`); wakeLockSentinel = null; } } };

        // --- Timer Show/Hide (Modified for setTimeout and Audio Unlock) ---
        const showTimer = async () => {
            if (isTimerVisible) return; // Already visible
            console.log("Showing timer...");

            // Attempt to unlock audio on the interaction that shows the timer
            unlockAudioContext();

            timerOverlay.style.display = 'flex';
            toggleTimerBtn.textContent = '⏱️ Hide Timer';
            toggleTimerBtn.setAttribute('aria-label', 'Hide Timer');

            await requestWakeLock(); // Request wake lock

            // Don't reset timerRemainingSeconds here, startTimer() handles it
            // timerRemainingSeconds = TIMER_DURATION_SECONDS;

            startTimer(); // This now sets isTimerVisible = true and starts the chain
        };

        const hideTimer = async () => {
            if (!isTimerVisible) return; // Already hidden
            console.log("Hiding timer...");
            isTimerVisible = false; // Mark as hidden FIRST
            stopTimer(); // Stop the timer chain

            timerOverlay.style.display = 'none';
            toggleTimerBtn.textContent = '⏱️ Timer';
            toggleTimerBtn.setAttribute('aria-label', 'Show Timer');

            await releaseWakeLock(); // Release wake lock

            // Pause and reset audio state
            if (timerAudio) {
                 timerAudio.pause();
                 timerAudio.currentTime = 0;
            }

            // Reset visual state and remaining time state AFTER stopping
            timerFill.style.height = '100%';
            timerRemainingSeconds = TIMER_DURATION_SECONDS;
            updateTimerDisplay();
        };


        // --- Event Listeners ---

        // Player Management Listeners (Keep existing)
        togglePlayerManagementBtn.addEventListener('click', () => { playerManagementSection.classList.toggle('hidden'); const i = playerManagementSection.classList.contains('hidden'); togglePlayerManagementBtn.setAttribute('aria-expanded',!i); togglePlayerManagementBtn.textContent = i?'⚙️ Manage':'🔽 Close'; });
        addPlayerBtn.addEventListener('click', () => addPlayer(newPlayerNameInput.value));
        newPlayerNameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') { e.preventDefault(); addPlayer(newPlayerNameInput.value); } addPlayerError.textContent = ""; });
        playerListManagementUl.addEventListener('click', (e) => { const t = e.target; const pE = t.closest('.player-management-entry'); if (!pE) return; const pId = pE.dataset.playerId; if (t.classList.contains('delete-player-btn')) { deletePlayer(pId); } else if (t.classList.contains('rename-btn')) { playerListManagementUl.querySelectorAll('.rename-controls:not(.hidden)').forEach(c => { const en = c.closest('.player-management-entry'); if (en && en !== pE) { en.querySelector('.rename-controls').classList.add('hidden'); en.querySelector('.player-name-display').classList.remove('hidden'); en.querySelector('.action-buttons').classList.remove('hidden'); } }); pE.querySelector('.player-name-display').classList.add('hidden'); pE.querySelector('.action-buttons').classList.add('hidden'); const rC = pE.querySelector('.rename-controls'); rC.classList.remove('hidden'); const i = rC.querySelector('.rename-input'); i.focus(); i.select(); } else if (t.classList.contains('save-rename-btn')) { const i = pE.querySelector('.rename-input'); renamePlayer(pId, i.value); } else if (t.classList.contains('cancel-rename-btn')) { const oN = pE.querySelector('.player-name-display').textContent; pE.querySelector('.rename-input').value = oN; pE.querySelector('.rename-controls').classList.add('hidden'); pE.querySelector('.player-name-display').classList.remove('hidden'); pE.querySelector('.action-buttons').classList.remove('hidden'); } });
        playerListManagementUl.addEventListener('keypress', (e) => { if (e.key === 'Enter' && e.target.classList.contains('rename-input')) { e.preventDefault(); const pE = e.target.closest('.player-management-entry'); if (pE) renamePlayer(pE.dataset.playerId, e.target.value); } });

        // Score Tracking / Today's Wins Listeners (Keep existing)
        scoreTrackingListUl.addEventListener('click', (e) => { if (e.target.classList.contains('add-win-btn') && !e.target.disabled) { recordWin(e.target.dataset.playerId); } });
        todaysWinsListUl.addEventListener('click', (e) => { if (e.target.classList.contains('delete-win-btn') && !e.target.disabled) { const wL = e.target.closest('li'); if (wL?.dataset.winId) deleteWin(wL.dataset.winId); } });

        // Dashboard Controls Listener (Keep existing)
        dashboardControls.addEventListener('click', (e) => { if (e.target.tagName === 'BUTTON' && e.target.dataset.period) { const newlySelectedPeriod = e.target.dataset.period; console.log(`Dashboard Control Clicked: ${newlySelectedPeriod}`); currentDisplayDate = new Date(); /* console.log(`Date RESET to: ${currentDisplayDate.toDateString()}`); */ currentDashboardPeriod = newlySelectedPeriod; currentView = 'player'; renderDashboard(); } });

        // View Toggle Button Listeners (Keep existing)
        playerViewBtn.addEventListener('click', () => { /* console.log("Player View Button Clicked"); */ if (currentView !== 'player') { currentView = 'player'; renderDashboard(); } });
        monthlyViewBtn.addEventListener('click', () => { /* console.log("Monthly View Button Clicked"); */ if (currentView !== 'monthly') { currentView = 'monthly'; renderDashboard(); } });

        // Period Navigation Button Listeners (Keep existing)
        prevPeriodBtn.addEventListener('click', () => { const oldDate = new Date(currentDisplayDate); if (currentDashboardPeriod === 'week') { currentDisplayDate.setDate(currentDisplayDate.getDate() - 7); } else if (currentDashboardPeriod === 'month') { currentDisplayDate.setMonth(currentDisplayDate.getMonth() - 1); } else if (currentDashboardPeriod === 'year') { currentDisplayDate.setFullYear(currentDisplayDate.getFullYear() - 1); } /* console.log(`Prev Period Clicked. Old: ${oldDate.toDateString()}, New: ${currentDisplayDate.toDateString()}`); */ renderDashboard(); });
        nextPeriodBtn.addEventListener('click', () => { const oldDate = new Date(currentDisplayDate); if (currentDashboardPeriod === 'week') { currentDisplayDate.setDate(currentDisplayDate.getDate() + 7); } else if (currentDashboardPeriod === 'month') { const tempDate = new Date(currentDisplayDate); tempDate.setMonth(tempDate.getMonth() + 1); const today = new Date(); if (tempDate.getFullYear() < today.getFullYear() || (tempDate.getFullYear() === today.getFullYear() && tempDate.getMonth() <= today.getMonth())) { currentDisplayDate.setMonth(currentDisplayDate.getMonth() + 1); } else { console.log("Next month navigation blocked."); nextPeriodBtn.disabled = true; return; } } else if (currentDashboardPeriod === 'year') { const nextYear = currentDisplayDate.getFullYear() + 1; if (nextYear <= new Date().getFullYear()) { currentDisplayDate.setFullYear(nextYear); } else { console.log("Next year navigation blocked."); nextPeriodBtn.disabled = true; return; } } /* console.log(`Next Period Clicked. Old: ${oldDate.toDateString()}, New: ${currentDisplayDate.toDateString()}`); */ renderDashboard(); });
        prevYearBtn.addEventListener('click', () => { const oldDate = new Date(currentDisplayDate); currentDisplayDate.setFullYear(currentDisplayDate.getFullYear() - 1); /* console.log(`Prev Year Clicked. Old: ${oldDate.toDateString()}, New: ${currentDisplayDate.toDateString()}`); */ renderDashboard(); });
        nextYearBtn.addEventListener('click', () => { const oldDate = new Date(currentDisplayDate); const nextYear = currentDisplayDate.getFullYear() + 1; if (nextYear <= new Date().getFullYear()) { currentDisplayDate.setFullYear(nextYear); /* console.log(`Next Year Clicked. Old: ${oldDate.toDateString()}, New: ${currentDisplayDate.toDateString()}`); */ renderDashboard(); } else { console.log("Next year navigation blocked."); nextYearBtn.disabled = true; } });

        // Timer Event Listeners
        toggleTimerBtn.addEventListener('click', () => { if (isTimerVisible) { hideTimer(); } else { showTimer(); } });
        hideTimerBtn.addEventListener('click', hideTimer);
        nextTimerBtn.addEventListener('click', handleNextTimerClick);

        // Visibility Change Listener (Critical for Mobile)
         document.addEventListener('visibilitychange', async () => {
             console.log(`Visibility changed to: ${document.visibilityState}`);

             if (document.visibilityState === 'visible') {
                 // --- Re-acquire Wake Lock if necessary ---
                 if (isTimerVisible && !wakeLockSentinel) {
                     console.log("Page visible, timer active, but no wake lock. Re-requesting wake lock.");
                     await requestWakeLock();
                 }
                 // --- Attempt to re-unlock/re-activate Audio Context ---
                 // This is crucial if the browser suspended it while backgrounded
                 if (isTimerVisible) { // Only if timer is supposed to be running
                      console.log("Page visible, attempting to re-activate audio context.");
                      unlockAudioContext();
                 }
                 // --- Optional: Resume Timer if stopped by extreme throttling? ---
                 // If the timeout chain was completely broken, we might need to restart it.
                 // Check if the timer *should* be running but isn't (no timeout ID)
                 // if (isTimerVisible && !timerTimeoutId) {
                 //     console.warn("Timer was visible but timeout loop was broken. Restarting tick.");
                 //     startTimer(); // Or maybe just timerTick() if state is preserved? Careful here.
                 // }

             } else { // document.visibilityState === 'hidden'
                // --- Optional: Release Wake Lock proactively? ---
                // Browsers usually handle this, but explicit release might be cleaner.
                // console.log("Page hidden, releasing wake lock proactively.");
                // await releaseWakeLock(); // Be careful, might interfere if quickly switching back

                // --- Audio context will likely be suspended by the browser ---
                console.log("Page hidden, audio context likely to be suspended.");
             }
         });

        // --- Initial Load ---
        (async () => {
            if (typeof ChartDataLabels !== 'undefined') { Chart.register(ChartDataLabels); } else { console.error("ChartDataLabels plugin not loaded!"); }
            currentView = 'player';
            currentDashboardPeriod = 'month';
            currentDisplayDate = new Date();
            updateTimerDisplay(); // Set initial timer display
            timerAudio.load(); // Ensure audio attempts to load
            await loadData(); // Load data and trigger initial renderApp()
        })();

    </script>

</body>
</html>
